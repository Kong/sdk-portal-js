/* tslint:disable */
/* eslint-disable */
/**
 * Portal API
 * Portal API
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Application creation response payload
 * @export
 * @interface ApplicationCreationResponse
 */
export interface ApplicationCreationResponse {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'reference_id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'redirect_uri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCreationResponse
     */
    'is_dcr': boolean;
    /**
     * 
     * @type {ApplicationCreationResponseCredentials}
     * @memberof ApplicationCreationResponse
     */
    'credentials'?: ApplicationCreationResponseCredentials;
}
/**
 * 
 * @export
 * @interface ApplicationCreationResponseCredentials
 */
export interface ApplicationCreationResponseCredentials {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponseCredentials
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponseCredentials
     */
    'client_secret': string;
}
/**
 * 
 * @export
 * @interface ApplicationRegistrationConfiguration
 */
export interface ApplicationRegistrationConfiguration {
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationRegistrationConfiguration
     */
    'auto_approve': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationRegistrationConfiguration
     */
    'status': ApplicationRegistrationConfigurationStatusEnum;
    /**
     * 
     * @type {ApplicationRegistrationConfigurationAuthConfig}
     * @memberof ApplicationRegistrationConfiguration
     */
    'auth_config': ApplicationRegistrationConfigurationAuthConfig;
}

export const ApplicationRegistrationConfigurationStatusEnum = {
    Enabled: 'enabled',
    Pending: 'pending'
} as const;

export type ApplicationRegistrationConfigurationStatusEnum = typeof ApplicationRegistrationConfigurationStatusEnum[keyof typeof ApplicationRegistrationConfigurationStatusEnum];

/**
 * 
 * @export
 * @interface ApplicationRegistrationConfigurationAuthConfig
 */
export interface ApplicationRegistrationConfigurationAuthConfig {
    /**
     * 
     * @type {string}
     * @memberof ApplicationRegistrationConfigurationAuthConfig
     */
    'name'?: ApplicationRegistrationConfigurationAuthConfigNameEnum;
    /**
     * 
     * @type {object}
     * @memberof ApplicationRegistrationConfigurationAuthConfig
     */
    'config'?: object;
}

export const ApplicationRegistrationConfigurationAuthConfigNameEnum = {
    KeyAuth: 'key-auth',
    OpenidConnect: 'openid-connect'
} as const;

export type ApplicationRegistrationConfigurationAuthConfigNameEnum = typeof ApplicationRegistrationConfigurationAuthConfigNameEnum[keyof typeof ApplicationRegistrationConfigurationAuthConfigNameEnum];

/**
 * Application update response payload
 * @export
 * @interface ApplicationUpdateResponse
 */
export interface ApplicationUpdateResponse {
    /**
     * 
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'reference_id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'redirect_uri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUpdateResponse
     */
    'is_dcr': boolean;
}
/**
 * an application payload
 * @export
 * @interface CreateApplicationPayload
 */
export interface CreateApplicationPayload {
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'reference_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'redirect_uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateCredentialPayload
 */
export interface CreateCredentialPayload {
    /**
     * 
     * @type {string}
     * @memberof CreateCredentialPayload
     */
    'display_name'?: string;
}
/**
 * 
 * @export
 * @interface CredentialCreationResponse
 */
export interface CredentialCreationResponse {
    /**
     * 
     * @type {string}
     * @memberof CredentialCreationResponse
     */
    'credential': string;
    /**
     * 
     * @type {string}
     * @memberof CredentialCreationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CredentialCreationResponse
     */
    'display_name': string;
}
/**
 * 
 * @export
 * @interface ErrorInvalidParametersInner
 */
export interface ErrorInvalidParametersInner {
    /**
     * The name of the invalid parameter.
     * @type {string}
     * @memberof ErrorInvalidParametersInner
     */
    'name'?: string;
    /**
     * The reason the parameter is invalid.
     * @type {string}
     * @memberof ErrorInvalidParametersInner
     */
    'reason'?: string;
    /**
     * The field that caused the error.
     * @type {string}
     * @memberof ErrorInvalidParametersInner
     */
    'field'?: string;
    /**
     * The rule that caused the error.
     * @type {string}
     * @memberof ErrorInvalidParametersInner
     */
    'rule'?: string;
}
/**
 * 
 * @export
 * @interface GetApplicationResponse
 */
export interface GetApplicationResponse {
    /**
     * 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'reference_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'redirect_uri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplicationResponse
     */
    'is_dcr': boolean;
}
/**
 * 
 * @export
 * @interface GetCredentialsResponse
 */
export interface GetCredentialsResponse {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof GetCredentialsResponse
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<GetCredentialsResponseDataInner>}
     * @memberof GetCredentialsResponse
     */
    'data': Array<GetCredentialsResponseDataInner>;
}
/**
 * 
 * @export
 * @interface GetCredentialsResponseDataInner
 */
export interface GetCredentialsResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetCredentialsResponseDataInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetCredentialsResponseDataInner
     */
    'display_name': string;
}
/**
 * 
 * @export
 * @interface GetManyApplicationsResponse
 */
export interface GetManyApplicationsResponse {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof GetManyApplicationsResponse
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<GetApplicationResponse>}
     * @memberof GetManyApplicationsResponse
     */
    'data': Array<GetApplicationResponse>;
}
/**
 * standard error
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * The HTTP status code.
     * @type {number}
     * @memberof ModelError
     */
    'status': number;
    /**
     * The error response code.
     * @type {string}
     * @memberof ModelError
     */
    'title': string;
    /**
     * The error type.
     * @type {string}
     * @memberof ModelError
     */
    'type'?: string;
    /**
     * The portal traceback code
     * @type {string}
     * @memberof ModelError
     */
    'instance': string;
    /**
     * An array of invalid parameters.
     * @type {Array<ErrorInvalidParametersInner>}
     * @memberof ModelError
     */
    'invalid_parameters'?: Array<ErrorInvalidParametersInner>;
    /**
     * Details about the error.
     * @type {string}
     * @memberof ModelError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface PageParameters
 */
export interface PageParameters {
    /**
     * 
     * @type {number}
     * @memberof PageParameters
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageParameters
     */
    'number'?: number;
}
/**
 * Returns pagination information
 * @export
 * @interface PaginatedMeta
 */
export interface PaginatedMeta {
    /**
     * 
     * @type {PaginatedMetaPage}
     * @memberof PaginatedMeta
     */
    'page'?: PaginatedMetaPage;
}
/**
 * Contains pagination query parameters and the total number of objects returned.
 * @export
 * @interface PaginatedMetaPage
 */
export interface PaginatedMetaPage {
    /**
     * Specifies the number of objects returned per page.
     * @type {number}
     * @memberof PaginatedMetaPage
     */
    'number'?: number;
    /**
     * Specifies the size of the page.
     * @type {number}
     * @memberof PaginatedMetaPage
     */
    'size'?: number;
    /**
     * Integer representation of the amount of items returned.
     * @type {number}
     * @memberof PaginatedMetaPage
     */
    'total'?: number;
}
/**
 * the portal appearance
 * @export
 * @interface PortalAppearance
 */
export interface PortalAppearance {
    /**
     * 
     * @type {PortalAppearanceVariables}
     * @memberof PortalAppearance
     */
    'variables'?: PortalAppearanceVariables;
    /**
     * 
     * @type {PortalAppearanceStylesheets}
     * @memberof PortalAppearance
     */
    'stylesheets'?: PortalAppearanceStylesheets;
}
/**
 * 
 * @export
 * @interface PortalAppearanceStylesheets
 */
export interface PortalAppearanceStylesheets {
    /**
     * 
     * @type {PortalAppearanceStylesheetsGlobal}
     * @memberof PortalAppearanceStylesheets
     */
    'global'?: PortalAppearanceStylesheetsGlobal;
}
/**
 * 
 * @export
 * @interface PortalAppearanceStylesheetsGlobal
 */
export interface PortalAppearanceStylesheetsGlobal {
    /**
     * 
     * @type {PortalAppearanceStylesheetsGlobalMain}
     * @memberof PortalAppearanceStylesheetsGlobal
     */
    'main'?: PortalAppearanceStylesheetsGlobalMain;
}
/**
 * 
 * @export
 * @interface PortalAppearanceStylesheetsGlobalMain
 */
export interface PortalAppearanceStylesheetsGlobalMain {
    /**
     * 
     * @type {object}
     * @memberof PortalAppearanceStylesheetsGlobalMain
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface PortalAppearanceVariables
 */
export interface PortalAppearanceVariables {
    /**
     * 
     * @type {PortalAppearanceVariablesCatalog}
     * @memberof PortalAppearanceVariables
     */
    'catalog'?: PortalAppearanceVariablesCatalog;
}
/**
 * 
 * @export
 * @interface PortalAppearanceVariablesCatalog
 */
export interface PortalAppearanceVariablesCatalog {
    /**
     * 
     * @type {PortalAppearanceVariablesCatalogLogo}
     * @memberof PortalAppearanceVariablesCatalog
     */
    'logo'?: PortalAppearanceVariablesCatalogLogo;
    /**
     * 
     * @type {PortalAppearanceVariablesCatalogLogo}
     * @memberof PortalAppearanceVariablesCatalog
     */
    'cover'?: PortalAppearanceVariablesCatalogLogo;
    /**
     * 
     * @type {PortalAppearanceVariablesCatalogPrimaryHeader}
     * @memberof PortalAppearanceVariablesCatalog
     */
    'primary_header'?: PortalAppearanceVariablesCatalogPrimaryHeader;
    /**
     * 
     * @type {PortalAppearanceVariablesCatalogPrimaryHeader}
     * @memberof PortalAppearanceVariablesCatalog
     */
    'welcome_message'?: PortalAppearanceVariablesCatalogPrimaryHeader;
}
/**
 * 
 * @export
 * @interface PortalAppearanceVariablesCatalogLogo
 */
export interface PortalAppearanceVariablesCatalogLogo {
    /**
     * 
     * @type {string}
     * @memberof PortalAppearanceVariablesCatalogLogo
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface PortalAppearanceVariablesCatalogPrimaryHeader
 */
export interface PortalAppearanceVariablesCatalogPrimaryHeader {
    /**
     * 
     * @type {string}
     * @memberof PortalAppearanceVariablesCatalogPrimaryHeader
     */
    'text'?: string;
}
/**
 * describe the portal execution context
 * @export
 * @interface PortalContext
 */
export interface PortalContext {
    /**
     * 
     * @type {string}
     * @memberof PortalContext
     */
    'portal_id': string;
    /**
     * 
     * @type {string}
     * @memberof PortalContext
     */
    'org_id': string;
    /**
     * 
     * @type {string}
     * @memberof PortalContext
     */
    'featureset_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof PortalContext
     */
    'basic_auth_enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortalContext
     */
    'is_public': boolean;
    /**
     * Is the portal protected with role base access
     * @type {boolean}
     * @memberof PortalContext
     */
    'rbac_enabled': boolean;
    /**
     * Is the portal using DCR application registration
     * @type {boolean}
     * @memberof PortalContext
     */
    'is_dcr': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortalContext
     */
    'oidc_auth_enabled': boolean;
}
/**
 * Refresh token response
 * @export
 * @interface RefreshTokenResponse
 */
export interface RefreshTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    'client_secret': string;
}
/**
 * Payload required to be sent to register a developer to the portal. 
 * @export
 * @interface RegisterPayload
 */
export interface RegisterPayload {
    /**
     * 
     * @type {string}
     * @memberof RegisterPayload
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterPayload
     */
    'full_name': string;
}
/**
 * Payload required to start the reset password flow 
 * @export
 * @interface ResetPasswordPayload
 */
export interface ResetPasswordPayload {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordPayload
     */
    'email': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SearchIndicesParameters = {
    ServiceCatalog: 'service-catalog'
} as const;

export type SearchIndicesParameters = typeof SearchIndicesParameters[keyof typeof SearchIndicesParameters];


/**
 * 
 * @export
 * @interface SearchParameters
 */
export interface SearchParameters {
    /**
     * 
     * @type {string}
     * @memberof SearchParameters
     */
    'q'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchParameters
     */
    'join'?: SearchParametersJoinEnum;
}

export const SearchParametersJoinEnum = {
    Documents: 'documents',
    Versions: 'versions',
    VersionsDocuments: 'versions.documents'
} as const;

export type SearchParametersJoinEnum = typeof SearchParametersJoinEnum[keyof typeof SearchParametersJoinEnum];

/**
 * 
 * @export
 * @interface SearchResults
 */
export interface SearchResults {
    /**
     * The paginated data items that matched the search query
     * @type {Array<SearchResultsDataInner>}
     * @memberof SearchResults
     */
    'data': Array<SearchResultsDataInner>;
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof SearchResults
     */
    'meta': PaginatedMeta;
}
/**
 * 
 * @export
 * @interface SearchResultsDataInner
 */
export interface SearchResultsDataInner {
    /**
     * 
     * @type {SearchIndicesParameters}
     * @memberof SearchResultsDataInner
     */
    'index': SearchIndicesParameters;
    /**
     * 
     * @type {ServiceCatalogIndexSource}
     * @memberof SearchResultsDataInner
     */
    'source': ServiceCatalogIndexSource;
}
/**
 * 
 * @export
 * @interface ServiceCatalogIndexSource
 */
export interface ServiceCatalogIndexSource {
    /**
     * The entity ID.
     * @type {string}
     * @memberof ServiceCatalogIndexSource
     */
    'id': string;
    /**
     * the name of the service
     * @type {string}
     * @memberof ServiceCatalogIndexSource
     */
    'name': string;
    /**
     * the name of the service
     * @type {string}
     * @memberof ServiceCatalogIndexSource
     */
    'display_name'?: string;
    /**
     * the name of the service
     * @type {string}
     * @memberof ServiceCatalogIndexSource
     */
    'description'?: string;
    /**
     * An ISO-8604 timestamp representation of entity creation date.
     * @type {string}
     * @memberof ServiceCatalogIndexSource
     */
    'created_at': string;
    /**
     * An ISO-8604 timestamp representation of entity update date.
     * @type {string}
     * @memberof ServiceCatalogIndexSource
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<ServiceCatalogIndexSourceVersionsInner>}
     * @memberof ServiceCatalogIndexSource
     */
    'versions'?: Array<ServiceCatalogIndexSourceVersionsInner>;
}
/**
 * 
 * @export
 * @interface ServiceCatalogIndexSourceVersionsInner
 */
export interface ServiceCatalogIndexSourceVersionsInner {
    /**
     * The entity ID.
     * @type {string}
     * @memberof ServiceCatalogIndexSourceVersionsInner
     */
    'id': string;
    /**
     * An ISO-8604 timestamp representation of entity creation date.
     * @type {string}
     * @memberof ServiceCatalogIndexSourceVersionsInner
     */
    'created_at': string;
    /**
     * An ISO-8604 timestamp representation of entity update date.
     * @type {string}
     * @memberof ServiceCatalogIndexSourceVersionsInner
     */
    'updated_at': string;
    /**
     * the name of the service
     * @type {string}
     * @memberof ServiceCatalogIndexSourceVersionsInner
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCatalogIndexSourceVersionsInner
     */
    'publish_status': ServiceCatalogIndexSourceVersionsInnerPublishStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceCatalogIndexSourceVersionsInner
     */
    'deprecated': boolean;
    /**
     * The entity ID.
     * @type {string}
     * @memberof ServiceCatalogIndexSourceVersionsInner
     */
    'tracking_id': string;
}

export const ServiceCatalogIndexSourceVersionsInnerPublishStatusEnum = {
    Published: 'published',
    Unpublished: 'unpublished'
} as const;

export type ServiceCatalogIndexSourceVersionsInnerPublishStatusEnum = typeof ServiceCatalogIndexSourceVersionsInnerPublishStatusEnum[keyof typeof ServiceCatalogIndexSourceVersionsInnerPublishStatusEnum];

/**
 * Payload required to update an application
 * @export
 * @interface UpdateApplicationPayload
 */
export interface UpdateApplicationPayload {
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationPayload
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationPayload
     */
    'reference_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationPayload
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationPayload
     */
    'redirect_uri'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCredentialPayload
 */
export interface UpdateCredentialPayload {
    /**
     * 
     * @type {string}
     * @memberof UpdateCredentialPayload
     */
    'display_name': string;
}

/**
 * AppRegApi - axios parameter creator
 * @export
 */
export const AppRegApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the application registration configuration of the given service
         * @summary Application registration Configuration
         * @param {string} id id of the service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationRegistrationConfiguration: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getApplicationRegistrationConfiguration', 'id', id)
            const localVarPath = `/api/v2/application-registrations/service-versions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppRegApi - functional programming interface
 * @export
 */
export const AppRegApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppRegApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the application registration configuration of the given service
         * @summary Application registration Configuration
         * @param {string} id id of the service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationRegistrationConfiguration(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationRegistrationConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationRegistrationConfiguration(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppRegApi - factory interface
 * @export
 */
export const AppRegApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppRegApiFp(configuration)
    return {
        /**
         * Returns the application registration configuration of the given service
         * @summary Application registration Configuration
         * @param {string} id id of the service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationRegistrationConfiguration(id: string, options?: any): AxiosPromise<ApplicationRegistrationConfiguration> {
            return localVarFp.getApplicationRegistrationConfiguration(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getApplicationRegistrationConfiguration operation in AppRegApi.
 * @export
 * @interface AppRegApiGetApplicationRegistrationConfigurationRequest
 */
export interface AppRegApiGetApplicationRegistrationConfigurationRequest {
    /**
     * id of the service version
     * @type {string}
     * @memberof AppRegApiGetApplicationRegistrationConfiguration
     */
    readonly id: string
}

/**
 * AppRegApi - object-oriented interface
 * @export
 * @class AppRegApi
 * @extends {BaseAPI}
 */
export class AppRegApi extends BaseAPI {
    /**
     * Returns the application registration configuration of the given service
     * @summary Application registration Configuration
     * @param {AppRegApiGetApplicationRegistrationConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppRegApi
     */
    public getApplicationRegistrationConfiguration(requestParameters: AppRegApiGetApplicationRegistrationConfigurationRequest, options?: AxiosRequestConfig) {
        return AppRegApiFp(this.configuration).getApplicationRegistrationConfiguration(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows the developer to create an application
         * @summary Create Application
         * @param {CreateApplicationPayload} createApplicationPayload Create an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (createApplicationPayload: CreateApplicationPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createApplicationPayload' is not null or undefined
            assertParamExists('createApplication', 'createApplicationPayload', createApplicationPayload)
            const localVarPath = `/api/v2/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApplicationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to delete an application they own
         * @summary Delete Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplication', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to list applications
         * @summary Get many applications
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyApplications: async (page?: PageParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to get an application
         * @summary Get one Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getOneApplication', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to reset the client secret for an application they own
         * @summary refresh token
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshApplicationToken: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('refreshApplicationToken', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/refresh-token`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to update an application they own
         * @summary Update Application
         * @param {string} applicationId Id of the targeted application
         * @param {UpdateApplicationPayload} updateApplicationPayload Update an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication: async (applicationId: string, updateApplicationPayload: UpdateApplicationPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateApplication', 'applicationId', applicationId)
            // verify required parameter 'updateApplicationPayload' is not null or undefined
            assertParamExists('updateApplication', 'updateApplicationPayload', updateApplicationPayload)
            const localVarPath = `/api/v2/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateApplicationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows the developer to create an application
         * @summary Create Application
         * @param {CreateApplicationPayload} createApplicationPayload Create an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(createApplicationPayload: CreateApplicationPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCreationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(createApplicationPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to delete an application they own
         * @summary Delete Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to list applications
         * @summary Get many applications
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManyApplications(page?: PageParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetManyApplicationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManyApplications(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to get an application
         * @summary Get one Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOneApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOneApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to reset the client secret for an application they own
         * @summary refresh token
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshApplicationToken(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshApplicationToken(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to update an application they own
         * @summary Update Application
         * @param {string} applicationId Id of the targeted application
         * @param {UpdateApplicationPayload} updateApplicationPayload Update an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplication(applicationId: string, updateApplicationPayload: UpdateApplicationPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplication(applicationId, updateApplicationPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * This endpoint allows the developer to create an application
         * @summary Create Application
         * @param {CreateApplicationPayload} createApplicationPayload Create an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(createApplicationPayload: CreateApplicationPayload, options?: any): AxiosPromise<ApplicationCreationResponse> {
            return localVarFp.createApplication(createApplicationPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to delete an application they own
         * @summary Delete Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to list applications
         * @summary Get many applications
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyApplications(page?: PageParameters, options?: any): AxiosPromise<GetManyApplicationsResponse> {
            return localVarFp.getManyApplications(page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to get an application
         * @summary Get one Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneApplication(applicationId: string, options?: any): AxiosPromise<GetApplicationResponse> {
            return localVarFp.getOneApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to reset the client secret for an application they own
         * @summary refresh token
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshApplicationToken(applicationId: string, options?: any): AxiosPromise<RefreshTokenResponse> {
            return localVarFp.refreshApplicationToken(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to update an application they own
         * @summary Update Application
         * @param {string} applicationId Id of the targeted application
         * @param {UpdateApplicationPayload} updateApplicationPayload Update an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication(applicationId: string, updateApplicationPayload: UpdateApplicationPayload, options?: any): AxiosPromise<ApplicationUpdateResponse> {
            return localVarFp.updateApplication(applicationId, updateApplicationPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiCreateApplicationRequest
 */
export interface ApplicationsApiCreateApplicationRequest {
    /**
     * Create an application
     * @type {CreateApplicationPayload}
     * @memberof ApplicationsApiCreateApplication
     */
    readonly createApplicationPayload: CreateApplicationPayload
}

/**
 * Request parameters for deleteApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiDeleteApplicationRequest
 */
export interface ApplicationsApiDeleteApplicationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof ApplicationsApiDeleteApplication
     */
    readonly applicationId: string
}

/**
 * Request parameters for getManyApplications operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiGetManyApplicationsRequest
 */
export interface ApplicationsApiGetManyApplicationsRequest {
    /**
     * Determines which page of search results to retrieve.
     * @type {PageParameters}
     * @memberof ApplicationsApiGetManyApplications
     */
    readonly page?: PageParameters
}

/**
 * Request parameters for getOneApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiGetOneApplicationRequest
 */
export interface ApplicationsApiGetOneApplicationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof ApplicationsApiGetOneApplication
     */
    readonly applicationId: string
}

/**
 * Request parameters for refreshApplicationToken operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiRefreshApplicationTokenRequest
 */
export interface ApplicationsApiRefreshApplicationTokenRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof ApplicationsApiRefreshApplicationToken
     */
    readonly applicationId: string
}

/**
 * Request parameters for updateApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiUpdateApplicationRequest
 */
export interface ApplicationsApiUpdateApplicationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof ApplicationsApiUpdateApplication
     */
    readonly applicationId: string

    /**
     * Update an application
     * @type {UpdateApplicationPayload}
     * @memberof ApplicationsApiUpdateApplication
     */
    readonly updateApplicationPayload: UpdateApplicationPayload
}

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * This endpoint allows the developer to create an application
     * @summary Create Application
     * @param {ApplicationsApiCreateApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public createApplication(requestParameters: ApplicationsApiCreateApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).createApplication(requestParameters.createApplicationPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to delete an application they own
     * @summary Delete Application
     * @param {ApplicationsApiDeleteApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public deleteApplication(requestParameters: ApplicationsApiDeleteApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).deleteApplication(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to list applications
     * @summary Get many applications
     * @param {ApplicationsApiGetManyApplicationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getManyApplications(requestParameters: ApplicationsApiGetManyApplicationsRequest = {}, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getManyApplications(requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to get an application
     * @summary Get one Application
     * @param {ApplicationsApiGetOneApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getOneApplication(requestParameters: ApplicationsApiGetOneApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getOneApplication(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to reset the client secret for an application they own
     * @summary refresh token
     * @param {ApplicationsApiRefreshApplicationTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public refreshApplicationToken(requestParameters: ApplicationsApiRefreshApplicationTokenRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).refreshApplicationToken(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to update an application they own
     * @summary Update Application
     * @param {ApplicationsApiUpdateApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public updateApplication(requestParameters: ApplicationsApiUpdateApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).updateApplication(requestParameters.applicationId, requestParameters.updateApplicationPayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CredentialsApi - axios parameter creator
 * @export
 */
export const CredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows the developer to create a credential for an application they own
         * @summary Post Credential
         * @param {string} applicationId Id of the targeted application
         * @param {CreateCredentialPayload} [createCredentialPayload] Create a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredential: async (applicationId: string, createCredentialPayload?: CreateCredentialPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createCredential', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/credentials`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCredentialPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to delete a credential for an application they own
         * @summary Delete Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential: async (applicationId: string, credentialId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteCredential', 'applicationId', applicationId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('deleteCredential', 'credentialId', credentialId)
            const localVarPath = `/api/v2/applications/{applicationId}/credentials/{credentialId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to list the credentials for an application they own
         * @summary Get Many credentials
         * @param {string} applicationId Id of the targeted application
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyCredentials: async (applicationId: string, page?: PageParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getManyCredentials', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/credentials`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to reset the client secret for an application they own
         * @summary refresh token
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshApplicationToken: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('refreshApplicationToken', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/refresh-token`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to update a credential for an application they own
         * @summary Update Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {UpdateCredentialPayload} updateCredentialPayload Update a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential: async (applicationId: string, credentialId: string, updateCredentialPayload: UpdateCredentialPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateCredential', 'applicationId', applicationId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('updateCredential', 'credentialId', credentialId)
            // verify required parameter 'updateCredentialPayload' is not null or undefined
            assertParamExists('updateCredential', 'updateCredentialPayload', updateCredentialPayload)
            const localVarPath = `/api/v2/applications/{applicationId}/credentials/{credentialId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCredentialPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CredentialsApi - functional programming interface
 * @export
 */
export const CredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows the developer to create a credential for an application they own
         * @summary Post Credential
         * @param {string} applicationId Id of the targeted application
         * @param {CreateCredentialPayload} [createCredentialPayload] Create a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredential(applicationId: string, createCredentialPayload?: CreateCredentialPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialCreationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredential(applicationId, createCredentialPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to delete a credential for an application they own
         * @summary Delete Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCredential(applicationId: string, credentialId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCredential(applicationId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to list the credentials for an application they own
         * @summary Get Many credentials
         * @param {string} applicationId Id of the targeted application
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManyCredentials(applicationId: string, page?: PageParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCredentialsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManyCredentials(applicationId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to reset the client secret for an application they own
         * @summary refresh token
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshApplicationToken(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshApplicationToken(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to update a credential for an application they own
         * @summary Update Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {UpdateCredentialPayload} updateCredentialPayload Update a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCredential(applicationId: string, credentialId: string, updateCredentialPayload: UpdateCredentialPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCredential(applicationId, credentialId, updateCredentialPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CredentialsApi - factory interface
 * @export
 */
export const CredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CredentialsApiFp(configuration)
    return {
        /**
         * This endpoint allows the developer to create a credential for an application they own
         * @summary Post Credential
         * @param {string} applicationId Id of the targeted application
         * @param {CreateCredentialPayload} [createCredentialPayload] Create a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredential(applicationId: string, createCredentialPayload?: CreateCredentialPayload, options?: any): AxiosPromise<CredentialCreationResponse> {
            return localVarFp.createCredential(applicationId, createCredentialPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to delete a credential for an application they own
         * @summary Delete Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(applicationId: string, credentialId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCredential(applicationId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to list the credentials for an application they own
         * @summary Get Many credentials
         * @param {string} applicationId Id of the targeted application
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyCredentials(applicationId: string, page?: PageParameters, options?: any): AxiosPromise<GetCredentialsResponse> {
            return localVarFp.getManyCredentials(applicationId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to reset the client secret for an application they own
         * @summary refresh token
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshApplicationToken(applicationId: string, options?: any): AxiosPromise<RefreshTokenResponse> {
            return localVarFp.refreshApplicationToken(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to update a credential for an application they own
         * @summary Update Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {UpdateCredentialPayload} updateCredentialPayload Update a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(applicationId: string, credentialId: string, updateCredentialPayload: UpdateCredentialPayload, options?: any): AxiosPromise<void> {
            return localVarFp.updateCredential(applicationId, credentialId, updateCredentialPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCredential operation in CredentialsApi.
 * @export
 * @interface CredentialsApiCreateCredentialRequest
 */
export interface CredentialsApiCreateCredentialRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiCreateCredential
     */
    readonly applicationId: string

    /**
     * Create a credential
     * @type {CreateCredentialPayload}
     * @memberof CredentialsApiCreateCredential
     */
    readonly createCredentialPayload?: CreateCredentialPayload
}

/**
 * Request parameters for deleteCredential operation in CredentialsApi.
 * @export
 * @interface CredentialsApiDeleteCredentialRequest
 */
export interface CredentialsApiDeleteCredentialRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiDeleteCredential
     */
    readonly applicationId: string

    /**
     * Id of the targeted credential
     * @type {string}
     * @memberof CredentialsApiDeleteCredential
     */
    readonly credentialId: string
}

/**
 * Request parameters for getManyCredentials operation in CredentialsApi.
 * @export
 * @interface CredentialsApiGetManyCredentialsRequest
 */
export interface CredentialsApiGetManyCredentialsRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiGetManyCredentials
     */
    readonly applicationId: string

    /**
     * Determines which page of search results to retrieve.
     * @type {PageParameters}
     * @memberof CredentialsApiGetManyCredentials
     */
    readonly page?: PageParameters
}

/**
 * Request parameters for refreshApplicationToken operation in CredentialsApi.
 * @export
 * @interface CredentialsApiRefreshApplicationTokenRequest
 */
export interface CredentialsApiRefreshApplicationTokenRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiRefreshApplicationToken
     */
    readonly applicationId: string
}

/**
 * Request parameters for updateCredential operation in CredentialsApi.
 * @export
 * @interface CredentialsApiUpdateCredentialRequest
 */
export interface CredentialsApiUpdateCredentialRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiUpdateCredential
     */
    readonly applicationId: string

    /**
     * Id of the targeted credential
     * @type {string}
     * @memberof CredentialsApiUpdateCredential
     */
    readonly credentialId: string

    /**
     * Update a credential
     * @type {UpdateCredentialPayload}
     * @memberof CredentialsApiUpdateCredential
     */
    readonly updateCredentialPayload: UpdateCredentialPayload
}

/**
 * CredentialsApi - object-oriented interface
 * @export
 * @class CredentialsApi
 * @extends {BaseAPI}
 */
export class CredentialsApi extends BaseAPI {
    /**
     * This endpoint allows the developer to create a credential for an application they own
     * @summary Post Credential
     * @param {CredentialsApiCreateCredentialRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public createCredential(requestParameters: CredentialsApiCreateCredentialRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).createCredential(requestParameters.applicationId, requestParameters.createCredentialPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to delete a credential for an application they own
     * @summary Delete Credential
     * @param {CredentialsApiDeleteCredentialRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public deleteCredential(requestParameters: CredentialsApiDeleteCredentialRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).deleteCredential(requestParameters.applicationId, requestParameters.credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to list the credentials for an application they own
     * @summary Get Many credentials
     * @param {CredentialsApiGetManyCredentialsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public getManyCredentials(requestParameters: CredentialsApiGetManyCredentialsRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).getManyCredentials(requestParameters.applicationId, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to reset the client secret for an application they own
     * @summary refresh token
     * @param {CredentialsApiRefreshApplicationTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public refreshApplicationToken(requestParameters: CredentialsApiRefreshApplicationTokenRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).refreshApplicationToken(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to update a credential for an application they own
     * @summary Update Credential
     * @param {CredentialsApiUpdateCredentialRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public updateCredential(requestParameters: CredentialsApiUpdateCredentialRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).updateCredential(requestParameters.applicationId, requestParameters.credentialId, requestParameters.updateCredentialPayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeveloperApi - axios parameter creator
 * @export
 */
export const DeveloperApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Register to the developer portal
         * @summary Register
         * @param {RegisterPayload} [registerPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerPayload?: RegisterPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/developer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the password reset flow for the desired account. An email will be sent to the email address to initiate the password reset flow. 
         * @summary Password Reset
         * @param {ResetPasswordPayload} [resetPasswordPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetPasswordPayload?: ResetPasswordPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/developer/password-reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeveloperApi - functional programming interface
 * @export
 */
export const DeveloperApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeveloperApiAxiosParamCreator(configuration)
    return {
        /**
         * Register to the developer portal
         * @summary Register
         * @param {RegisterPayload} [registerPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerPayload?: RegisterPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Starts the password reset flow for the desired account. An email will be sent to the email address to initiate the password reset flow. 
         * @summary Password Reset
         * @param {ResetPasswordPayload} [resetPasswordPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetPasswordPayload?: ResetPasswordPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetPasswordPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeveloperApi - factory interface
 * @export
 */
export const DeveloperApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeveloperApiFp(configuration)
    return {
        /**
         * Register to the developer portal
         * @summary Register
         * @param {RegisterPayload} [registerPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerPayload?: RegisterPayload, options?: any): AxiosPromise<void> {
            return localVarFp.register(registerPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the password reset flow for the desired account. An email will be sent to the email address to initiate the password reset flow. 
         * @summary Password Reset
         * @param {ResetPasswordPayload} [resetPasswordPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(resetPasswordPayload?: ResetPasswordPayload, options?: any): AxiosPromise<void> {
            return localVarFp.resetPassword(resetPasswordPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for register operation in DeveloperApi.
 * @export
 * @interface DeveloperApiRegisterRequest
 */
export interface DeveloperApiRegisterRequest {
    /**
     * Developer registration
     * @type {RegisterPayload}
     * @memberof DeveloperApiRegister
     */
    readonly registerPayload?: RegisterPayload
}

/**
 * Request parameters for resetPassword operation in DeveloperApi.
 * @export
 * @interface DeveloperApiResetPasswordRequest
 */
export interface DeveloperApiResetPasswordRequest {
    /**
     * Developer registration
     * @type {ResetPasswordPayload}
     * @memberof DeveloperApiResetPassword
     */
    readonly resetPasswordPayload?: ResetPasswordPayload
}

/**
 * DeveloperApi - object-oriented interface
 * @export
 * @class DeveloperApi
 * @extends {BaseAPI}
 */
export class DeveloperApi extends BaseAPI {
    /**
     * Register to the developer portal
     * @summary Register
     * @param {DeveloperApiRegisterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperApi
     */
    public register(requestParameters: DeveloperApiRegisterRequest = {}, options?: AxiosRequestConfig) {
        return DeveloperApiFp(this.configuration).register(requestParameters.registerPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts the password reset flow for the desired account. An email will be sent to the email address to initiate the password reset flow. 
     * @summary Password Reset
     * @param {DeveloperApiResetPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperApi
     */
    public resetPassword(requestParameters: DeveloperApiResetPasswordRequest = {}, options?: AxiosRequestConfig) {
        return DeveloperApiFp(this.configuration).resetPassword(requestParameters.resetPasswordPayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PortalApi - axios parameter creator
 * @export
 */
export const PortalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * appearance of the portal
         * @summary portal appearance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalAppearance: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/portal/appearance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cover banner for the developer portal
         * @summary catalog cover
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalCatalogCover: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/portal/stylesheet/catalog-cover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * return the portal context
         * @summary get portal context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalContext: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/portal/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logo of the developer portal
         * @summary portal logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalLogo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/portal/stylesheet/logo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortalApi - functional programming interface
 * @export
 */
export const PortalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortalApiAxiosParamCreator(configuration)
    return {
        /**
         * appearance of the portal
         * @summary portal appearance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalAppearance(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortalAppearance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalAppearance(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cover banner for the developer portal
         * @summary catalog cover
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalCatalogCover(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalCatalogCover(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * return the portal context
         * @summary get portal context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalContext(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortalContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalContext(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Logo of the developer portal
         * @summary portal logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalLogo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalLogo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PortalApi - factory interface
 * @export
 */
export const PortalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortalApiFp(configuration)
    return {
        /**
         * appearance of the portal
         * @summary portal appearance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalAppearance(options?: any): AxiosPromise<PortalAppearance> {
            return localVarFp.getPortalAppearance(options).then((request) => request(axios, basePath));
        },
        /**
         * Cover banner for the developer portal
         * @summary catalog cover
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalCatalogCover(options?: any): AxiosPromise<File> {
            return localVarFp.getPortalCatalogCover(options).then((request) => request(axios, basePath));
        },
        /**
         * return the portal context
         * @summary get portal context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalContext(options?: any): AxiosPromise<PortalContext> {
            return localVarFp.getPortalContext(options).then((request) => request(axios, basePath));
        },
        /**
         * Logo of the developer portal
         * @summary portal logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalLogo(options?: any): AxiosPromise<File> {
            return localVarFp.getPortalLogo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortalApi - object-oriented interface
 * @export
 * @class PortalApi
 * @extends {BaseAPI}
 */
export class PortalApi extends BaseAPI {
    /**
     * appearance of the portal
     * @summary portal appearance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalApi
     */
    public getPortalAppearance(options?: AxiosRequestConfig) {
        return PortalApiFp(this.configuration).getPortalAppearance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cover banner for the developer portal
     * @summary catalog cover
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalApi
     */
    public getPortalCatalogCover(options?: AxiosRequestConfig) {
        return PortalApiFp(this.configuration).getPortalCatalogCover(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * return the portal context
     * @summary get portal context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalApi
     */
    public getPortalContext(options?: AxiosRequestConfig) {
        return PortalApiFp(this.configuration).getPortalContext(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logo of the developer portal
     * @summary portal logo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalApi
     */
    public getPortalLogo(options?: AxiosRequestConfig) {
        return PortalApiFp(this.configuration).getPortalLogo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns paginated search results from the specified entities with the given search parameters.
         * @summary Search Portal Entities
         * @param {SearchIndicesParameters} indices Determines which entity sets to search
         * @param {SearchParameters} [search] Determines how to filter search results
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPortalEntities: async (indices: SearchIndicesParameters, search?: SearchParameters, page?: PageParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indices' is not null or undefined
            assertParamExists('searchPortalEntities', 'indices', indices)
            const localVarPath = `/api/v2/search/{indices}`
                .replace(`{${"indices"}}`, encodeURIComponent(String(indices)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns paginated search results from the specified entities with the given search parameters.
         * @summary Search Portal Entities
         * @param {SearchIndicesParameters} indices Determines which entity sets to search
         * @param {SearchParameters} [search] Determines how to filter search results
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPortalEntities(indices: SearchIndicesParameters, search?: SearchParameters, page?: PageParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPortalEntities(indices, search, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Returns paginated search results from the specified entities with the given search parameters.
         * @summary Search Portal Entities
         * @param {SearchIndicesParameters} indices Determines which entity sets to search
         * @param {SearchParameters} [search] Determines how to filter search results
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPortalEntities(indices: SearchIndicesParameters, search?: SearchParameters, page?: PageParameters, options?: any): AxiosPromise<SearchResults> {
            return localVarFp.searchPortalEntities(indices, search, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for searchPortalEntities operation in SearchApi.
 * @export
 * @interface SearchApiSearchPortalEntitiesRequest
 */
export interface SearchApiSearchPortalEntitiesRequest {
    /**
     * Determines which entity sets to search
     * @type {SearchIndicesParameters}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly indices: SearchIndicesParameters

    /**
     * Determines how to filter search results
     * @type {SearchParameters}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly search?: SearchParameters

    /**
     * Determines which page of search results to retrieve.
     * @type {PageParameters}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly page?: PageParameters
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Returns paginated search results from the specified entities with the given search parameters.
     * @summary Search Portal Entities
     * @param {SearchApiSearchPortalEntitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchPortalEntities(requestParameters: SearchApiSearchPortalEntitiesRequest, options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchPortalEntities(requestParameters.indices, requestParameters.search, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }
}


