/* tslint:disable */
/* eslint-disable */
/**
 * Portal API
 * Portal API
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const AlignmentKind = {
    Left: 'left',
    Right: 'right',
    Center: 'center',
    None: 'none'
} as const;

export type AlignmentKind = typeof AlignmentKind[keyof typeof AlignmentKind];


/**
 * 
 * @export
 * @interface ApiProductVersionFilter
 */
export interface ApiProductVersionFilter {
    /**
     * The dimension to filter.
     * @type {string}
     * @memberof ApiProductVersionFilter
     */
    'dimension': ApiProductVersionFilterDimensionEnum;
    /**
     * 
     * @type {FilterType}
     * @memberof ApiProductVersionFilter
     */
    'type': FilterType;
    /**
     * The UUIDs of the API product versions to include in the results. 
     * @type {Array<string>}
     * @memberof ApiProductVersionFilter
     */
    'values': Array<string>;
}

export const ApiProductVersionFilterDimensionEnum = {
    ApiProductVersion: 'API_PRODUCT_VERSION'
} as const;

export type ApiProductVersionFilterDimensionEnum = typeof ApiProductVersionFilterDimensionEnum[keyof typeof ApiProductVersionFilterDimensionEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const ApiTypeEnum = {
    Openapi: 'openapi'
} as const;

export type ApiTypeEnum = typeof ApiTypeEnum[keyof typeof ApiTypeEnum];


/**
 * Application creation response payload
 * @export
 * @interface ApplicationCreationResponse
 */
export interface ApplicationCreationResponse {
    /**
     * Contains a unique identifier used by the API for this resource.
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'name': string;
    /**
     * An identifier to correlate the application with an external system. Cannot be set when using Dynamic Client Registration. 
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'reference_id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'redirect_uri'?: string | null;
    /**
     * 
     * @type {ApplicationCreationResponseCredentials}
     * @memberof ApplicationCreationResponse
     */
    'credentials'?: ApplicationCreationResponseCredentials;
    /**
     * ID of the auth strategy to use for the application. If null or not included, the default application auth strategy will be used.
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'auth_strategy_id': string | null;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'created_at': string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface ApplicationCreationResponseCredentials
 */
export interface ApplicationCreationResponseCredentials {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponseCredentials
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponseCredentials
     */
    'client_secret': string;
}
/**
 * 
 * @export
 * @interface ApplicationFilter
 */
export interface ApplicationFilter {
    /**
     * The dimension to filter. If no application filter is provided the API will implicitly filter on the applications owned by the developer making the query request.
     * @type {string}
     * @memberof ApplicationFilter
     */
    'dimension': ApplicationFilterDimensionEnum;
    /**
     * 
     * @type {FilterType}
     * @memberof ApplicationFilter
     */
    'type': FilterType;
    /**
     * The UUIDs of the dev portal applications to include in the results. 
     * @type {Array<string>}
     * @memberof ApplicationFilter
     */
    'values': Array<string>;
}

export const ApplicationFilterDimensionEnum = {
    Application: 'APPLICATION'
} as const;

export type ApplicationFilterDimensionEnum = typeof ApplicationFilterDimensionEnum[keyof typeof ApplicationFilterDimensionEnum];

/**
 * Application update response payload
 * @export
 * @interface ApplicationUpdateResponse
 */
export interface ApplicationUpdateResponse {
    /**
     * Contains a unique identifier used by the API for this resource.
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'name': string;
    /**
     * An identifier to correlate the application with an external system. Cannot be set when using Dynamic Client Registration. 
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'reference_id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'redirect_uri'?: string | null;
    /**
     * ID of the auth strategy to use for the application. If null or not included, the default application auth strategy will be used.
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'auth_strategy_id'?: string | null;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'created_at': string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'updated_at': string;
}
/**
 * The request schema for the authenticate endpoint.
 * @export
 * @interface AuthenticateRequest
 */
export interface AuthenticateRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthenticateRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticateRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface BadRequestError
 */
export interface BadRequestError {
    /**
     * 
     * @type {any}
     * @memberof BadRequestError
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof BadRequestError
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof BadRequestError
     */
    'type'?: any;
    /**
     * 
     * @type {any}
     * @memberof BadRequestError
     */
    'instance'?: any;
    /**
     * 
     * @type {any}
     * @memberof BadRequestError
     */
    'detail'?: any;
    /**
     * invalid parameters
     * @type {Set<InvalidParametersInner>}
     * @memberof BadRequestError
     */
    'invalid_parameters': Set<InvalidParametersInner>;
}
/**
 * standard error
 * @export
 * @interface BaseError
 */
export interface BaseError {
    /**
     * The HTTP status code of the error. Useful when passing the response body to child properties in a frontend UI. Must be returned as an integer. 
     * @type {number}
     * @memberof BaseError
     */
    'status': number;
    /**
     * A short, human-readable summary of the problem. It should not change between occurences of a problem, except for localization. Should be provided as \"Sentence case\" for direct use in the UI. 
     * @type {string}
     * @memberof BaseError
     */
    'title': string;
    /**
     * The error type.
     * @type {string}
     * @memberof BaseError
     */
    'type'?: string;
    /**
     * Used to return the correlation ID back to the user, in the format kong:trace:<correlation_id>. This helps us find the relevant logs when a customer reports an issue. 
     * @type {string}
     * @memberof BaseError
     */
    'instance': string;
    /**
     * A human readable explanation specific to this occurence of the problem. This field may contain request/entity data to help the user understand what went wrong. Enclose variable values in square brackets. Should be provided as \"Sentence case\" for direct use in the UI. 
     * @type {string}
     * @memberof BaseError
     */
    'detail': string;
}
/**
 * 
 * @export
 * @interface BlockQuoteBlock
 */
export interface BlockQuoteBlock {
    /**
     * 
     * @type {string}
     * @memberof BlockQuoteBlock
     */
    'type': BlockQuoteBlockTypeEnum;
    /**
     * List of children nodes of the current node
     * @type {Array<ChildNode>}
     * @memberof BlockQuoteBlock
     */
    'children'?: Array<ChildNode>;
}

export const BlockQuoteBlockTypeEnum = {
    Blockquote: 'blockquote'
} as const;

export type BlockQuoteBlockTypeEnum = typeof BlockQuoteBlockTypeEnum[keyof typeof BlockQuoteBlockTypeEnum];

/**
 * 
 * @export
 * @interface BreakBlock
 */
export interface BreakBlock {
    /**
     * 
     * @type {string}
     * @memberof BreakBlock
     */
    'type': BreakBlockTypeEnum;
    /**
     * List of children nodes of the current node
     * @type {Array<ChildNode>}
     * @memberof BreakBlock
     */
    'children'?: Array<ChildNode>;
}

export const BreakBlockTypeEnum = {
    Break: 'break'
} as const;

export type BreakBlockTypeEnum = typeof BreakBlockTypeEnum[keyof typeof BreakBlockTypeEnum];

/**
 * @type ChildNode
 * @export
 */
export type ChildNode = BlockQuoteBlock | BreakBlock | Code | CodeBlock | Emphasis | HeadingBlock | Image | Link | ListBlock | ListItemBlock | ParagraphBlock | StrikeThrough | TableBlock | TableCellBlock | TableHeaderBlock | TableRowBlock | TaskCheckbox | Text | TextBlock;

/**
 * 
 * @export
 * @interface Code
 */
export interface Code {
    /**
     * 
     * @type {string}
     * @memberof Code
     */
    'type': CodeTypeEnum;
    /**
     * List of children nodes of the current node
     * @type {Array<ChildNode>}
     * @memberof Code
     */
    'children'?: Array<ChildNode>;
}

export const CodeTypeEnum = {
    Code: 'code'
} as const;

export type CodeTypeEnum = typeof CodeTypeEnum[keyof typeof CodeTypeEnum];

/**
 * 
 * @export
 * @interface CodeBlock
 */
export interface CodeBlock {
    /**
     * 
     * @type {string}
     * @memberof CodeBlock
     */
    'type': CodeBlockTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CodeBlock
     */
    'lang'?: string;
    /**
     * List of children nodes of the current node
     * @type {Array<ChildNode>}
     * @memberof CodeBlock
     */
    'children'?: Array<ChildNode>;
}

export const CodeBlockTypeEnum = {
    CodeBlock: 'code_block'
} as const;

export type CodeBlockTypeEnum = typeof CodeBlockTypeEnum[keyof typeof CodeBlockTypeEnum];

/**
 * 
 * @export
 * @interface ConflictError
 */
export interface ConflictError {
    /**
     * 
     * @type {any}
     * @memberof ConflictError
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof ConflictError
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof ConflictError
     */
    'type'?: any;
    /**
     * 
     * @type {any}
     * @memberof ConflictError
     */
    'instance'?: any;
    /**
     * 
     * @type {any}
     * @memberof ConflictError
     */
    'detail'?: any;
}
/**
 * Application creation payload
 * @export
 * @interface CreateApplicationPayload
 */
export interface CreateApplicationPayload {
    /**
     * The name of the application
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'name': string;
    /**
     * An identifier to correlate the application with an external system. Cannot be set when using Dynamic Client Registration. 
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'reference_id'?: string;
    /**
     * URL to redirect to after completing an OIDC auth flow
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'redirect_uri'?: string;
    /**
     * A brief description of the application
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'description'?: string;
    /**
     * ID of the auth strategy to use for the application. If null or not included, the default application auth strategy will be used.
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'auth_strategy_id'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateCredentialPayload
 */
export interface CreateCredentialPayload {
    /**
     * 
     * @type {string}
     * @memberof CreateCredentialPayload
     */
    'display_name'?: string;
}
/**
 * The payload to create a registration.
 * @export
 * @interface CreateRegistrationPayload
 */
export interface CreateRegistrationPayload {
    /**
     * The product version id required for registration.
     * @type {string}
     * @memberof CreateRegistrationPayload
     */
    'product_version_id': string;
    /**
     * The requested scopes for the registration, requires developer_managed_scopes to be enabled.
     * @type {Array<string>}
     * @memberof CreateRegistrationPayload
     */
    'scopes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CredentialCreationResponse
 */
export interface CredentialCreationResponse {
    /**
     * 
     * @type {string}
     * @memberof CredentialCreationResponse
     */
    'credential': string;
    /**
     * Contains a unique identifier used by the API for this resource.
     * @type {string}
     * @memberof CredentialCreationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CredentialCreationResponse
     */
    'display_name': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CredentialType = {
    ClientCredentials: 'client_credentials',
    SelfManagedClientCredentials: 'self_managed_client_credentials',
    KeyAuth: 'key_auth'
} as const;

export type CredentialType = typeof CredentialType[keyof typeof CredentialType];


/**
 * A user who can use a developer portal
 * @export
 * @interface Developer
 */
export interface Developer {
    /**
     * Contains a unique identifier used by the API for this resource.
     * @type {string}
     * @memberof Developer
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Developer
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Developer
     */
    'full_name': string;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof Developer
     */
    'created_at'?: string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof Developer
     */
    'updated_at'?: string;
}
/**
 * content of the document
 * @export
 * @interface DocumentBlock
 */
export interface DocumentBlock {
    /**
     * 
     * @type {string}
     * @memberof DocumentBlock
     */
    'type': DocumentBlockTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DocumentBlock
     */
    'version'?: string;
    /**
     * List of children nodes of the current node
     * @type {Array<ChildNode>}
     * @memberof DocumentBlock
     */
    'children'?: Array<ChildNode>;
}

export const DocumentBlockTypeEnum = {
    Document: 'document'
} as const;

export type DocumentBlockTypeEnum = typeof DocumentBlockTypeEnum[keyof typeof DocumentBlockTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const DocumentContentTypeEnum = {
    Json: 'application/json',
    VndKonnectDocumentTreejson: 'application/vnd.konnect.document-tree+json'
} as const;

export type DocumentContentTypeEnum = typeof DocumentContentTypeEnum[keyof typeof DocumentContentTypeEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const DocumentFormatContentTypeEnum = {
    Json: 'application/json',
    VndKonnectDocumentNodesjson: 'application/vnd.konnect.document-nodes+json'
} as const;

export type DocumentFormatContentTypeEnum = typeof DocumentFormatContentTypeEnum[keyof typeof DocumentFormatContentTypeEnum];


/**
 * 
 * @export
 * @interface DocumentItem
 */
export interface DocumentItem {
    /**
     * the id of the document
     * @type {string}
     * @memberof DocumentItem
     */
    'id': string;
    /**
     * the id of the parent document
     * @type {string}
     * @memberof DocumentItem
     */
    'parent_document_id': string | null;
    /**
     * the slug of the document
     * @type {string}
     * @memberof DocumentItem
     */
    'slug': string;
    /**
     * the title of the document
     * @type {string}
     * @memberof DocumentItem
     */
    'title': string;
}
/**
 * a document tree
 * @export
 * @interface DocumentTree
 */
export interface DocumentTree {
    /**
     * 
     * @type {string}
     * @memberof DocumentTree
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentTree
     */
    'parent_document_id'?: string | null;
    /**
     * the title of the document
     * @type {string}
     * @memberof DocumentTree
     */
    'title': string;
    /**
     * the slug of the document
     * @type {string}
     * @memberof DocumentTree
     */
    'slug': string;
    /**
     * the metadata of the document
     * @type {object}
     * @memberof DocumentTree
     */
    'metadata': object;
    /**
     * 
     * @type {Array<DocumentTree>}
     * @memberof DocumentTree
     */
    'children': Array<DocumentTree>;
}
/**
 * 
 * @export
 * @interface Emphasis
 */
export interface Emphasis {
    /**
     * 
     * @type {string}
     * @memberof Emphasis
     */
    'type': EmphasisTypeEnum;
    /**
     * Level of emphasis 1 - italic 2 - bold 
     * @type {number}
     * @memberof Emphasis
     */
    'level'?: number;
    /**
     * List of children nodes of the current node
     * @type {Array<ChildNode>}
     * @memberof Emphasis
     */
    'children'?: Array<ChildNode>;
}

export const EmphasisTypeEnum = {
    Emphasis: 'emphasis'
} as const;

export type EmphasisTypeEnum = typeof EmphasisTypeEnum[keyof typeof EmphasisTypeEnum];

/**
 * The type of filter to apply.  `IN` filters will limit results to only the specified values, while `NOT_IN` filters will exclude the specified values.
 * @export
 * @enum {string}
 */

export const FilterType = {
    In: 'IN',
    NotIn: 'NOT_IN'
} as const;

export type FilterType = typeof FilterType[keyof typeof FilterType];


/**
 * 
 * @export
 * @interface ForbiddenError
 */
export interface ForbiddenError {
    /**
     * 
     * @type {any}
     * @memberof ForbiddenError
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof ForbiddenError
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof ForbiddenError
     */
    'type'?: any;
    /**
     * 
     * @type {any}
     * @memberof ForbiddenError
     */
    'instance'?: any;
    /**
     * 
     * @type {any}
     * @memberof ForbiddenError
     */
    'detail'?: any;
}
/**
 * 
 * @export
 * @interface GetApplicationResponse
 */
export interface GetApplicationResponse {
    /**
     * Contains a unique identifier used by the API for this resource.
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'name': string;
    /**
     * An identifier to correlate the application with an external system. Cannot be set when using Dynamic Client Registration. 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'reference_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'redirect_uri'?: string | null;
    /**
     * ID of the auth strategy to use for the application. If null or not included, the default application auth strategy will be used.
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'auth_strategy_id'?: string | null;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'created_at': string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface GetGrantedScopesProductVersionResponse
 */
export interface GetGrantedScopesProductVersionResponse {
    /**
     * List of granted scopes, directly updated from the IDP
     * @type {Array<string>}
     * @memberof GetGrantedScopesProductVersionResponse
     */
    'scopes': Array<string>;
}
/**
 * 
 * @export
 * @interface GetGrantedScopesResponse
 */
export interface GetGrantedScopesResponse {
    /**
     * List of granted scopes, directly updated from the IDP
     * @type {Array<string>}
     * @memberof GetGrantedScopesResponse
     */
    'scopes': Array<string>;
}
/**
 * 
 * @export
 * @interface GetRegistrationResponse
 */
export interface GetRegistrationResponse {
    /**
     * Contains a unique identifier used by the API for this resource.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'id': string;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'created_at': string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'updated_at': string;
    /**
     * The approval status of the registration.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'status': GetRegistrationResponseStatusEnum;
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'product_id': string;
    /**
     * The name of the product. This is the name that is displayed in the developer portal.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'product_name': string;
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'product_version_id': string;
    /**
     * The name of the product version. This is the version label that is displayed in the developer portal.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'product_version_name': string;
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'application_id': string;
    /**
     * Cached list of scopes granted for the given application registration. Use `/api/v2/applications/{applicationId}/registrations/{registrationId}/granted-scopes` to get up to date granted scopes from the IDP. This property will be omitted if not supported by the application. 
     * @type {Array<string>}
     * @memberof GetRegistrationResponse
     */
    'granted_scopes'?: Array<string>;
}

export const GetRegistrationResponseStatusEnum = {
    Approved: 'approved',
    Pending: 'pending',
    Rejected: 'rejected',
    Revoked: 'revoked'
} as const;

export type GetRegistrationResponseStatusEnum = typeof GetRegistrationResponseStatusEnum[keyof typeof GetRegistrationResponseStatusEnum];

/**
 * 
 * @export
 * @interface GoneError
 */
export interface GoneError {
    /**
     * 
     * @type {any}
     * @memberof GoneError
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof GoneError
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof GoneError
     */
    'type'?: any;
    /**
     * 
     * @type {any}
     * @memberof GoneError
     */
    'instance'?: any;
    /**
     * 
     * @type {any}
     * @memberof GoneError
     */
    'detail'?: any;
}
/**
 * 
 * @export
 * @interface HeadingBlock
 */
export interface HeadingBlock {
    /**
     * 
     * @type {string}
     * @memberof HeadingBlock
     */
    'type': HeadingBlockTypeEnum;
    /**
     * Level of the heading which maps to HTML <h> tag
     * @type {number}
     * @memberof HeadingBlock
     */
    'level'?: number;
    /**
     * List of children nodes of the current node
     * @type {Array<ChildNode>}
     * @memberof HeadingBlock
     */
    'children'?: Array<ChildNode>;
}

export const HeadingBlockTypeEnum = {
    Heading: 'heading'
} as const;

export type HeadingBlockTypeEnum = typeof HeadingBlockTypeEnum[keyof typeof HeadingBlockTypeEnum];

/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'type': ImageTypeEnum;
    /**
     * Url of the image
     * @type {string}
     * @memberof Image
     */
    'url'?: string;
    /**
     * Alternate tag of the image
     * @type {string}
     * @memberof Image
     */
    'alt'?: string;
    /**
     * Title of the image
     * @type {string}
     * @memberof Image
     */
    'title'?: string;
}

export const ImageTypeEnum = {
    Image: 'image'
} as const;

export type ImageTypeEnum = typeof ImageTypeEnum[keyof typeof ImageTypeEnum];

/**
 * 
 * @export
 * @interface InvalidParameterChoiceItem
 */
export interface InvalidParameterChoiceItem {
    /**
     * 
     * @type {string}
     * @memberof InvalidParameterChoiceItem
     */
    'field': string;
    /**
     * 
     * @type {InvalidRules}
     * @memberof InvalidParameterChoiceItem
     */
    'rule'?: InvalidRules | null;
    /**
     * 
     * @type {string}
     * @memberof InvalidParameterChoiceItem
     */
    'reason': string;
    /**
     * 
     * @type {Set<any>}
     * @memberof InvalidParameterChoiceItem
     */
    'choices'?: Set<any> | null;
}
/**
 * 
 * @export
 * @interface InvalidParameterDependentItem
 */
export interface InvalidParameterDependentItem {
    /**
     * 
     * @type {string}
     * @memberof InvalidParameterDependentItem
     */
    'field': string;
    /**
     * invalid parameters rules
     * @type {string}
     * @memberof InvalidParameterDependentItem
     */
    'rule': InvalidParameterDependentItemRuleEnum;
    /**
     * 
     * @type {string}
     * @memberof InvalidParameterDependentItem
     */
    'reason': string;
    /**
     * 
     * @type {Set<any>}
     * @memberof InvalidParameterDependentItem
     */
    'dependents': Set<any> | null;
}

export const InvalidParameterDependentItemRuleEnum = {
    DependentFields: 'dependent_fields'
} as const;

export type InvalidParameterDependentItemRuleEnum = typeof InvalidParameterDependentItemRuleEnum[keyof typeof InvalidParameterDependentItemRuleEnum];

/**
 * @type InvalidParametersInner
 * @export
 */
export type InvalidParametersInner = InvalidParameterChoiceItem | InvalidParameterDependentItem;

/**
 * invalid parameters rules
 * @export
 * @enum {string}
 */

export const InvalidRules = {
    Required: 'required',
    Enum: 'enum',
    MinLength: 'min_length',
    MaxLength: 'max_length',
    MinDigits: 'min_digits',
    MinLowercase: 'min_lowercase',
    MinUppercase: 'min_uppercase',
    MinSymbols: 'min_symbols',
    IsArray: 'is_array',
    IsBase64: 'is_base64',
    IsBoolean: 'is_boolean',
    IsDateTime: 'is_date_time',
    IsInteger: 'is_integer',
    IsNull: 'is_null',
    IsNumber: 'is_number',
    IsObject: 'is_object',
    IsString: 'is_string',
    IsUuid: 'is_uuid',
    UnknownProperty: 'unknown_property',
    IsLabel: 'is_label',
    MatchesRegex: 'matches_regex'
} as const;

export type InvalidRules = typeof InvalidRules[keyof typeof InvalidRules];


/**
 * 
 * @export
 * @interface LatestVersion
 */
export interface LatestVersion {
    /**
     * 
     * @type {string}
     * @memberof LatestVersion
     */
    'name'?: string;
    /**
     * Contains a unique identifier used by the API for this resource.
     * @type {string}
     * @memberof LatestVersion
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'type': LinkTypeEnum;
    /**
     * Target url of the link
     * @type {string}
     * @memberof Link
     */
    'href'?: string;
    /**
     * Title of the link
     * @type {string}
     * @memberof Link
     */
    'title'?: string;
}

export const LinkTypeEnum = {
    Link: 'link'
} as const;

export type LinkTypeEnum = typeof LinkTypeEnum[keyof typeof LinkTypeEnum];

/**
 * 
 * @export
 * @interface ListApplicationsResponse
 */
export interface ListApplicationsResponse {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ListApplicationsResponse
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<GetApplicationResponse>}
     * @memberof ListApplicationsResponse
     */
    'data': Array<GetApplicationResponse>;
}
/**
 * 
 * @export
 * @interface ListAuthStrategiesItem
 */
export interface ListAuthStrategiesItem {
    /**
     * ID of the auth strategy to use for the application. If null or not included, the default application auth strategy will be used.
     * @type {string}
     * @memberof ListAuthStrategiesItem
     */
    'id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ListAuthStrategiesItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListAuthStrategiesItem
     */
    'credential_type': ListAuthStrategiesItemCredentialTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListAuthStrategiesItem
     */
    'auth_methods'?: Array<string>;
}

export const ListAuthStrategiesItemCredentialTypeEnum = {
    ClientCredentials: 'client_credentials',
    SelfManagedClientCredentials: 'self_managed_client_credentials',
    KeyAuth: 'key_auth'
} as const;

export type ListAuthStrategiesItemCredentialTypeEnum = typeof ListAuthStrategiesItemCredentialTypeEnum[keyof typeof ListAuthStrategiesItemCredentialTypeEnum];

/**
 * 
 * @export
 * @interface ListAuthStrategiesResponse
 */
export interface ListAuthStrategiesResponse {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ListAuthStrategiesResponse
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<ListAuthStrategiesItem>}
     * @memberof ListAuthStrategiesResponse
     */
    'data': Array<ListAuthStrategiesItem>;
}
/**
 * 
 * @export
 * @interface ListBlock
 */
export interface ListBlock {
    /**
     * 
     * @type {string}
     * @memberof ListBlock
     */
    'type': ListBlockTypeEnum;
    /**
     * Defines if the list is ordered or not
     * @type {boolean}
     * @memberof ListBlock
     */
    'isOrdered'?: boolean;
    /**
     * List of children nodes of the current node
     * @type {Array<ChildNode>}
     * @memberof ListBlock
     */
    'children'?: Array<ChildNode>;
}

export const ListBlockTypeEnum = {
    List: 'list'
} as const;

export type ListBlockTypeEnum = typeof ListBlockTypeEnum[keyof typeof ListBlockTypeEnum];

/**
 * 
 * @export
 * @interface ListCredentialsResponse
 */
export interface ListCredentialsResponse {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ListCredentialsResponse
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<ListCredentialsResponseDataInner>}
     * @memberof ListCredentialsResponse
     */
    'data': Array<ListCredentialsResponseDataInner>;
}
/**
 * 
 * @export
 * @interface ListCredentialsResponseDataInner
 */
export interface ListCredentialsResponseDataInner {
    /**
     * Contains a unique identifier used by the API for this resource.
     * @type {string}
     * @memberof ListCredentialsResponseDataInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListCredentialsResponseDataInner
     */
    'display_name': string;
}
/**
 * 
 * @export
 * @interface ListDocuments
 */
export interface ListDocuments {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ListDocuments
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<DocumentItem>}
     * @memberof ListDocuments
     */
    'data': Array<DocumentItem>;
}
/**
 * 
 * @export
 * @interface ListDocumentsTree
 */
export interface ListDocumentsTree {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ListDocumentsTree
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<DocumentTree>}
     * @memberof ListDocumentsTree
     */
    'data': Array<DocumentTree>;
}
/**
 * 
 * @export
 * @interface ListItemBlock
 */
export interface ListItemBlock {
    /**
     * 
     * @type {string}
     * @memberof ListItemBlock
     */
    'type': ListItemBlockTypeEnum;
    /**
     * List of children nodes of the current node
     * @type {Array<ChildNode>}
     * @memberof ListItemBlock
     */
    'children'?: Array<ChildNode>;
}

export const ListItemBlockTypeEnum = {
    ListItem: 'list_item'
} as const;

export type ListItemBlockTypeEnum = typeof ListItemBlockTypeEnum[keyof typeof ListItemBlockTypeEnum];

/**
 * 
 * @export
 * @interface ListRegistrationsResponse
 */
export interface ListRegistrationsResponse {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ListRegistrationsResponse
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<GetRegistrationResponse>}
     * @memberof ListRegistrationsResponse
     */
    'data': Array<GetRegistrationResponse>;
}
/**
 * 
 * @export
 * @interface NotAvailableError
 */
export interface NotAvailableError {
    /**
     * The HTTP status code of the error. Useful when passing the response body to child properties in a frontend UI. Must be returned as an integer. 
     * @type {number}
     * @memberof NotAvailableError
     */
    'status': number;
    /**
     * A short, human-readable summary of the problem. It should not change between occurences of a problem, except for localization. Should be provided as \"Sentence case\" for direct use in the UI. 
     * @type {string}
     * @memberof NotAvailableError
     */
    'title': string;
    /**
     * The error type.
     * @type {string}
     * @memberof NotAvailableError
     */
    'type'?: string;
    /**
     * Used to return the correlation ID back to the user, in the format kong:trace:<correlation_id>. This helps us find the relevant logs when a customer reports an issue. 
     * @type {string}
     * @memberof NotAvailableError
     */
    'instance': string;
    /**
     * A human readable explanation specific to this occurence of the problem. This field may contain request/entity data to help the user understand what went wrong. Enclose variable values in square brackets. Should be provided as \"Sentence case\" for direct use in the UI. 
     * @type {string}
     * @memberof NotAvailableError
     */
    'detail': string;
}
/**
 * 
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
    /**
     * 
     * @type {any}
     * @memberof NotFoundError
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotFoundError
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotFoundError
     */
    'type'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotFoundError
     */
    'instance'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotFoundError
     */
    'detail'?: any;
}
/**
 * Contains pagination query parameters and the total number of objects returned.
 * @export
 * @interface PageMeta
 */
export interface PageMeta {
    /**
     * 
     * @type {number}
     * @memberof PageMeta
     */
    'number': number;
    /**
     * 
     * @type {number}
     * @memberof PageMeta
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof PageMeta
     */
    'total': number;
}
/**
 * returns the pagination information
 * @export
 * @interface PaginatedMeta
 */
export interface PaginatedMeta {
    /**
     * 
     * @type {PageMeta}
     * @memberof PaginatedMeta
     */
    'page': PageMeta;
}
/**
 * 
 * @export
 * @interface ParagraphBlock
 */
export interface ParagraphBlock {
    /**
     * 
     * @type {string}
     * @memberof ParagraphBlock
     */
    'type': ParagraphBlockTypeEnum;
    /**
     * List of children nodes of the current node
     * @type {Array<ChildNode>}
     * @memberof ParagraphBlock
     */
    'children'?: Array<ChildNode>;
}

export const ParagraphBlockTypeEnum = {
    Paragraph: 'paragraph'
} as const;

export type ParagraphBlockTypeEnum = typeof ParagraphBlockTypeEnum[keyof typeof ParagraphBlockTypeEnum];

/**
 * the portal appearance
 * @export
 * @interface PortalAppearance
 */
export interface PortalAppearance {
    /**
     * 
     * @type {PortalAppearanceVariables}
     * @memberof PortalAppearance
     */
    'variables'?: PortalAppearanceVariables;
    /**
     * 
     * @type {PortalAppearanceStylesheets}
     * @memberof PortalAppearance
     */
    'stylesheets'?: PortalAppearanceStylesheets;
}
/**
 * 
 * @export
 * @interface PortalAppearanceStylesheets
 */
export interface PortalAppearanceStylesheets {
    /**
     * 
     * @type {PortalAppearanceStylesheetsGlobal}
     * @memberof PortalAppearanceStylesheets
     */
    'global'?: PortalAppearanceStylesheetsGlobal;
}
/**
 * 
 * @export
 * @interface PortalAppearanceStylesheetsGlobal
 */
export interface PortalAppearanceStylesheetsGlobal {
    /**
     * 
     * @type {PortalAppearanceStylesheetsGlobalMain}
     * @memberof PortalAppearanceStylesheetsGlobal
     */
    'main'?: PortalAppearanceStylesheetsGlobalMain;
}
/**
 * 
 * @export
 * @interface PortalAppearanceStylesheetsGlobalMain
 */
export interface PortalAppearanceStylesheetsGlobalMain {
    /**
     * 
     * @type {object}
     * @memberof PortalAppearanceStylesheetsGlobalMain
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface PortalAppearanceVariables
 */
export interface PortalAppearanceVariables {
    /**
     * 
     * @type {PortalAppearanceVariablesCatalog}
     * @memberof PortalAppearanceVariables
     */
    'catalog'?: PortalAppearanceVariablesCatalog;
}
/**
 * 
 * @export
 * @interface PortalAppearanceVariablesCatalog
 */
export interface PortalAppearanceVariablesCatalog {
    /**
     * 
     * @type {PortalAppearanceVariablesCatalogLogo}
     * @memberof PortalAppearanceVariablesCatalog
     */
    'logo'?: PortalAppearanceVariablesCatalogLogo;
    /**
     * 
     * @type {PortalAppearanceVariablesCatalogLogo}
     * @memberof PortalAppearanceVariablesCatalog
     */
    'cover'?: PortalAppearanceVariablesCatalogLogo;
    /**
     * 
     * @type {PortalAppearanceVariablesCatalogPrimaryHeader}
     * @memberof PortalAppearanceVariablesCatalog
     */
    'primary_header'?: PortalAppearanceVariablesCatalogPrimaryHeader;
    /**
     * 
     * @type {PortalAppearanceVariablesCatalogPrimaryHeader}
     * @memberof PortalAppearanceVariablesCatalog
     */
    'welcome_message'?: PortalAppearanceVariablesCatalogPrimaryHeader;
}
/**
 * 
 * @export
 * @interface PortalAppearanceVariablesCatalogLogo
 */
export interface PortalAppearanceVariablesCatalogLogo {
    /**
     * 
     * @type {string}
     * @memberof PortalAppearanceVariablesCatalogLogo
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface PortalAppearanceVariablesCatalogPrimaryHeader
 */
export interface PortalAppearanceVariablesCatalogPrimaryHeader {
    /**
     * 
     * @type {string}
     * @memberof PortalAppearanceVariablesCatalogPrimaryHeader
     */
    'text'?: string;
}
/**
 * describe the portal execution context
 * @export
 * @interface PortalContext
 */
export interface PortalContext {
    /**
     * 
     * @type {string}
     * @memberof PortalContext
     */
    'portal_id': string;
    /**
     * 
     * @type {string}
     * @memberof PortalContext
     */
    'org_id': string;
    /**
     * 
     * @type {string}
     * @memberof PortalContext
     */
    'featureset_id': string;
    /**
     * String that determines feature set group developer belongs to when logged in
     * @type {string}
     * @memberof PortalContext
     */
    'feature_set'?: string;
    /**
     * Whether the portal can be accessed via email and password
     * @type {boolean}
     * @memberof PortalContext
     */
    'basic_auth_enabled': boolean;
    /**
     * Whether the portal can be accessed via authentication with Single Sign On (SSO) through OpenID Connect (OIDC) from a third-party Identity Provider
     * @type {boolean}
     * @memberof PortalContext
     */
    'oidc_auth_enabled': boolean;
    /**
     * Whether the portal catalog can be accessed by non-authenticated users
     * @type {boolean}
     * @memberof PortalContext
     */
    'is_public': boolean;
    /**
     * Whether the portal is protected with Role-Based Access Control
     * @type {boolean}
     * @memberof PortalContext
     */
    'rbac_enabled': boolean;
    /**
     * The unique identifiers of each available client provider when using Dynamic Client Registration
     * @type {Array<string>}
     * @memberof PortalContext
     */
    'dcr_provider_ids': Array<string>;
    /**
     * Allowed time period for Analytics queries
     * @type {string}
     * @memberof PortalContext
     */
    'allowed_time_period': string;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * Contains a unique identifier used by the API for this resource.
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof Product
     */
    'created_at': string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof Product
     */
    'updated_at': string;
    /**
     * Name of product.
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'description'?: string | null;
    /**
     * Number of linked documents in documentation.
     * @type {number}
     * @memberof Product
     */
    'document_count'?: number;
    /**
     * Number of published versions.
     * @type {number}
     * @memberof Product
     */
    'version_count'?: number;
    /**
     * 
     * @type {LatestVersion}
     * @memberof Product
     */
    'latest_version'?: LatestVersion | null;
}
/**
 * 
 * @export
 * @interface ProductActionsResponse
 */
export interface ProductActionsResponse {
    /**
     * 
     * @type {ProductActionsResponseActions}
     * @memberof ProductActionsResponse
     */
    'actions': ProductActionsResponseActions;
}
/**
 * List of actions that can be performed on the API Product
 * @export
 * @interface ProductActionsResponseActions
 */
export interface ProductActionsResponseActions {
    /**
     * 
     * @type {boolean}
     * @memberof ProductActionsResponseActions
     */
    'view': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductActionsResponseActions
     */
    'register': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductActionsResponseActions
     */
    'view_documentation': boolean;
}
/**
 * 
 * @export
 * @interface ProductCatalogIndexSource
 */
export interface ProductCatalogIndexSource {
    /**
     * Contains a unique identifier used by the API for this resource.
     * @type {string}
     * @memberof ProductCatalogIndexSource
     */
    'id': string;
    /**
     * the name of the product
     * @type {string}
     * @memberof ProductCatalogIndexSource
     */
    'name': string | null;
    /**
     * a description of the product
     * @type {string}
     * @memberof ProductCatalogIndexSource
     */
    'description'?: string | null;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof ProductCatalogIndexSource
     */
    'created_at': string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof ProductCatalogIndexSource
     */
    'updated_at': string;
    /**
     * Number of product documents available.
     * @type {number}
     * @memberof ProductCatalogIndexSource
     */
    'document_count': number;
    /**
     * Number of product versions.
     * @type {number}
     * @memberof ProductCatalogIndexSource
     */
    'version_count': number;
    /**
     * 
     * @type {ProductCatalogIndexSourceLatestVersion}
     * @memberof ProductCatalogIndexSource
     */
    'latest_version': ProductCatalogIndexSourceLatestVersion | null;
}
/**
 * Last created version.
 * @export
 * @interface ProductCatalogIndexSourceLatestVersion
 */
export interface ProductCatalogIndexSourceLatestVersion {
    /**
     * Name of product version.
     * @type {string}
     * @memberof ProductCatalogIndexSourceLatestVersion
     */
    'name': string;
    /**
     * Contains a unique identifier used by the API for this resource.
     * @type {string}
     * @memberof ProductCatalogIndexSourceLatestVersion
     */
    'id': string;
}
/**
 * A document for a product. This is a document that is not a part of the API specification.
 * @export
 * @interface ProductDocument
 */
export interface ProductDocument {
    /**
     * 
     * @type {string}
     * @memberof ProductDocument
     */
    'id': string;
    /**
     * Contains a unique identifier used by the DocumentHub service for this resource.
     * @type {string}
     * @memberof ProductDocument
     */
    'parent_document_id'?: string | null;
    /**
     * Slug of the document. This is used in the URL to identify the document.
     * @type {string}
     * @memberof ProductDocument
     */
    'slug': string;
    /**
     * 
     * @type {DocumentBlock}
     * @memberof ProductDocument
     */
    'content': DocumentBlock;
    /**
     * Title of the document. This is used in the Portal UI to identify the document.
     * @type {string}
     * @memberof ProductDocument
     */
    'title': string;
}
/**
 * A document for a product. This is a document that is not a part of the API specification.
 * @export
 * @interface ProductDocumentRaw
 */
export interface ProductDocumentRaw {
    /**
     * 
     * @type {string}
     * @memberof ProductDocumentRaw
     */
    'id': string;
    /**
     * Contains a unique identifier used by the DocumentHub service for this resource.
     * @type {string}
     * @memberof ProductDocumentRaw
     */
    'parent_document_id'?: string | null;
    /**
     * Slug of the document. This is used in the URL to identify the document.
     * @type {string}
     * @memberof ProductDocumentRaw
     */
    'slug': string;
    /**
     * Markdown document
     * @type {string}
     * @memberof ProductDocumentRaw
     */
    'content': string;
    /**
     * Title of the document. This is used in the Portal UI to identify the document.
     * @type {string}
     * @memberof ProductDocumentRaw
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ProductListPage
 */
export interface ProductListPage {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ProductListPage
     */
    'meta'?: PaginatedMeta;
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductListPage
     */
    'data'?: Array<Product>;
}
/**
 * 
 * @export
 * @interface ProductVersion
 */
export interface ProductVersion {
    /**
     * Contains a unique identifier used by the API for this resource.
     * @type {string}
     * @memberof ProductVersion
     */
    'id': string;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof ProductVersion
     */
    'created_at': string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof ProductVersion
     */
    'updated_at': string;
    /**
     * Name of product version.
     * @type {string}
     * @memberof ProductVersion
     */
    'name': string;
    /**
     * If true, product version is deprecated.
     * @type {boolean}
     * @memberof ProductVersion
     */
    'deprecated': boolean;
    /**
     * Configurations for how the product version is able to be registered for by applications.
     * @type {Array<RegistrationConfiguration>}
     * @memberof ProductVersion
     */
    'registration_configs': Array<RegistrationConfiguration>;
}
/**
 * 
 * @export
 * @interface ProductVersionApplication
 */
export interface ProductVersionApplication {
    /**
     * Contains a unique identifier used by the API for this resource.
     * @type {string}
     * @memberof ProductVersionApplication
     */
    'id': string;
    /**
     * The name of the application
     * @type {string}
     * @memberof ProductVersionApplication
     */
    'name': string;
    /**
     * Contains a unique identifier for a resource.
     * @type {string}
     * @memberof ProductVersionApplication
     */
    'registration_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductVersionApplication
     */
    'registration_status': ProductVersionApplicationRegistrationStatusEnum;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof ProductVersionApplication
     */
    'created_at': string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof ProductVersionApplication
     */
    'updated_at': string;
}

export const ProductVersionApplicationRegistrationStatusEnum = {
    Approved: 'approved',
    Pending: 'pending',
    Rejected: 'rejected',
    Revoked: 'revoked'
} as const;

export type ProductVersionApplicationRegistrationStatusEnum = typeof ProductVersionApplicationRegistrationStatusEnum[keyof typeof ProductVersionApplicationRegistrationStatusEnum];

/**
 * 
 * @export
 * @interface ProductVersionListApplicationsPage
 */
export interface ProductVersionListApplicationsPage {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ProductVersionListApplicationsPage
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<ProductVersionApplication>}
     * @memberof ProductVersionListApplicationsPage
     */
    'data': Array<ProductVersionApplication>;
}
/**
 * 
 * @export
 * @interface ProductVersionListPage
 */
export interface ProductVersionListPage {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ProductVersionListPage
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<ProductVersion>}
     * @memberof ProductVersionListPage
     */
    'data': Array<ProductVersion>;
}
/**
 * API specification document for a product version.
 * @export
 * @interface ProductVersionSpecDocument
 */
export interface ProductVersionSpecDocument {
    /**
     * 
     * @type {ApiTypeEnum}
     * @memberof ProductVersionSpecDocument
     */
    'api_type': ApiTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductVersionSpecDocument
     */
    'content': string;
}
/**
 * List of every operation detailed in a product version spec document.
 * @export
 * @interface ProductVersionSpecOperations
 */
export interface ProductVersionSpecOperations {
    /**
     * 
     * @type {ApiTypeEnum}
     * @memberof ProductVersionSpecOperations
     */
    'api_type': ApiTypeEnum;
    /**
     * 
     * @type {Array<ProductVersionSpecOperationsOperationsInner>}
     * @memberof ProductVersionSpecOperations
     */
    'operations': Array<ProductVersionSpecOperationsOperationsInner>;
}
/**
 * 
 * @export
 * @interface ProductVersionSpecOperationsOperationsInner
 */
export interface ProductVersionSpecOperationsOperationsInner {
    /**
     * 
     * @type {string}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'method': string;
    /**
     * 
     * @type {string}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'operation_id': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'summary': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'deprecated': boolean;
}
/**
 * 
 * @export
 * @interface QueryApplicationAnalytics
 */
export interface QueryApplicationAnalytics {
    /**
     * Unix timestamp in milliseconds specifying the lower bound to return data for the query, inclusive.
     * @type {number}
     * @memberof QueryApplicationAnalytics
     */
    'start_ms': number;
    /**
     * Unix timestamp in milliseconds specifying upper bound to return data for the query, inclusive.
     * @type {number}
     * @memberof QueryApplicationAnalytics
     */
    'end_ms': number;
    /**
     * A property of your API (such as request count or latency) that you wish to query on. Your chosen metric is aggregated within the specified dimensions, meaning that if you query \'request count by application\', you\'ll receive the total number of requests each application received within the given time frame.  Some metrics, such as latency and response size, have more complicated aggregations: selecting P99 will result in the 99th percentile of the chosen metric. 
     * @type {Array<string>}
     * @memberof QueryApplicationAnalytics
     */
    'metrics': Array<QueryApplicationAnalyticsMetricsEnum>;
    /**
     * The dimensions for the query.  A query may have up to 2 dimensions, including time. If no dimensions are provided, the report will simply return the provided metric aggregated across all available data. 
     * @type {Array<string>}
     * @memberof QueryApplicationAnalytics
     */
    'dimensions'?: Array<QueryApplicationAnalyticsDimensionsEnum>;
    /**
     * `granularity_ms` is only valid for queries that include a time dimension, and it specifies the time buckets in for the returned data. 
     * @type {number}
     * @memberof QueryApplicationAnalytics
     */
    'granularity_ms'?: number;
    /**
     * 
     * @type {Array<QueryApplicationAnalyticsFilterInner>}
     * @memberof QueryApplicationAnalytics
     */
    'filter'?: Array<QueryApplicationAnalyticsFilterInner>;
}

export const QueryApplicationAnalyticsMetricsEnum = {
    RequestCount: 'REQUEST_COUNT',
    RequestPerMinute: 'REQUEST_PER_MINUTE',
    ResponseLatencyP99: 'RESPONSE_LATENCY_P99',
    ResponseLatencyP95: 'RESPONSE_LATENCY_P95',
    ResponseLatencyP50: 'RESPONSE_LATENCY_P50',
    ResponseSizeP99: 'RESPONSE_SIZE_P99',
    ResponseSizeP95: 'RESPONSE_SIZE_P95',
    ResponseSizeP50: 'RESPONSE_SIZE_P50',
    RequestSizeP99: 'REQUEST_SIZE_P99',
    RequestSizeP95: 'REQUEST_SIZE_P95',
    RequestSizeP50: 'REQUEST_SIZE_P50'
} as const;

export type QueryApplicationAnalyticsMetricsEnum = typeof QueryApplicationAnalyticsMetricsEnum[keyof typeof QueryApplicationAnalyticsMetricsEnum];
export const QueryApplicationAnalyticsDimensionsEnum = {
    ApiProductVersion: 'API_PRODUCT_VERSION',
    Application: 'APPLICATION',
    StatusCode: 'STATUS_CODE',
    StatusCodeGrouped: 'STATUS_CODE_GROUPED',
    Time: 'TIME'
} as const;

export type QueryApplicationAnalyticsDimensionsEnum = typeof QueryApplicationAnalyticsDimensionsEnum[keyof typeof QueryApplicationAnalyticsDimensionsEnum];

/**
 * 
 * @export
 * @interface QueryApplicationAnalytics200Response
 */
export interface QueryApplicationAnalytics200Response {
    /**
     * 
     * @type {QueryResponseMeta}
     * @memberof QueryApplicationAnalytics200Response
     */
    'meta'?: QueryResponseMeta;
    /**
     * Query response data.
     * @type {Array<QueryResponseRecord>}
     * @memberof QueryApplicationAnalytics200Response
     */
    'records'?: Array<QueryResponseRecord>;
}
/**
 * @type QueryApplicationAnalyticsFilterInner
 * @export
 */
export type QueryApplicationAnalyticsFilterInner = { dimension: 'API_PRODUCT_VERSION' } & ApiProductVersionFilter | { dimension: 'APPLICATION' } & ApplicationFilter | { dimension: 'STATUS_CODE' } & StatusCodeFilter | { dimension: 'STATUS_CODE_GROUPED' } & StatusCodeGroupedFilter;

/**
 * Query response metadata.
 * @export
 * @interface QueryResponseMeta
 */
export interface QueryResponseMeta {
    /**
     * 
     * @type {QueryResponseMetaDimensions}
     * @memberof QueryResponseMeta
     */
    'dimensions'?: QueryResponseMetaDimensions;
    /**
     * The metric requested in query.
     * @type {Array<string>}
     * @memberof QueryResponseMeta
     */
    'metric_names'?: Array<QueryResponseMetaMetricNamesEnum>;
    /**
     * 
     * @type {QueryResponseMetaMetricUnits}
     * @memberof QueryResponseMeta
     */
    'metric_units'?: QueryResponseMetaMetricUnits;
    /**
     * Unix timestamp in milliseconds specifying the lower bound to return data for the query. Provided from the query parameters.
     * @type {number}
     * @memberof QueryResponseMeta
     */
    'start_ms'?: number;
    /**
     * Unix timestamp in milliseconds specifying the upper bound to return data for the query. Provided from the query parameters.
     * @type {number}
     * @memberof QueryResponseMeta
     */
    'end_ms'?: number;
    /**
     * True if the limit of dimension values was reached and results were truncated. Limit value is 50.
     * @type {boolean}
     * @memberof QueryResponseMeta
     */
    'truncated'?: boolean;
    /**
     * The resulting time bucket for the returned data. If `TIME` was not specified as a dimension, granularity is the duration of the query.
     * @type {number}
     * @memberof QueryResponseMeta
     */
    'granularity'?: number;
    /**
     * Optional ID used to look up the query.
     * @type {string}
     * @memberof QueryResponseMeta
     */
    'query_id'?: string;
}

export const QueryResponseMetaMetricNamesEnum = {
    RequestCount: 'REQUEST_COUNT',
    RequestPerMinute: 'REQUEST_PER_MINUTE',
    ResponseLatencyP99: 'RESPONSE_LATENCY_P99',
    ResponseLatencyP95: 'RESPONSE_LATENCY_P95',
    ResponseLatencyP50: 'RESPONSE_LATENCY_P50',
    ResponseSizeP99: 'RESPONSE_SIZE_P99',
    ResponseSizeP95: 'RESPONSE_SIZE_P95',
    ResponseSizeP50: 'RESPONSE_SIZE_P50',
    RequestSizeP99: 'REQUEST_SIZE_P99',
    RequestSizeP95: 'REQUEST_SIZE_P95',
    RequestSizeP50: 'REQUEST_SIZE_P50'
} as const;

export type QueryResponseMetaMetricNamesEnum = typeof QueryResponseMetaMetricNamesEnum[keyof typeof QueryResponseMetaMetricNamesEnum];

/**
 * The dimension name and values returned in the response.
 * @export
 * @interface QueryResponseMetaDimensions
 */
export interface QueryResponseMetaDimensions {
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryResponseMetaDimensions
     */
    'API_PRODUCT_VERSION'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryResponseMetaDimensions
     */
    'APPLICATION'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryResponseMetaDimensions
     */
    'STATUS_CODE'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryResponseMetaDimensions
     */
    'STATUS_CODE_GROUPED'?: Array<string>;
}
/**
 * The unit of metric.
 * @export
 * @interface QueryResponseMetaMetricUnits
 */
export interface QueryResponseMetaMetricUnits {
    /**
     * 
     * @type {string}
     * @memberof QueryResponseMetaMetricUnits
     */
    'REQUEST_COUNT'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResponseMetaMetricUnits
     */
    'REQUEST_PER_MINUTE'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResponseMetaMetricUnits
     */
    'RESPONSE_LATENCY_P99'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResponseMetaMetricUnits
     */
    'RESPONSE_LATENCY_P95'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResponseMetaMetricUnits
     */
    'RESPONSE_LATENCY_P50'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResponseMetaMetricUnits
     */
    'RESPONSE_SIZE_P99'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResponseMetaMetricUnits
     */
    'RESPONSE_SIZE_P95'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResponseMetaMetricUnits
     */
    'RESPONSE_SIZE_P50'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResponseMetaMetricUnits
     */
    'REQUEST_SIZE_P99'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResponseMetaMetricUnits
     */
    'REQUEST_SIZE_P95'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResponseMetaMetricUnits
     */
    'REQUEST_SIZE_P50'?: string;
}
/**
 * A response record.
 * @export
 * @interface QueryResponseRecord
 */
export interface QueryResponseRecord {
    /**
     * 
     * @type {QueryResponseRecordEvent}
     * @memberof QueryResponseRecord
     */
    'event'?: QueryResponseRecordEvent;
    /**
     * An ISO-8601 timestamp. If `TIME` was requested as a dimension this will be the start of the time bucket. If not specified this is the start time of the query.
     * @type {string}
     * @memberof QueryResponseRecord
     */
    'timestamp'?: string;
}
/**
 * Event within the response. Mapping from the requested metrics and dimensions to the values.
 * @export
 * @interface QueryResponseRecordEvent
 */
export interface QueryResponseRecordEvent {
    /**
     * The number or requests metric.
     * @type {number}
     * @memberof QueryResponseRecordEvent
     */
    'REQUEST_COUNT'?: number;
    /**
     * The number of requests per minute metric.
     * @type {number}
     * @memberof QueryResponseRecordEvent
     */
    'REQUEST_PER_MINUTE'?: number;
    /**
     * 99th percentile response latency metric in milliseconds.
     * @type {number}
     * @memberof QueryResponseRecordEvent
     */
    'RESPONSE_LATENCY_P99'?: number;
    /**
     * 95th percentile response latency metric in milliseconds.
     * @type {number}
     * @memberof QueryResponseRecordEvent
     */
    'RESPONSE_LATENCY_P95'?: number;
    /**
     * 50th percentile response latency metric in milliseconds.
     * @type {number}
     * @memberof QueryResponseRecordEvent
     */
    'RESPONSE_LATENCY_P50'?: number;
    /**
     * 99th percentile response size metric in bytes.
     * @type {number}
     * @memberof QueryResponseRecordEvent
     */
    'RESPONSE_SIZE_P99'?: number;
    /**
     * 95th percentile response size metric in bytes.
     * @type {number}
     * @memberof QueryResponseRecordEvent
     */
    'RESPONSE_SIZE_P95'?: number;
    /**
     * 50th percentile response size metric in bytes.
     * @type {number}
     * @memberof QueryResponseRecordEvent
     */
    'RESPONSE_SIZE_P50'?: number;
    /**
     * 99th percentile request size metric in bytes.
     * @type {number}
     * @memberof QueryResponseRecordEvent
     */
    'REQUEST_SIZE_P99'?: number;
    /**
     * 95th percentile request size metric in bytes.
     * @type {number}
     * @memberof QueryResponseRecordEvent
     */
    'REQUEST_SIZE_P95'?: number;
    /**
     * 50th percentile request size metric in bytes.
     * @type {number}
     * @memberof QueryResponseRecordEvent
     */
    'REQUEST_SIZE_P50'?: number;
    /**
     * Dimension value for `API_PRODUCT_VERSION` name.
     * @type {string}
     * @memberof QueryResponseRecordEvent
     */
    'API_PRODUCT_VERSION'?: string;
    /**
     * Dimension value for `APPLICATION` name.
     * @type {string}
     * @memberof QueryResponseRecordEvent
     */
    'APPLICATION'?: string;
    /**
     * Dimension value for `STATUS_CODE`.
     * @type {string}
     * @memberof QueryResponseRecordEvent
     */
    'STATUS_CODE'?: string;
    /**
     * Dimension value for `STATUS_CODE_GROUPED`.
     * @type {string}
     * @memberof QueryResponseRecordEvent
     */
    'STATUS_CODE_GROUPED'?: string;
}
/**
 * Refresh token response
 * @export
 * @interface RefreshTokenResponse
 */
export interface RefreshTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    'client_secret': string;
}
/**
 * Payload required to be sent to register a developer to the portal. 
 * @export
 * @interface RegisterPayload
 */
export interface RegisterPayload {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof RegisterPayload
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterPayload
     */
    'full_name': string;
}
/**
 * 
 * @export
 * @interface RegistrationConfiguration
 */
export interface RegistrationConfiguration {
    /**
     * Contains a unique identifier used by the API for this resource.
     * @type {string}
     * @memberof RegistrationConfiguration
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegistrationConfiguration
     */
    'auth_methods'?: Array<string>;
    /**
     * 
     * @type {CredentialType}
     * @memberof RegistrationConfiguration
     */
    'credential_type'?: CredentialType;
    /**
     * 
     * @type {string}
     * @memberof RegistrationConfiguration
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegistrationConfiguration
     */
    'available_scopes'?: Array<string>;
}
/**
 * Payload required to start the reset password flow 
 * @export
 * @interface ResetPasswordPayload
 */
export interface ResetPasswordPayload {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordPayload
     */
    'email': string;
}
/**
 * The request schema for the reset password endpoint.
 * @export
 * @interface ResetPasswordRequest
 */
export interface ResetPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SearchIndicesParameters = {
    ProductCatalog: 'product-catalog'
} as const;

export type SearchIndicesParameters = typeof SearchIndicesParameters[keyof typeof SearchIndicesParameters];


/**
 * 
 * @export
 * @interface SearchResults
 */
export interface SearchResults {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof SearchResults
     */
    'meta': PaginatedMeta;
    /**
     * The paginated results that matched the search query
     * @type {Array<SearchResultsDataInner>}
     * @memberof SearchResults
     */
    'data': Array<SearchResultsDataInner>;
}
/**
 * 
 * @export
 * @interface SearchResultsDataInner
 */
export interface SearchResultsDataInner {
    /**
     * 
     * @type {SearchIndicesParameters}
     * @memberof SearchResultsDataInner
     */
    'index': SearchIndicesParameters;
    /**
     * 
     * @type {ProductCatalogIndexSource}
     * @memberof SearchResultsDataInner
     */
    'source': ProductCatalogIndexSource;
}
/**
 * 
 * @export
 * @interface StatusCodeFilter
 */
export interface StatusCodeFilter {
    /**
     * The dimension to filter.
     * @type {string}
     * @memberof StatusCodeFilter
     */
    'dimension': StatusCodeFilterDimensionEnum;
    /**
     * 
     * @type {FilterType}
     * @memberof StatusCodeFilter
     */
    'type': FilterType;
    /**
     * Only include requests with specific status codes in the results. 
     * @type {Array<number>}
     * @memberof StatusCodeFilter
     */
    'values': Array<number>;
}

export const StatusCodeFilterDimensionEnum = {
    StatusCode: 'STATUS_CODE'
} as const;

export type StatusCodeFilterDimensionEnum = typeof StatusCodeFilterDimensionEnum[keyof typeof StatusCodeFilterDimensionEnum];

/**
 * 
 * @export
 * @interface StatusCodeGroupedFilter
 */
export interface StatusCodeGroupedFilter {
    /**
     * The dimension to filter.
     * @type {string}
     * @memberof StatusCodeGroupedFilter
     */
    'dimension': StatusCodeGroupedFilterDimensionEnum;
    /**
     * 
     * @type {FilterType}
     * @memberof StatusCodeGroupedFilter
     */
    'type': FilterType;
    /**
     * Only include the given groups of status codes in the results. 
     * @type {Array<string>}
     * @memberof StatusCodeGroupedFilter
     */
    'values': Array<string>;
}

export const StatusCodeGroupedFilterDimensionEnum = {
    StatusCodeGrouped: 'STATUS_CODE_GROUPED'
} as const;

export type StatusCodeGroupedFilterDimensionEnum = typeof StatusCodeGroupedFilterDimensionEnum[keyof typeof StatusCodeGroupedFilterDimensionEnum];

/**
 * 
 * @export
 * @interface StrikeThrough
 */
export interface StrikeThrough {
    /**
     * 
     * @type {string}
     * @memberof StrikeThrough
     */
    'type': StrikeThroughTypeEnum;
}

export const StrikeThroughTypeEnum = {
    Strikethrough: 'strikethrough'
} as const;

export type StrikeThroughTypeEnum = typeof StrikeThroughTypeEnum[keyof typeof StrikeThroughTypeEnum];

/**
 * 
 * @export
 * @interface TableBlock
 */
export interface TableBlock {
    /**
     * 
     * @type {string}
     * @memberof TableBlock
     */
    'type': TableBlockTypeEnum;
    /**
     * 
     * @type {Array<AlignmentKind>}
     * @memberof TableBlock
     */
    'alignments': Array<AlignmentKind> | null;
    /**
     * List of children nodes of the current node
     * @type {Array<ChildNode>}
     * @memberof TableBlock
     */
    'children'?: Array<ChildNode>;
}

export const TableBlockTypeEnum = {
    Table: 'table'
} as const;

export type TableBlockTypeEnum = typeof TableBlockTypeEnum[keyof typeof TableBlockTypeEnum];

/**
 * 
 * @export
 * @interface TableCellBlock
 */
export interface TableCellBlock {
    /**
     * 
     * @type {string}
     * @memberof TableCellBlock
     */
    'type': TableCellBlockTypeEnum;
    /**
     * 
     * @type {AlignmentKind}
     * @memberof TableCellBlock
     */
    'alignment'?: AlignmentKind;
    /**
     * List of children nodes of the current node
     * @type {Array<ChildNode>}
     * @memberof TableCellBlock
     */
    'children'?: Array<ChildNode>;
}

export const TableCellBlockTypeEnum = {
    TableCell: 'table_cell'
} as const;

export type TableCellBlockTypeEnum = typeof TableCellBlockTypeEnum[keyof typeof TableCellBlockTypeEnum];

/**
 * 
 * @export
 * @interface TableHeaderBlock
 */
export interface TableHeaderBlock {
    /**
     * 
     * @type {string}
     * @memberof TableHeaderBlock
     */
    'type': TableHeaderBlockTypeEnum;
    /**
     * 
     * @type {Array<AlignmentKind>}
     * @memberof TableHeaderBlock
     */
    'alignments': Array<AlignmentKind> | null;
    /**
     * List of children nodes of the current node
     * @type {Array<ChildNode>}
     * @memberof TableHeaderBlock
     */
    'children'?: Array<ChildNode>;
}

export const TableHeaderBlockTypeEnum = {
    TableHeader: 'table_header'
} as const;

export type TableHeaderBlockTypeEnum = typeof TableHeaderBlockTypeEnum[keyof typeof TableHeaderBlockTypeEnum];

/**
 * 
 * @export
 * @interface TableRowBlock
 */
export interface TableRowBlock {
    /**
     * 
     * @type {string}
     * @memberof TableRowBlock
     */
    'type': TableRowBlockTypeEnum;
    /**
     * 
     * @type {Array<AlignmentKind>}
     * @memberof TableRowBlock
     */
    'alignments': Array<AlignmentKind> | null;
    /**
     * List of children nodes of the current node
     * @type {Array<ChildNode>}
     * @memberof TableRowBlock
     */
    'children'?: Array<ChildNode>;
}

export const TableRowBlockTypeEnum = {
    TableRow: 'table_row'
} as const;

export type TableRowBlockTypeEnum = typeof TableRowBlockTypeEnum[keyof typeof TableRowBlockTypeEnum];

/**
 * 
 * @export
 * @interface TaskCheckbox
 */
export interface TaskCheckbox {
    /**
     * 
     * @type {string}
     * @memberof TaskCheckbox
     */
    'type': TaskCheckboxTypeEnum;
    /**
     * State of the checkbox
     * @type {boolean}
     * @memberof TaskCheckbox
     */
    'checked': boolean;
}

export const TaskCheckboxTypeEnum = {
    TaskCheckbox: 'task_checkbox'
} as const;

export type TaskCheckboxTypeEnum = typeof TaskCheckboxTypeEnum[keyof typeof TaskCheckboxTypeEnum];

/**
 * 
 * @export
 * @interface Text
 */
export interface Text {
    /**
     * 
     * @type {string}
     * @memberof Text
     */
    'type': TextTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Text
     */
    'text'?: string;
    /**
     * If this property is true the end of this block should be a carriage return and not concatenated to the next Text block. 
     * @type {boolean}
     * @memberof Text
     */
    'hardBreak'?: boolean;
    /**
     * If this property is true the end of this block should should be concatenated with a space caracter before the next block. This is the flag showing that the parsed markdown block was at the end of the line. 
     * @type {boolean}
     * @memberof Text
     */
    'softBreak'?: boolean;
    /**
     * List of children nodes of the current node
     * @type {Array<ChildNode>}
     * @memberof Text
     */
    'children'?: Array<ChildNode>;
}

export const TextTypeEnum = {
    Text: 'text'
} as const;

export type TextTypeEnum = typeof TextTypeEnum[keyof typeof TextTypeEnum];

/**
 * 
 * @export
 * @interface TextBlock
 */
export interface TextBlock {
    /**
     * 
     * @type {string}
     * @memberof TextBlock
     */
    'type': TextBlockTypeEnum;
    /**
     * List of children nodes of the current node
     * @type {Array<ChildNode>}
     * @memberof TextBlock
     */
    'children'?: Array<ChildNode>;
}

export const TextBlockTypeEnum = {
    TextBlock: 'text_block'
} as const;

export type TextBlockTypeEnum = typeof TextBlockTypeEnum[keyof typeof TextBlockTypeEnum];

/**
 * 
 * @export
 * @interface TooManyRequestsError
 */
export interface TooManyRequestsError {
    /**
     * 
     * @type {any}
     * @memberof TooManyRequestsError
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof TooManyRequestsError
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof TooManyRequestsError
     */
    'type'?: any;
    /**
     * 
     * @type {any}
     * @memberof TooManyRequestsError
     */
    'instance'?: any;
    /**
     * 
     * @type {any}
     * @memberof TooManyRequestsError
     */
    'detail'?: any;
}
/**
 * 
 * @export
 * @interface UnauthorizedError
 */
export interface UnauthorizedError {
    /**
     * 
     * @type {any}
     * @memberof UnauthorizedError
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof UnauthorizedError
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof UnauthorizedError
     */
    'type'?: any;
    /**
     * 
     * @type {any}
     * @memberof UnauthorizedError
     */
    'instance'?: any;
    /**
     * 
     * @type {any}
     * @memberof UnauthorizedError
     */
    'detail'?: any;
}
/**
 * 
 * @export
 * @interface UnprocessableContentError
 */
export interface UnprocessableContentError {
    /**
     * 
     * @type {any}
     * @memberof UnprocessableContentError
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof UnprocessableContentError
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof UnprocessableContentError
     */
    'type'?: any;
    /**
     * 
     * @type {any}
     * @memberof UnprocessableContentError
     */
    'instance'?: any;
    /**
     * 
     * @type {any}
     * @memberof UnprocessableContentError
     */
    'detail'?: any;
}
/**
 * Payload required to update an application
 * @export
 * @interface UpdateApplicationPayload
 */
export interface UpdateApplicationPayload {
    /**
     * The name of the application
     * @type {string}
     * @memberof UpdateApplicationPayload
     */
    'name': string;
    /**
     * An identifier to correlate the application with an external system. Cannot be set when using Dynamic Client Registration. 
     * @type {string}
     * @memberof UpdateApplicationPayload
     */
    'reference_id'?: string;
    /**
     * URL to redirect to after completing an OIDC auth flow
     * @type {string}
     * @memberof UpdateApplicationPayload
     */
    'redirect_uri'?: string;
    /**
     * A brief description of the application
     * @type {string}
     * @memberof UpdateApplicationPayload
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCredentialPayload
 */
export interface UpdateCredentialPayload {
    /**
     * 
     * @type {string}
     * @memberof UpdateCredentialPayload
     */
    'display_name': string;
}
/**
 * The request schema for the verify email endpoint.
 * @export
 * @interface VerifyEmailRequest
 */
export interface VerifyEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailRequest
     */
    'token': string;
}
/**
 * The response schema for the verify email endpoint.
 * @export
 * @interface VerifyEmailResponse
 */
export interface VerifyEmailResponse {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailResponse
     */
    'token'?: string;
}

/**
 * ApplicationAnalyticsApi - axios parameter creator
 * @export
 */
export const ApplicationAnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Query
         * @summary Query Application Analytics
         * @param {QueryApplicationAnalytics} [queryApplicationAnalytics] Object describing the query sent to analytics API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryApplicationAnalytics: async (queryApplicationAnalytics?: QueryApplicationAnalytics, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryApplicationAnalytics, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationAnalyticsApi - functional programming interface
 * @export
 */
export const ApplicationAnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationAnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Query
         * @summary Query Application Analytics
         * @param {QueryApplicationAnalytics} [queryApplicationAnalytics] Object describing the query sent to analytics API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryApplicationAnalytics(queryApplicationAnalytics?: QueryApplicationAnalytics, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryApplicationAnalytics200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryApplicationAnalytics(queryApplicationAnalytics, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationAnalyticsApi - factory interface
 * @export
 */
export const ApplicationAnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationAnalyticsApiFp(configuration)
    return {
        /**
         * Query
         * @summary Query Application Analytics
         * @param {QueryApplicationAnalytics} [queryApplicationAnalytics] Object describing the query sent to analytics API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryApplicationAnalytics(queryApplicationAnalytics?: QueryApplicationAnalytics, options?: any): AxiosPromise<QueryApplicationAnalytics200Response> {
            return localVarFp.queryApplicationAnalytics(queryApplicationAnalytics, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for queryApplicationAnalytics operation in ApplicationAnalyticsApi.
 * @export
 * @interface ApplicationAnalyticsApiQueryApplicationAnalyticsRequest
 */
export interface ApplicationAnalyticsApiQueryApplicationAnalyticsRequest {
    /**
     * Object describing the query sent to analytics API.
     * @type {QueryApplicationAnalytics}
     * @memberof ApplicationAnalyticsApiQueryApplicationAnalytics
     */
    readonly queryApplicationAnalytics?: QueryApplicationAnalytics
}

/**
 * ApplicationAnalyticsApi - object-oriented interface
 * @export
 * @class ApplicationAnalyticsApi
 * @extends {BaseAPI}
 */
export class ApplicationAnalyticsApi extends BaseAPI {
    /**
     * Query
     * @summary Query Application Analytics
     * @param {ApplicationAnalyticsApiQueryApplicationAnalyticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApi
     */
    public queryApplicationAnalytics(requestParameters: ApplicationAnalyticsApiQueryApplicationAnalyticsRequest = {}, options?: AxiosRequestConfig) {
        return ApplicationAnalyticsApiFp(this.configuration).queryApplicationAnalytics(requestParameters.queryApplicationAnalytics, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Application.
         * @summary Create an Application
         * @param {CreateApplicationPayload} createApplicationPayload Create an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (createApplicationPayload: CreateApplicationPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createApplicationPayload' is not null or undefined
            assertParamExists('createApplication', 'createApplicationPayload', createApplicationPayload)
            const localVarPath = `/api/v2/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApplicationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an application and all of its associated entities (registrations).
         * @summary Delete Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplication', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the details for an existing application. You need only supply the unique application identifier that was returned upon application creation or by the list-applications endpoint.
         * @summary Get an Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplication', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the granted scopes of a specified application and product version directly from the IDP. Scopes shared between product versions will be returned, even if not currently registered for given product version. Will return 409 if this feature is not supported by the application. 
         * @summary Get the granted scopes
         * @param {string} applicationId Id of the targeted application
         * @param {string} productVersionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationProductVersionGrantedScopes: async (applicationId: string, productVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationProductVersionGrantedScopes', 'applicationId', applicationId)
            // verify required parameter 'productVersionId' is not null or undefined
            assertParamExists('getApplicationProductVersionGrantedScopes', 'productVersionId', productVersionId)
            const localVarPath = `/api/v2/applications/{applicationId}/product-versions/{productVersionId}/granted-scopes`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"productVersionId"}}`, encodeURIComponent(String(productVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the available Auth Strategies on this portal. An Auth Strategy is a set of plugin configurations that represent how the gateway will perform authentication and authorization for a Product Version. It may reference to Key-Auth or an OIDC configuration (with or without DCR). 
         * @summary List the available auth strategies
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {'client_credentials' | 'self_managed_client_credentials' | 'key_auth'} [filterCredentialTypeEq] Filter by direct equality comparison of the credential_type with a supplied value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationAuthStrategies: async (pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, filterCredentialTypeEq?: 'client_credentials' | 'self_managed_client_credentials' | 'key_auth', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/applications/auth-strategies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (filterNameEq !== undefined) {
                localVarQueryParameter['filter[name][eq]'] = filterNameEq;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterNameContains !== undefined) {
                localVarQueryParameter['filter[name][contains]'] = filterNameContains;
            }

            if (filterCredentialTypeEq !== undefined) {
                localVarQueryParameter['filter[credential_type][eq]'] = filterCredentialTypeEq;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List applications owned by the developer currently logged in.
         * @summary List Applications
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {string} [filterAuthStrategyIdEq] Filter by the id of the auth strategy supported by the application.
         * @param {string} [filterAuthStrategyId] Filter by the id of the auth strategy supported by the application (short-hand).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications: async (pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, filterAuthStrategyIdEq?: string, filterAuthStrategyId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (filterNameEq !== undefined) {
                localVarQueryParameter['filter[name][eq]'] = filterNameEq;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterNameContains !== undefined) {
                localVarQueryParameter['filter[name][contains]'] = filterNameContains;
            }

            if (filterAuthStrategyIdEq !== undefined) {
                localVarQueryParameter['filter[auth_strategy_id][eq]'] = filterAuthStrategyIdEq;
            }

            if (filterAuthStrategyId !== undefined) {
                localVarQueryParameter['filter[auth_strategy_id]'] = filterAuthStrategyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an application, replacing specified properties with any new values supplied in the request body.
         * @summary Update Application
         * @param {string} applicationId Id of the targeted application
         * @param {UpdateApplicationPayload} updateApplicationPayload Update an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication: async (applicationId: string, updateApplicationPayload: UpdateApplicationPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateApplication', 'applicationId', applicationId)
            // verify required parameter 'updateApplicationPayload' is not null or undefined
            assertParamExists('updateApplication', 'updateApplicationPayload', updateApplicationPayload)
            const localVarPath = `/api/v2/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateApplicationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new Application.
         * @summary Create an Application
         * @param {CreateApplicationPayload} createApplicationPayload Create an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(createApplicationPayload: CreateApplicationPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCreationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(createApplicationPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an application and all of its associated entities (registrations).
         * @summary Delete Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the details for an existing application. You need only supply the unique application identifier that was returned upon application creation or by the list-applications endpoint.
         * @summary Get an Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the granted scopes of a specified application and product version directly from the IDP. Scopes shared between product versions will be returned, even if not currently registered for given product version. Will return 409 if this feature is not supported by the application. 
         * @summary Get the granted scopes
         * @param {string} applicationId Id of the targeted application
         * @param {string} productVersionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationProductVersionGrantedScopes(applicationId: string, productVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGrantedScopesProductVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationProductVersionGrantedScopes(applicationId, productVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the available Auth Strategies on this portal. An Auth Strategy is a set of plugin configurations that represent how the gateway will perform authentication and authorization for a Product Version. It may reference to Key-Auth or an OIDC configuration (with or without DCR). 
         * @summary List the available auth strategies
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {'client_credentials' | 'self_managed_client_credentials' | 'key_auth'} [filterCredentialTypeEq] Filter by direct equality comparison of the credential_type with a supplied value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationAuthStrategies(pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, filterCredentialTypeEq?: 'client_credentials' | 'self_managed_client_credentials' | 'key_auth', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAuthStrategiesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationAuthStrategies(pageSize, pageNumber, filterNameEq, filterName, filterNameContains, filterCredentialTypeEq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List applications owned by the developer currently logged in.
         * @summary List Applications
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {string} [filterAuthStrategyIdEq] Filter by the id of the auth strategy supported by the application.
         * @param {string} [filterAuthStrategyId] Filter by the id of the auth strategy supported by the application (short-hand).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplications(pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, filterAuthStrategyIdEq?: string, filterAuthStrategyId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApplicationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplications(pageSize, pageNumber, filterNameEq, filterName, filterNameContains, filterAuthStrategyIdEq, filterAuthStrategyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an application, replacing specified properties with any new values supplied in the request body.
         * @summary Update Application
         * @param {string} applicationId Id of the targeted application
         * @param {UpdateApplicationPayload} updateApplicationPayload Update an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplication(applicationId: string, updateApplicationPayload: UpdateApplicationPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplication(applicationId, updateApplicationPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * Creates a new Application.
         * @summary Create an Application
         * @param {CreateApplicationPayload} createApplicationPayload Create an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(createApplicationPayload: CreateApplicationPayload, options?: any): AxiosPromise<ApplicationCreationResponse> {
            return localVarFp.createApplication(createApplicationPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an application and all of its associated entities (registrations).
         * @summary Delete Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the details for an existing application. You need only supply the unique application identifier that was returned upon application creation or by the list-applications endpoint.
         * @summary Get an Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(applicationId: string, options?: any): AxiosPromise<GetApplicationResponse> {
            return localVarFp.getApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the granted scopes of a specified application and product version directly from the IDP. Scopes shared between product versions will be returned, even if not currently registered for given product version. Will return 409 if this feature is not supported by the application. 
         * @summary Get the granted scopes
         * @param {string} applicationId Id of the targeted application
         * @param {string} productVersionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationProductVersionGrantedScopes(applicationId: string, productVersionId: string, options?: any): AxiosPromise<GetGrantedScopesProductVersionResponse> {
            return localVarFp.getApplicationProductVersionGrantedScopes(applicationId, productVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the available Auth Strategies on this portal. An Auth Strategy is a set of plugin configurations that represent how the gateway will perform authentication and authorization for a Product Version. It may reference to Key-Auth or an OIDC configuration (with or without DCR). 
         * @summary List the available auth strategies
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {'client_credentials' | 'self_managed_client_credentials' | 'key_auth'} [filterCredentialTypeEq] Filter by direct equality comparison of the credential_type with a supplied value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationAuthStrategies(pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, filterCredentialTypeEq?: 'client_credentials' | 'self_managed_client_credentials' | 'key_auth', options?: any): AxiosPromise<ListAuthStrategiesResponse> {
            return localVarFp.listApplicationAuthStrategies(pageSize, pageNumber, filterNameEq, filterName, filterNameContains, filterCredentialTypeEq, options).then((request) => request(axios, basePath));
        },
        /**
         * List applications owned by the developer currently logged in.
         * @summary List Applications
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {string} [filterAuthStrategyIdEq] Filter by the id of the auth strategy supported by the application.
         * @param {string} [filterAuthStrategyId] Filter by the id of the auth strategy supported by the application (short-hand).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, filterAuthStrategyIdEq?: string, filterAuthStrategyId?: string, options?: any): AxiosPromise<ListApplicationsResponse> {
            return localVarFp.listApplications(pageSize, pageNumber, filterNameEq, filterName, filterNameContains, filterAuthStrategyIdEq, filterAuthStrategyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an application, replacing specified properties with any new values supplied in the request body.
         * @summary Update Application
         * @param {string} applicationId Id of the targeted application
         * @param {UpdateApplicationPayload} updateApplicationPayload Update an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication(applicationId: string, updateApplicationPayload: UpdateApplicationPayload, options?: any): AxiosPromise<ApplicationUpdateResponse> {
            return localVarFp.updateApplication(applicationId, updateApplicationPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiCreateApplicationRequest
 */
export interface ApplicationsApiCreateApplicationRequest {
    /**
     * Create an application
     * @type {CreateApplicationPayload}
     * @memberof ApplicationsApiCreateApplication
     */
    readonly createApplicationPayload: CreateApplicationPayload
}

/**
 * Request parameters for deleteApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiDeleteApplicationRequest
 */
export interface ApplicationsApiDeleteApplicationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof ApplicationsApiDeleteApplication
     */
    readonly applicationId: string
}

/**
 * Request parameters for getApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiGetApplicationRequest
 */
export interface ApplicationsApiGetApplicationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof ApplicationsApiGetApplication
     */
    readonly applicationId: string
}

/**
 * Request parameters for getApplicationProductVersionGrantedScopes operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiGetApplicationProductVersionGrantedScopesRequest
 */
export interface ApplicationsApiGetApplicationProductVersionGrantedScopesRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof ApplicationsApiGetApplicationProductVersionGrantedScopes
     */
    readonly applicationId: string

    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof ApplicationsApiGetApplicationProductVersionGrantedScopes
     */
    readonly productVersionId: string
}

/**
 * Request parameters for listApplicationAuthStrategies operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiListApplicationAuthStrategiesRequest
 */
export interface ApplicationsApiListApplicationAuthStrategiesRequest {
    /**
     * The maximum number of items to include per page. The last page of a collection may include fewer items.
     * @type {number}
     * @memberof ApplicationsApiListApplicationAuthStrategies
     */
    readonly pageSize?: number

    /**
     * Determines which page of the entities to retrieve.
     * @type {number}
     * @memberof ApplicationsApiListApplicationAuthStrategies
     */
    readonly pageNumber?: number

    /**
     * Filter by direct equality comparison of the name property with a supplied value.
     * @type {string}
     * @memberof ApplicationsApiListApplicationAuthStrategies
     */
    readonly filterNameEq?: string

    /**
     * Filter by direct equality comparison (short-hand) of the name property with a supplied value.
     * @type {string}
     * @memberof ApplicationsApiListApplicationAuthStrategies
     */
    readonly filterName?: string

    /**
     * Filter by contains comparison of the name property with a supplied substring
     * @type {string}
     * @memberof ApplicationsApiListApplicationAuthStrategies
     */
    readonly filterNameContains?: string

    /**
     * Filter by direct equality comparison of the credential_type with a supplied value.
     * @type {'client_credentials' | 'self_managed_client_credentials' | 'key_auth'}
     * @memberof ApplicationsApiListApplicationAuthStrategies
     */
    readonly filterCredentialTypeEq?: 'client_credentials' | 'self_managed_client_credentials' | 'key_auth'
}

/**
 * Request parameters for listApplications operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiListApplicationsRequest
 */
export interface ApplicationsApiListApplicationsRequest {
    /**
     * The maximum number of items to include per page. The last page of a collection may include fewer items.
     * @type {number}
     * @memberof ApplicationsApiListApplications
     */
    readonly pageSize?: number

    /**
     * Determines which page of the entities to retrieve.
     * @type {number}
     * @memberof ApplicationsApiListApplications
     */
    readonly pageNumber?: number

    /**
     * Filter by direct equality comparison of the name property with a supplied value.
     * @type {string}
     * @memberof ApplicationsApiListApplications
     */
    readonly filterNameEq?: string

    /**
     * Filter by direct equality comparison (short-hand) of the name property with a supplied value.
     * @type {string}
     * @memberof ApplicationsApiListApplications
     */
    readonly filterName?: string

    /**
     * Filter by contains comparison of the name property with a supplied substring
     * @type {string}
     * @memberof ApplicationsApiListApplications
     */
    readonly filterNameContains?: string

    /**
     * Filter by the id of the auth strategy supported by the application.
     * @type {string}
     * @memberof ApplicationsApiListApplications
     */
    readonly filterAuthStrategyIdEq?: string

    /**
     * Filter by the id of the auth strategy supported by the application (short-hand).
     * @type {string}
     * @memberof ApplicationsApiListApplications
     */
    readonly filterAuthStrategyId?: string
}

/**
 * Request parameters for updateApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiUpdateApplicationRequest
 */
export interface ApplicationsApiUpdateApplicationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof ApplicationsApiUpdateApplication
     */
    readonly applicationId: string

    /**
     * Update an application
     * @type {UpdateApplicationPayload}
     * @memberof ApplicationsApiUpdateApplication
     */
    readonly updateApplicationPayload: UpdateApplicationPayload
}

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * Creates a new Application.
     * @summary Create an Application
     * @param {ApplicationsApiCreateApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public createApplication(requestParameters: ApplicationsApiCreateApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).createApplication(requestParameters.createApplicationPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an application and all of its associated entities (registrations).
     * @summary Delete Application
     * @param {ApplicationsApiDeleteApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public deleteApplication(requestParameters: ApplicationsApiDeleteApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).deleteApplication(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the details for an existing application. You need only supply the unique application identifier that was returned upon application creation or by the list-applications endpoint.
     * @summary Get an Application
     * @param {ApplicationsApiGetApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getApplication(requestParameters: ApplicationsApiGetApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getApplication(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the granted scopes of a specified application and product version directly from the IDP. Scopes shared between product versions will be returned, even if not currently registered for given product version. Will return 409 if this feature is not supported by the application. 
     * @summary Get the granted scopes
     * @param {ApplicationsApiGetApplicationProductVersionGrantedScopesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getApplicationProductVersionGrantedScopes(requestParameters: ApplicationsApiGetApplicationProductVersionGrantedScopesRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getApplicationProductVersionGrantedScopes(requestParameters.applicationId, requestParameters.productVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the available Auth Strategies on this portal. An Auth Strategy is a set of plugin configurations that represent how the gateway will perform authentication and authorization for a Product Version. It may reference to Key-Auth or an OIDC configuration (with or without DCR). 
     * @summary List the available auth strategies
     * @param {ApplicationsApiListApplicationAuthStrategiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplicationAuthStrategies(requestParameters: ApplicationsApiListApplicationAuthStrategiesRequest = {}, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplicationAuthStrategies(requestParameters.pageSize, requestParameters.pageNumber, requestParameters.filterNameEq, requestParameters.filterName, requestParameters.filterNameContains, requestParameters.filterCredentialTypeEq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List applications owned by the developer currently logged in.
     * @summary List Applications
     * @param {ApplicationsApiListApplicationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplications(requestParameters: ApplicationsApiListApplicationsRequest = {}, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplications(requestParameters.pageSize, requestParameters.pageNumber, requestParameters.filterNameEq, requestParameters.filterName, requestParameters.filterNameContains, requestParameters.filterAuthStrategyIdEq, requestParameters.filterAuthStrategyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an application, replacing specified properties with any new values supplied in the request body.
     * @summary Update Application
     * @param {ApplicationsApiUpdateApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public updateApplication(requestParameters: ApplicationsApiUpdateApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).updateApplication(requestParameters.applicationId, requestParameters.updateApplicationPayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CredentialsApi - axios parameter creator
 * @export
 */
export const CredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows a developer to create a credential for an application they own.
         * @summary Create Credential for Application
         * @param {string} applicationId Id of the targeted application
         * @param {CreateCredentialPayload} [createCredentialPayload] Create a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredential: async (applicationId: string, createCredentialPayload?: CreateCredentialPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createCredential', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/credentials`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCredentialPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a credential for an application they own.
         * @summary Delete Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential: async (applicationId: string, credentialId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteCredential', 'applicationId', applicationId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('deleteCredential', 'credentialId', credentialId)
            const localVarPath = `/api/v2/applications/{applicationId}/credentials/{credentialId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the credentials for an application they own.
         * @summary List credentials
         * @param {string} applicationId Id of the targeted application
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials: async (applicationId: string, pageSize?: number, pageNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listCredentials', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/credentials`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the client secret for an application.
         * @summary Refresh Client Secret
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshApplicationToken: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('refreshApplicationToken', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/refresh-token`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a credential for an application owned by the current logged in developer.
         * @summary Update Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {UpdateCredentialPayload} updateCredentialPayload Update a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential: async (applicationId: string, credentialId: string, updateCredentialPayload: UpdateCredentialPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateCredential', 'applicationId', applicationId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('updateCredential', 'credentialId', credentialId)
            // verify required parameter 'updateCredentialPayload' is not null or undefined
            assertParamExists('updateCredential', 'updateCredentialPayload', updateCredentialPayload)
            const localVarPath = `/api/v2/applications/{applicationId}/credentials/{credentialId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCredentialPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CredentialsApi - functional programming interface
 * @export
 */
export const CredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows a developer to create a credential for an application they own.
         * @summary Create Credential for Application
         * @param {string} applicationId Id of the targeted application
         * @param {CreateCredentialPayload} [createCredentialPayload] Create a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredential(applicationId: string, createCredentialPayload?: CreateCredentialPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialCreationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredential(applicationId, createCredentialPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a credential for an application they own.
         * @summary Delete Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCredential(applicationId: string, credentialId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCredential(applicationId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the credentials for an application they own.
         * @summary List credentials
         * @param {string} applicationId Id of the targeted application
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCredentials(applicationId: string, pageSize?: number, pageNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCredentialsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredentials(applicationId, pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resets the client secret for an application.
         * @summary Refresh Client Secret
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshApplicationToken(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshApplicationToken(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a credential for an application owned by the current logged in developer.
         * @summary Update Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {UpdateCredentialPayload} updateCredentialPayload Update a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCredential(applicationId: string, credentialId: string, updateCredentialPayload: UpdateCredentialPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCredential(applicationId, credentialId, updateCredentialPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CredentialsApi - factory interface
 * @export
 */
export const CredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CredentialsApiFp(configuration)
    return {
        /**
         * Allows a developer to create a credential for an application they own.
         * @summary Create Credential for Application
         * @param {string} applicationId Id of the targeted application
         * @param {CreateCredentialPayload} [createCredentialPayload] Create a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredential(applicationId: string, createCredentialPayload?: CreateCredentialPayload, options?: any): AxiosPromise<CredentialCreationResponse> {
            return localVarFp.createCredential(applicationId, createCredentialPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a credential for an application they own.
         * @summary Delete Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(applicationId: string, credentialId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCredential(applicationId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the credentials for an application they own.
         * @summary List credentials
         * @param {string} applicationId Id of the targeted application
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(applicationId: string, pageSize?: number, pageNumber?: number, options?: any): AxiosPromise<ListCredentialsResponse> {
            return localVarFp.listCredentials(applicationId, pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the client secret for an application.
         * @summary Refresh Client Secret
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshApplicationToken(applicationId: string, options?: any): AxiosPromise<RefreshTokenResponse> {
            return localVarFp.refreshApplicationToken(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a credential for an application owned by the current logged in developer.
         * @summary Update Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {UpdateCredentialPayload} updateCredentialPayload Update a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(applicationId: string, credentialId: string, updateCredentialPayload: UpdateCredentialPayload, options?: any): AxiosPromise<void> {
            return localVarFp.updateCredential(applicationId, credentialId, updateCredentialPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCredential operation in CredentialsApi.
 * @export
 * @interface CredentialsApiCreateCredentialRequest
 */
export interface CredentialsApiCreateCredentialRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiCreateCredential
     */
    readonly applicationId: string

    /**
     * Create a credential
     * @type {CreateCredentialPayload}
     * @memberof CredentialsApiCreateCredential
     */
    readonly createCredentialPayload?: CreateCredentialPayload
}

/**
 * Request parameters for deleteCredential operation in CredentialsApi.
 * @export
 * @interface CredentialsApiDeleteCredentialRequest
 */
export interface CredentialsApiDeleteCredentialRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiDeleteCredential
     */
    readonly applicationId: string

    /**
     * Id of the targeted credential
     * @type {string}
     * @memberof CredentialsApiDeleteCredential
     */
    readonly credentialId: string
}

/**
 * Request parameters for listCredentials operation in CredentialsApi.
 * @export
 * @interface CredentialsApiListCredentialsRequest
 */
export interface CredentialsApiListCredentialsRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiListCredentials
     */
    readonly applicationId: string

    /**
     * The maximum number of items to include per page. The last page of a collection may include fewer items.
     * @type {number}
     * @memberof CredentialsApiListCredentials
     */
    readonly pageSize?: number

    /**
     * Determines which page of the entities to retrieve.
     * @type {number}
     * @memberof CredentialsApiListCredentials
     */
    readonly pageNumber?: number
}

/**
 * Request parameters for refreshApplicationToken operation in CredentialsApi.
 * @export
 * @interface CredentialsApiRefreshApplicationTokenRequest
 */
export interface CredentialsApiRefreshApplicationTokenRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiRefreshApplicationToken
     */
    readonly applicationId: string
}

/**
 * Request parameters for updateCredential operation in CredentialsApi.
 * @export
 * @interface CredentialsApiUpdateCredentialRequest
 */
export interface CredentialsApiUpdateCredentialRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiUpdateCredential
     */
    readonly applicationId: string

    /**
     * Id of the targeted credential
     * @type {string}
     * @memberof CredentialsApiUpdateCredential
     */
    readonly credentialId: string

    /**
     * Update a credential
     * @type {UpdateCredentialPayload}
     * @memberof CredentialsApiUpdateCredential
     */
    readonly updateCredentialPayload: UpdateCredentialPayload
}

/**
 * CredentialsApi - object-oriented interface
 * @export
 * @class CredentialsApi
 * @extends {BaseAPI}
 */
export class CredentialsApi extends BaseAPI {
    /**
     * Allows a developer to create a credential for an application they own.
     * @summary Create Credential for Application
     * @param {CredentialsApiCreateCredentialRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public createCredential(requestParameters: CredentialsApiCreateCredentialRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).createCredential(requestParameters.applicationId, requestParameters.createCredentialPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a credential for an application they own.
     * @summary Delete Credential
     * @param {CredentialsApiDeleteCredentialRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public deleteCredential(requestParameters: CredentialsApiDeleteCredentialRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).deleteCredential(requestParameters.applicationId, requestParameters.credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the credentials for an application they own.
     * @summary List credentials
     * @param {CredentialsApiListCredentialsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public listCredentials(requestParameters: CredentialsApiListCredentialsRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).listCredentials(requestParameters.applicationId, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the client secret for an application.
     * @summary Refresh Client Secret
     * @param {CredentialsApiRefreshApplicationTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public refreshApplicationToken(requestParameters: CredentialsApiRefreshApplicationTokenRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).refreshApplicationToken(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a credential for an application owned by the current logged in developer.
     * @summary Update Credential
     * @param {CredentialsApiUpdateCredentialRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public updateCredential(requestParameters: CredentialsApiUpdateCredentialRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).updateCredential(requestParameters.applicationId, requestParameters.credentialId, requestParameters.updateCredentialPayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeveloperApi - axios parameter creator
 * @export
 */
export const DeveloperApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows a developer to authenticate to their portal using a username and password.
         * @summary Authenticate
         * @param {AuthenticateRequest} [authenticateRequest] The request schema for the authenticate endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (authenticateRequest?: AuthenticateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/developer/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows a developer to authenticate to their portal using an external IdP.
         * @summary Authenticate SSO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateSso: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/developer/authenticate/sso`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the password reset flow for the desired account. An email will be sent to the email address to initiate the password reset flow. 
         * @summary Forgot Password
         * @param {ResetPasswordPayload} [resetPasswordPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (resetPasswordPayload?: ResetPasswordPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/developer/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns info about the current developer.
         * @summary Retrieve My Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperMe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/developer/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows a developer to logout of the portal. This operation revokes all active tokens and clears the portal cookies.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/developer/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows a developer to refresh their existing access token.
         * @summary Refresh Access Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/developer/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register to the developer portal.
         * @summary Register
         * @param {{ [key: string]: any; }} [requestBody] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (requestBody?: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/developer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows a developer to reset their password, using a reset token.
         * @summary Reset Password
         * @param {ResetPasswordRequest} [resetPasswordRequest] The request schema for the reset password endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetPasswordRequest?: ResetPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/developer/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows a new developer to verify their email.
         * @summary Verify Email
         * @param {VerifyEmailRequest} [verifyEmailRequest] The request schema for the verify email endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail: async (verifyEmailRequest?: VerifyEmailRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/developer/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeveloperApi - functional programming interface
 * @export
 */
export const DeveloperApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeveloperApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows a developer to authenticate to their portal using a username and password.
         * @summary Authenticate
         * @param {AuthenticateRequest} [authenticateRequest] The request schema for the authenticate endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(authenticateRequest?: AuthenticateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(authenticateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows a developer to authenticate to their portal using an external IdP.
         * @summary Authenticate SSO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateSso(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateSso(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Starts the password reset flow for the desired account. An email will be sent to the email address to initiate the password reset flow. 
         * @summary Forgot Password
         * @param {ResetPasswordPayload} [resetPasswordPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(resetPasswordPayload?: ResetPasswordPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(resetPasswordPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns info about the current developer.
         * @summary Retrieve My Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeveloperMe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Developer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeveloperMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows a developer to logout of the portal. This operation revokes all active tokens and clears the portal cookies.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows a developer to refresh their existing access token.
         * @summary Refresh Access Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refresh(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register to the developer portal.
         * @summary Register
         * @param {{ [key: string]: any; }} [requestBody] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(requestBody?: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows a developer to reset their password, using a reset token.
         * @summary Reset Password
         * @param {ResetPasswordRequest} [resetPasswordRequest] The request schema for the reset password endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetPasswordRequest?: ResetPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows a new developer to verify their email.
         * @summary Verify Email
         * @param {VerifyEmailRequest} [verifyEmailRequest] The request schema for the verify email endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmail(verifyEmailRequest?: VerifyEmailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyEmailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmail(verifyEmailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeveloperApi - factory interface
 * @export
 */
export const DeveloperApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeveloperApiFp(configuration)
    return {
        /**
         * This endpoint allows a developer to authenticate to their portal using a username and password.
         * @summary Authenticate
         * @param {AuthenticateRequest} [authenticateRequest] The request schema for the authenticate endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(authenticateRequest?: AuthenticateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.authenticate(authenticateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows a developer to authenticate to their portal using an external IdP.
         * @summary Authenticate SSO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateSso(options?: any): AxiosPromise<void> {
            return localVarFp.authenticateSso(options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the password reset flow for the desired account. An email will be sent to the email address to initiate the password reset flow. 
         * @summary Forgot Password
         * @param {ResetPasswordPayload} [resetPasswordPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(resetPasswordPayload?: ResetPasswordPayload, options?: any): AxiosPromise<void> {
            return localVarFp.forgotPassword(resetPasswordPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns info about the current developer.
         * @summary Retrieve My Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperMe(options?: any): AxiosPromise<Developer> {
            return localVarFp.getDeveloperMe(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows a developer to logout of the portal. This operation revokes all active tokens and clears the portal cookies.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows a developer to refresh their existing access token.
         * @summary Refresh Access Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(options?: any): AxiosPromise<void> {
            return localVarFp.refresh(options).then((request) => request(axios, basePath));
        },
        /**
         * Register to the developer portal.
         * @summary Register
         * @param {{ [key: string]: any; }} [requestBody] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(requestBody?: { [key: string]: any; }, options?: any): AxiosPromise<void> {
            return localVarFp.register(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows a developer to reset their password, using a reset token.
         * @summary Reset Password
         * @param {ResetPasswordRequest} [resetPasswordRequest] The request schema for the reset password endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(resetPasswordRequest?: ResetPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.resetPassword(resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows a new developer to verify their email.
         * @summary Verify Email
         * @param {VerifyEmailRequest} [verifyEmailRequest] The request schema for the verify email endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(verifyEmailRequest?: VerifyEmailRequest, options?: any): AxiosPromise<VerifyEmailResponse> {
            return localVarFp.verifyEmail(verifyEmailRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authenticate operation in DeveloperApi.
 * @export
 * @interface DeveloperApiAuthenticateRequest
 */
export interface DeveloperApiAuthenticateRequest {
    /**
     * The request schema for the authenticate endpoint.
     * @type {AuthenticateRequest}
     * @memberof DeveloperApiAuthenticate
     */
    readonly authenticateRequest?: AuthenticateRequest
}

/**
 * Request parameters for forgotPassword operation in DeveloperApi.
 * @export
 * @interface DeveloperApiForgotPasswordRequest
 */
export interface DeveloperApiForgotPasswordRequest {
    /**
     * Developer registration
     * @type {ResetPasswordPayload}
     * @memberof DeveloperApiForgotPassword
     */
    readonly resetPasswordPayload?: ResetPasswordPayload
}

/**
 * Request parameters for register operation in DeveloperApi.
 * @export
 * @interface DeveloperApiRegisterRequest
 */
export interface DeveloperApiRegisterRequest {
    /**
     * Developer registration
     * @type {{ [key: string]: any; }}
     * @memberof DeveloperApiRegister
     */
    readonly requestBody?: { [key: string]: any; }
}

/**
 * Request parameters for resetPassword operation in DeveloperApi.
 * @export
 * @interface DeveloperApiResetPasswordRequest
 */
export interface DeveloperApiResetPasswordRequest {
    /**
     * The request schema for the reset password endpoint.
     * @type {ResetPasswordRequest}
     * @memberof DeveloperApiResetPassword
     */
    readonly resetPasswordRequest?: ResetPasswordRequest
}

/**
 * Request parameters for verifyEmail operation in DeveloperApi.
 * @export
 * @interface DeveloperApiVerifyEmailRequest
 */
export interface DeveloperApiVerifyEmailRequest {
    /**
     * The request schema for the verify email endpoint.
     * @type {VerifyEmailRequest}
     * @memberof DeveloperApiVerifyEmail
     */
    readonly verifyEmailRequest?: VerifyEmailRequest
}

/**
 * DeveloperApi - object-oriented interface
 * @export
 * @class DeveloperApi
 * @extends {BaseAPI}
 */
export class DeveloperApi extends BaseAPI {
    /**
     * This endpoint allows a developer to authenticate to their portal using a username and password.
     * @summary Authenticate
     * @param {DeveloperApiAuthenticateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperApi
     */
    public authenticate(requestParameters: DeveloperApiAuthenticateRequest = {}, options?: AxiosRequestConfig) {
        return DeveloperApiFp(this.configuration).authenticate(requestParameters.authenticateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows a developer to authenticate to their portal using an external IdP.
     * @summary Authenticate SSO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperApi
     */
    public authenticateSso(options?: AxiosRequestConfig) {
        return DeveloperApiFp(this.configuration).authenticateSso(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts the password reset flow for the desired account. An email will be sent to the email address to initiate the password reset flow. 
     * @summary Forgot Password
     * @param {DeveloperApiForgotPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperApi
     */
    public forgotPassword(requestParameters: DeveloperApiForgotPasswordRequest = {}, options?: AxiosRequestConfig) {
        return DeveloperApiFp(this.configuration).forgotPassword(requestParameters.resetPasswordPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns info about the current developer.
     * @summary Retrieve My Account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperApi
     */
    public getDeveloperMe(options?: AxiosRequestConfig) {
        return DeveloperApiFp(this.configuration).getDeveloperMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows a developer to logout of the portal. This operation revokes all active tokens and clears the portal cookies.
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperApi
     */
    public logout(options?: AxiosRequestConfig) {
        return DeveloperApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows a developer to refresh their existing access token.
     * @summary Refresh Access Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperApi
     */
    public refresh(options?: AxiosRequestConfig) {
        return DeveloperApiFp(this.configuration).refresh(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register to the developer portal.
     * @summary Register
     * @param {DeveloperApiRegisterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperApi
     */
    public register(requestParameters: DeveloperApiRegisterRequest = {}, options?: AxiosRequestConfig) {
        return DeveloperApiFp(this.configuration).register(requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows a developer to reset their password, using a reset token.
     * @summary Reset Password
     * @param {DeveloperApiResetPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperApi
     */
    public resetPassword(requestParameters: DeveloperApiResetPasswordRequest = {}, options?: AxiosRequestConfig) {
        return DeveloperApiFp(this.configuration).resetPassword(requestParameters.resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows a new developer to verify their email.
     * @summary Verify Email
     * @param {DeveloperApiVerifyEmailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperApi
     */
    public verifyEmail(requestParameters: DeveloperApiVerifyEmailRequest = {}, options?: AxiosRequestConfig) {
        return DeveloperApiFp(this.configuration).verifyEmail(requestParameters.verifyEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentationApi - axios parameter creator
 * @export
 */
export const DocumentationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the specified document from the product\'s document tree.
         * @summary Get one product document
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} documentId Contains a unique identifier used by the Portal API for this resource.
         * @param {DocumentFormatContentTypeEnum} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductDocument: async (productId: string, documentId: string, accept?: DocumentFormatContentTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductDocument', 'productId', productId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getProductDocument', 'documentId', documentId)
            const localVarPath = `/api/v2/products/{productId}/documents/{documentId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (accept != null) {
                localVarHeaderParameter['Accept'] = typeof accept === 'string' 
                    ? accept 
                    : JSON.stringify(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of documents that are associated with a given product. The list is paginated, and is in either a list or tree format (based on the Accept header).
         * @summary List product documents
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {DocumentContentTypeEnum} [accept] 
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductDocuments: async (productId: string, accept?: DocumentContentTypeEnum, pageSize?: number, pageNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('listProductDocuments', 'productId', productId)
            const localVarPath = `/api/v2/products/{productId}/documents`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (accept != null) {
                localVarHeaderParameter['Accept'] = typeof accept === 'string' 
                    ? accept 
                    : JSON.stringify(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentationApi - functional programming interface
 * @export
 */
export const DocumentationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentationApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the specified document from the product\'s document tree.
         * @summary Get one product document
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} documentId Contains a unique identifier used by the Portal API for this resource.
         * @param {DocumentFormatContentTypeEnum} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductDocument(productId: string, documentId: string, accept?: DocumentFormatContentTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDocumentRaw>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductDocument(productId, documentId, accept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of documents that are associated with a given product. The list is paginated, and is in either a list or tree format (based on the Accept header).
         * @summary List product documents
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {DocumentContentTypeEnum} [accept] 
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductDocuments(productId: string, accept?: DocumentContentTypeEnum, pageSize?: number, pageNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDocuments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProductDocuments(productId, accept, pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentationApi - factory interface
 * @export
 */
export const DocumentationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentationApiFp(configuration)
    return {
        /**
         * Returns the specified document from the product\'s document tree.
         * @summary Get one product document
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} documentId Contains a unique identifier used by the Portal API for this resource.
         * @param {DocumentFormatContentTypeEnum} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductDocument(productId: string, documentId: string, accept?: DocumentFormatContentTypeEnum, options?: any): AxiosPromise<ProductDocumentRaw> {
            return localVarFp.getProductDocument(productId, documentId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of documents that are associated with a given product. The list is paginated, and is in either a list or tree format (based on the Accept header).
         * @summary List product documents
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {DocumentContentTypeEnum} [accept] 
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductDocuments(productId: string, accept?: DocumentContentTypeEnum, pageSize?: number, pageNumber?: number, options?: any): AxiosPromise<ListDocuments> {
            return localVarFp.listProductDocuments(productId, accept, pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getProductDocument operation in DocumentationApi.
 * @export
 * @interface DocumentationApiGetProductDocumentRequest
 */
export interface DocumentationApiGetProductDocumentRequest {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof DocumentationApiGetProductDocument
     */
    readonly productId: string

    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof DocumentationApiGetProductDocument
     */
    readonly documentId: string

    /**
     * 
     * @type {DocumentFormatContentTypeEnum}
     * @memberof DocumentationApiGetProductDocument
     */
    readonly accept?: DocumentFormatContentTypeEnum
}

/**
 * Request parameters for listProductDocuments operation in DocumentationApi.
 * @export
 * @interface DocumentationApiListProductDocumentsRequest
 */
export interface DocumentationApiListProductDocumentsRequest {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof DocumentationApiListProductDocuments
     */
    readonly productId: string

    /**
     * 
     * @type {DocumentContentTypeEnum}
     * @memberof DocumentationApiListProductDocuments
     */
    readonly accept?: DocumentContentTypeEnum

    /**
     * The maximum number of items to include per page. The last page of a collection may include fewer items.
     * @type {number}
     * @memberof DocumentationApiListProductDocuments
     */
    readonly pageSize?: number

    /**
     * Determines which page of the entities to retrieve.
     * @type {number}
     * @memberof DocumentationApiListProductDocuments
     */
    readonly pageNumber?: number
}

/**
 * DocumentationApi - object-oriented interface
 * @export
 * @class DocumentationApi
 * @extends {BaseAPI}
 */
export class DocumentationApi extends BaseAPI {
    /**
     * Returns the specified document from the product\'s document tree.
     * @summary Get one product document
     * @param {DocumentationApiGetProductDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentationApi
     */
    public getProductDocument(requestParameters: DocumentationApiGetProductDocumentRequest, options?: AxiosRequestConfig) {
        return DocumentationApiFp(this.configuration).getProductDocument(requestParameters.productId, requestParameters.documentId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of documents that are associated with a given product. The list is paginated, and is in either a list or tree format (based on the Accept header).
     * @summary List product documents
     * @param {DocumentationApiListProductDocumentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentationApi
     */
    public listProductDocuments(requestParameters: DocumentationApiListProductDocumentsRequest, options?: AxiosRequestConfig) {
        return DocumentationApiFp(this.configuration).listProductDocuments(requestParameters.productId, requestParameters.accept, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PortalApi - axios parameter creator
 * @export
 */
export const PortalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets appearance configuration object for the portal. This object is set in Konnect.
         * @summary Portal Appearance Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalAppearance: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/portal/appearance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets cover banner for the developer portal. This object is set in Konnect.
         * @summary Portal Catalog Cover Banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalCatalogCover: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/portal/catalog-cover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the portal context object.
         * @summary Get portal context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalContext: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/portal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets logo of the developer portal. This object is set in Konnect.
         * @summary Portal Logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalLogo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/portal/logo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortalApi - functional programming interface
 * @export
 */
export const PortalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortalApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets appearance configuration object for the portal. This object is set in Konnect.
         * @summary Portal Appearance Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalAppearance(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortalAppearance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalAppearance(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets cover banner for the developer portal. This object is set in Konnect.
         * @summary Portal Catalog Cover Banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalCatalogCover(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalCatalogCover(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return the portal context object.
         * @summary Get portal context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalContext(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortalContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalContext(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets logo of the developer portal. This object is set in Konnect.
         * @summary Portal Logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalLogo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalLogo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PortalApi - factory interface
 * @export
 */
export const PortalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortalApiFp(configuration)
    return {
        /**
         * Gets appearance configuration object for the portal. This object is set in Konnect.
         * @summary Portal Appearance Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalAppearance(options?: any): AxiosPromise<PortalAppearance> {
            return localVarFp.getPortalAppearance(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets cover banner for the developer portal. This object is set in Konnect.
         * @summary Portal Catalog Cover Banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalCatalogCover(options?: any): AxiosPromise<File> {
            return localVarFp.getPortalCatalogCover(options).then((request) => request(axios, basePath));
        },
        /**
         * Return the portal context object.
         * @summary Get portal context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalContext(options?: any): AxiosPromise<PortalContext> {
            return localVarFp.getPortalContext(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets logo of the developer portal. This object is set in Konnect.
         * @summary Portal Logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalLogo(options?: any): AxiosPromise<File> {
            return localVarFp.getPortalLogo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortalApi - object-oriented interface
 * @export
 * @class PortalApi
 * @extends {BaseAPI}
 */
export class PortalApi extends BaseAPI {
    /**
     * Gets appearance configuration object for the portal. This object is set in Konnect.
     * @summary Portal Appearance Details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalApi
     */
    public getPortalAppearance(options?: AxiosRequestConfig) {
        return PortalApiFp(this.configuration).getPortalAppearance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets cover banner for the developer portal. This object is set in Konnect.
     * @summary Portal Catalog Cover Banner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalApi
     */
    public getPortalCatalogCover(options?: AxiosRequestConfig) {
        return PortalApiFp(this.configuration).getPortalCatalogCover(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the portal context object.
     * @summary Get portal context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalApi
     */
    public getPortalContext(options?: AxiosRequestConfig) {
        return PortalApiFp(this.configuration).getPortalContext(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets logo of the developer portal. This object is set in Konnect.
     * @summary Portal Logo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalApi
     */
    public getPortalLogo(options?: AxiosRequestConfig) {
        return PortalApiFp(this.configuration).getPortalLogo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the details for an existing published product.
         * @summary Get a product
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (productId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProduct', 'productId', productId)
            const localVarPath = `/api/v2/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of actions that the current developer is allowed to perform on an API product.
         * @summary Get Product Actions
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductActions: async (productId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductActions', 'productId', productId)
            const localVarPath = `/api/v2/products/{productId}/actions`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of published API Products.
         * @summary List Products
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {string} [filterDescriptionEq] Filter by direct equality comparison of the description property with a supplied value.
         * @param {string} [filterDescription] Filter by direct equality comparison (short-hand) of the description property with a supplied value.
         * @param {string} [filterDescriptionContains] Filter by contains comparison of the description property with a supplied substring
         * @param {string} [filterIdEq] Filter by direct equality comparison of the id property with a supplied value.
         * @param {string} [filterId] Filter by direct equality comparison (short-hand) of the id property with a supplied value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts: async (pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, filterDescriptionEq?: string, filterDescription?: string, filterDescriptionContains?: string, filterIdEq?: string, filterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (filterNameEq !== undefined) {
                localVarQueryParameter['filter[name][eq]'] = filterNameEq;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterNameContains !== undefined) {
                localVarQueryParameter['filter[name][contains]'] = filterNameContains;
            }

            if (filterDescriptionEq !== undefined) {
                localVarQueryParameter['filter[description][eq]'] = filterDescriptionEq;
            }

            if (filterDescription !== undefined) {
                localVarQueryParameter['filter[description]'] = filterDescription;
            }

            if (filterDescriptionContains !== undefined) {
                localVarQueryParameter['filter[description][contains]'] = filterDescriptionContains;
            }

            if (filterIdEq !== undefined) {
                localVarQueryParameter['filter[id][eq]'] = filterIdEq;
            }

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets the details for an existing published product.
         * @summary Get a product
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(productId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of actions that the current developer is allowed to perform on an API product.
         * @summary Get Product Actions
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductActions(productId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductActionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductActions(productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a paginated list of published API Products.
         * @summary List Products
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {string} [filterDescriptionEq] Filter by direct equality comparison of the description property with a supplied value.
         * @param {string} [filterDescription] Filter by direct equality comparison (short-hand) of the description property with a supplied value.
         * @param {string} [filterDescriptionContains] Filter by contains comparison of the description property with a supplied substring
         * @param {string} [filterIdEq] Filter by direct equality comparison of the id property with a supplied value.
         * @param {string} [filterId] Filter by direct equality comparison (short-hand) of the id property with a supplied value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProducts(pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, filterDescriptionEq?: string, filterDescription?: string, filterDescriptionContains?: string, filterIdEq?: string, filterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductListPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProducts(pageSize, pageNumber, filterNameEq, filterName, filterNameContains, filterDescriptionEq, filterDescription, filterDescriptionContains, filterIdEq, filterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * Gets the details for an existing published product.
         * @summary Get a product
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(productId: string, options?: any): AxiosPromise<Product> {
            return localVarFp.getProduct(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of actions that the current developer is allowed to perform on an API product.
         * @summary Get Product Actions
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductActions(productId: string, options?: any): AxiosPromise<ProductActionsResponse> {
            return localVarFp.getProductActions(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of published API Products.
         * @summary List Products
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {string} [filterDescriptionEq] Filter by direct equality comparison of the description property with a supplied value.
         * @param {string} [filterDescription] Filter by direct equality comparison (short-hand) of the description property with a supplied value.
         * @param {string} [filterDescriptionContains] Filter by contains comparison of the description property with a supplied substring
         * @param {string} [filterIdEq] Filter by direct equality comparison of the id property with a supplied value.
         * @param {string} [filterId] Filter by direct equality comparison (short-hand) of the id property with a supplied value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, filterDescriptionEq?: string, filterDescription?: string, filterDescriptionContains?: string, filterIdEq?: string, filterId?: string, options?: any): AxiosPromise<ProductListPage> {
            return localVarFp.listProducts(pageSize, pageNumber, filterNameEq, filterName, filterNameContains, filterDescriptionEq, filterDescription, filterDescriptionContains, filterIdEq, filterId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getProduct operation in ProductsApi.
 * @export
 * @interface ProductsApiGetProductRequest
 */
export interface ProductsApiGetProductRequest {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof ProductsApiGetProduct
     */
    readonly productId: string
}

/**
 * Request parameters for getProductActions operation in ProductsApi.
 * @export
 * @interface ProductsApiGetProductActionsRequest
 */
export interface ProductsApiGetProductActionsRequest {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof ProductsApiGetProductActions
     */
    readonly productId: string
}

/**
 * Request parameters for listProducts operation in ProductsApi.
 * @export
 * @interface ProductsApiListProductsRequest
 */
export interface ProductsApiListProductsRequest {
    /**
     * The maximum number of items to include per page. The last page of a collection may include fewer items.
     * @type {number}
     * @memberof ProductsApiListProducts
     */
    readonly pageSize?: number

    /**
     * Determines which page of the entities to retrieve.
     * @type {number}
     * @memberof ProductsApiListProducts
     */
    readonly pageNumber?: number

    /**
     * Filter by direct equality comparison of the name property with a supplied value.
     * @type {string}
     * @memberof ProductsApiListProducts
     */
    readonly filterNameEq?: string

    /**
     * Filter by direct equality comparison (short-hand) of the name property with a supplied value.
     * @type {string}
     * @memberof ProductsApiListProducts
     */
    readonly filterName?: string

    /**
     * Filter by contains comparison of the name property with a supplied substring
     * @type {string}
     * @memberof ProductsApiListProducts
     */
    readonly filterNameContains?: string

    /**
     * Filter by direct equality comparison of the description property with a supplied value.
     * @type {string}
     * @memberof ProductsApiListProducts
     */
    readonly filterDescriptionEq?: string

    /**
     * Filter by direct equality comparison (short-hand) of the description property with a supplied value.
     * @type {string}
     * @memberof ProductsApiListProducts
     */
    readonly filterDescription?: string

    /**
     * Filter by contains comparison of the description property with a supplied substring
     * @type {string}
     * @memberof ProductsApiListProducts
     */
    readonly filterDescriptionContains?: string

    /**
     * Filter by direct equality comparison of the id property with a supplied value.
     * @type {string}
     * @memberof ProductsApiListProducts
     */
    readonly filterIdEq?: string

    /**
     * Filter by direct equality comparison (short-hand) of the id property with a supplied value.
     * @type {string}
     * @memberof ProductsApiListProducts
     */
    readonly filterId?: string
}

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Gets the details for an existing published product.
     * @summary Get a product
     * @param {ProductsApiGetProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProduct(requestParameters: ProductsApiGetProductRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProduct(requestParameters.productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of actions that the current developer is allowed to perform on an API product.
     * @summary Get Product Actions
     * @param {ProductsApiGetProductActionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductActions(requestParameters: ProductsApiGetProductActionsRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProductActions(requestParameters.productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of published API Products.
     * @summary List Products
     * @param {ProductsApiListProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listProducts(requestParameters: ProductsApiListProductsRequest = {}, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).listProducts(requestParameters.pageSize, requestParameters.pageNumber, requestParameters.filterNameEq, requestParameters.filterName, requestParameters.filterNameContains, requestParameters.filterDescriptionEq, requestParameters.filterDescription, requestParameters.filterDescriptionContains, requestParameters.filterIdEq, requestParameters.filterId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegistrationsApi - axios parameter creator
 * @export
 */
export const RegistrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Registers an application for a product.
         * @summary Register an application for a product
         * @param {string} applicationId Id of the targeted application
         * @param {CreateRegistrationPayload} createRegistrationPayload Create an application registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationRegistration: async (applicationId: string, createRegistrationPayload: CreateRegistrationPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationRegistration', 'applicationId', applicationId)
            // verify required parameter 'createRegistrationPayload' is not null or undefined
            assertParamExists('createApplicationRegistration', 'createRegistrationPayload', createRegistrationPayload)
            const localVarPath = `/api/v2/applications/{applicationId}/registrations`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRegistrationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unregister an application for a product version.
         * @summary Delete an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationRegistration: async (applicationId: string, registrationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationRegistration', 'applicationId', applicationId)
            // verify required parameter 'registrationId' is not null or undefined
            assertParamExists('deleteApplicationRegistration', 'registrationId', registrationId)
            const localVarPath = `/api/v2/applications/{applicationId}/registrations/{registrationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"registrationId"}}`, encodeURIComponent(String(registrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the specified product registration for an application.
         * @summary Get an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationRegistration: async (applicationId: string, registrationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationRegistration', 'applicationId', applicationId)
            // verify required parameter 'registrationId' is not null or undefined
            assertParamExists('getApplicationRegistration', 'registrationId', registrationId)
            const localVarPath = `/api/v2/applications/{applicationId}/registrations/{registrationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"registrationId"}}`, encodeURIComponent(String(registrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the granted scopes of a specified product registration directly from the IDP for an application. Will return 409 if this feature is not supported by the application. 
         * @summary Get the granted scopes of an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationRegistrationGrantedScopes: async (applicationId: string, registrationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationRegistrationGrantedScopes', 'applicationId', applicationId)
            // verify required parameter 'registrationId' is not null or undefined
            assertParamExists('getApplicationRegistrationGrantedScopes', 'registrationId', registrationId)
            const localVarPath = `/api/v2/applications/{applicationId}/registrations/{registrationId}/granted-scopes`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"registrationId"}}`, encodeURIComponent(String(registrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists product registrations for an application.
         * @summary Get application registrations
         * @param {string} applicationId Id of the targeted application
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterIdEq] Filter by direct equality comparison of the id property with a supplied value.
         * @param {string} [filterId] Filter by direct equality comparison (short-hand) of the id property with a supplied value.
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatusEq] Filter by direct equality comparison of the status property with a supplied value.
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatus] Filter by direct equality comparison (short-hand) of the status property with a supplied value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationRegistrations: async (applicationId: string, pageSize?: number, pageNumber?: number, filterIdEq?: string, filterId?: string, filterStatusEq?: 'approved' | 'pending' | 'rejected' | 'revoked', filterStatus?: 'approved' | 'pending' | 'rejected' | 'revoked', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationRegistrations', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/registrations`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (filterIdEq !== undefined) {
                localVarQueryParameter['filter[id][eq]'] = filterIdEq;
            }

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterStatusEq !== undefined) {
                localVarQueryParameter['filter[status][eq]'] = filterStatusEq;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistrationsApi - functional programming interface
 * @export
 */
export const RegistrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Registers an application for a product.
         * @summary Register an application for a product
         * @param {string} applicationId Id of the targeted application
         * @param {CreateRegistrationPayload} createRegistrationPayload Create an application registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationRegistration(applicationId: string, createRegistrationPayload: CreateRegistrationPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRegistrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationRegistration(applicationId, createRegistrationPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unregister an application for a product version.
         * @summary Delete an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationRegistration(applicationId: string, registrationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationRegistration(applicationId, registrationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the specified product registration for an application.
         * @summary Get an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationRegistration(applicationId: string, registrationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRegistrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationRegistration(applicationId, registrationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the granted scopes of a specified product registration directly from the IDP for an application. Will return 409 if this feature is not supported by the application. 
         * @summary Get the granted scopes of an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationRegistrationGrantedScopes(applicationId: string, registrationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGrantedScopesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationRegistrationGrantedScopes(applicationId, registrationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists product registrations for an application.
         * @summary Get application registrations
         * @param {string} applicationId Id of the targeted application
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterIdEq] Filter by direct equality comparison of the id property with a supplied value.
         * @param {string} [filterId] Filter by direct equality comparison (short-hand) of the id property with a supplied value.
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatusEq] Filter by direct equality comparison of the status property with a supplied value.
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatus] Filter by direct equality comparison (short-hand) of the status property with a supplied value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationRegistrations(applicationId: string, pageSize?: number, pageNumber?: number, filterIdEq?: string, filterId?: string, filterStatusEq?: 'approved' | 'pending' | 'rejected' | 'revoked', filterStatus?: 'approved' | 'pending' | 'rejected' | 'revoked', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRegistrationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationRegistrations(applicationId, pageSize, pageNumber, filterIdEq, filterId, filterStatusEq, filterStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegistrationsApi - factory interface
 * @export
 */
export const RegistrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistrationsApiFp(configuration)
    return {
        /**
         * Registers an application for a product.
         * @summary Register an application for a product
         * @param {string} applicationId Id of the targeted application
         * @param {CreateRegistrationPayload} createRegistrationPayload Create an application registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationRegistration(applicationId: string, createRegistrationPayload: CreateRegistrationPayload, options?: any): AxiosPromise<GetRegistrationResponse> {
            return localVarFp.createApplicationRegistration(applicationId, createRegistrationPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Unregister an application for a product version.
         * @summary Delete an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationRegistration(applicationId: string, registrationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationRegistration(applicationId, registrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the specified product registration for an application.
         * @summary Get an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationRegistration(applicationId: string, registrationId: string, options?: any): AxiosPromise<GetRegistrationResponse> {
            return localVarFp.getApplicationRegistration(applicationId, registrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the granted scopes of a specified product registration directly from the IDP for an application. Will return 409 if this feature is not supported by the application. 
         * @summary Get the granted scopes of an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationRegistrationGrantedScopes(applicationId: string, registrationId: string, options?: any): AxiosPromise<GetGrantedScopesResponse> {
            return localVarFp.getApplicationRegistrationGrantedScopes(applicationId, registrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists product registrations for an application.
         * @summary Get application registrations
         * @param {string} applicationId Id of the targeted application
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterIdEq] Filter by direct equality comparison of the id property with a supplied value.
         * @param {string} [filterId] Filter by direct equality comparison (short-hand) of the id property with a supplied value.
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatusEq] Filter by direct equality comparison of the status property with a supplied value.
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatus] Filter by direct equality comparison (short-hand) of the status property with a supplied value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationRegistrations(applicationId: string, pageSize?: number, pageNumber?: number, filterIdEq?: string, filterId?: string, filterStatusEq?: 'approved' | 'pending' | 'rejected' | 'revoked', filterStatus?: 'approved' | 'pending' | 'rejected' | 'revoked', options?: any): AxiosPromise<ListRegistrationsResponse> {
            return localVarFp.listApplicationRegistrations(applicationId, pageSize, pageNumber, filterIdEq, filterId, filterStatusEq, filterStatus, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createApplicationRegistration operation in RegistrationsApi.
 * @export
 * @interface RegistrationsApiCreateApplicationRegistrationRequest
 */
export interface RegistrationsApiCreateApplicationRegistrationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof RegistrationsApiCreateApplicationRegistration
     */
    readonly applicationId: string

    /**
     * Create an application registration.
     * @type {CreateRegistrationPayload}
     * @memberof RegistrationsApiCreateApplicationRegistration
     */
    readonly createRegistrationPayload: CreateRegistrationPayload
}

/**
 * Request parameters for deleteApplicationRegistration operation in RegistrationsApi.
 * @export
 * @interface RegistrationsApiDeleteApplicationRegistrationRequest
 */
export interface RegistrationsApiDeleteApplicationRegistrationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof RegistrationsApiDeleteApplicationRegistration
     */
    readonly applicationId: string

    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof RegistrationsApiDeleteApplicationRegistration
     */
    readonly registrationId: string
}

/**
 * Request parameters for getApplicationRegistration operation in RegistrationsApi.
 * @export
 * @interface RegistrationsApiGetApplicationRegistrationRequest
 */
export interface RegistrationsApiGetApplicationRegistrationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof RegistrationsApiGetApplicationRegistration
     */
    readonly applicationId: string

    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof RegistrationsApiGetApplicationRegistration
     */
    readonly registrationId: string
}

/**
 * Request parameters for getApplicationRegistrationGrantedScopes operation in RegistrationsApi.
 * @export
 * @interface RegistrationsApiGetApplicationRegistrationGrantedScopesRequest
 */
export interface RegistrationsApiGetApplicationRegistrationGrantedScopesRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof RegistrationsApiGetApplicationRegistrationGrantedScopes
     */
    readonly applicationId: string

    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof RegistrationsApiGetApplicationRegistrationGrantedScopes
     */
    readonly registrationId: string
}

/**
 * Request parameters for listApplicationRegistrations operation in RegistrationsApi.
 * @export
 * @interface RegistrationsApiListApplicationRegistrationsRequest
 */
export interface RegistrationsApiListApplicationRegistrationsRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof RegistrationsApiListApplicationRegistrations
     */
    readonly applicationId: string

    /**
     * The maximum number of items to include per page. The last page of a collection may include fewer items.
     * @type {number}
     * @memberof RegistrationsApiListApplicationRegistrations
     */
    readonly pageSize?: number

    /**
     * Determines which page of the entities to retrieve.
     * @type {number}
     * @memberof RegistrationsApiListApplicationRegistrations
     */
    readonly pageNumber?: number

    /**
     * Filter by direct equality comparison of the id property with a supplied value.
     * @type {string}
     * @memberof RegistrationsApiListApplicationRegistrations
     */
    readonly filterIdEq?: string

    /**
     * Filter by direct equality comparison (short-hand) of the id property with a supplied value.
     * @type {string}
     * @memberof RegistrationsApiListApplicationRegistrations
     */
    readonly filterId?: string

    /**
     * Filter by direct equality comparison of the status property with a supplied value.
     * @type {'approved' | 'pending' | 'rejected' | 'revoked'}
     * @memberof RegistrationsApiListApplicationRegistrations
     */
    readonly filterStatusEq?: 'approved' | 'pending' | 'rejected' | 'revoked'

    /**
     * Filter by direct equality comparison (short-hand) of the status property with a supplied value.
     * @type {'approved' | 'pending' | 'rejected' | 'revoked'}
     * @memberof RegistrationsApiListApplicationRegistrations
     */
    readonly filterStatus?: 'approved' | 'pending' | 'rejected' | 'revoked'
}

/**
 * RegistrationsApi - object-oriented interface
 * @export
 * @class RegistrationsApi
 * @extends {BaseAPI}
 */
export class RegistrationsApi extends BaseAPI {
    /**
     * Registers an application for a product.
     * @summary Register an application for a product
     * @param {RegistrationsApiCreateApplicationRegistrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationsApi
     */
    public createApplicationRegistration(requestParameters: RegistrationsApiCreateApplicationRegistrationRequest, options?: AxiosRequestConfig) {
        return RegistrationsApiFp(this.configuration).createApplicationRegistration(requestParameters.applicationId, requestParameters.createRegistrationPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unregister an application for a product version.
     * @summary Delete an application registration
     * @param {RegistrationsApiDeleteApplicationRegistrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationsApi
     */
    public deleteApplicationRegistration(requestParameters: RegistrationsApiDeleteApplicationRegistrationRequest, options?: AxiosRequestConfig) {
        return RegistrationsApiFp(this.configuration).deleteApplicationRegistration(requestParameters.applicationId, requestParameters.registrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the specified product registration for an application.
     * @summary Get an application registration
     * @param {RegistrationsApiGetApplicationRegistrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationsApi
     */
    public getApplicationRegistration(requestParameters: RegistrationsApiGetApplicationRegistrationRequest, options?: AxiosRequestConfig) {
        return RegistrationsApiFp(this.configuration).getApplicationRegistration(requestParameters.applicationId, requestParameters.registrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the granted scopes of a specified product registration directly from the IDP for an application. Will return 409 if this feature is not supported by the application. 
     * @summary Get the granted scopes of an application registration
     * @param {RegistrationsApiGetApplicationRegistrationGrantedScopesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationsApi
     */
    public getApplicationRegistrationGrantedScopes(requestParameters: RegistrationsApiGetApplicationRegistrationGrantedScopesRequest, options?: AxiosRequestConfig) {
        return RegistrationsApiFp(this.configuration).getApplicationRegistrationGrantedScopes(requestParameters.applicationId, requestParameters.registrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists product registrations for an application.
     * @summary Get application registrations
     * @param {RegistrationsApiListApplicationRegistrationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationsApi
     */
    public listApplicationRegistrations(requestParameters: RegistrationsApiListApplicationRegistrationsRequest, options?: AxiosRequestConfig) {
        return RegistrationsApiFp(this.configuration).listApplicationRegistrations(requestParameters.applicationId, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.filterIdEq, requestParameters.filterId, requestParameters.filterStatusEq, requestParameters.filterStatus, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns paginated search results from the specified entities with the given search parameters.
         * @summary Search Portal Entities
         * @param {SearchIndicesParameters} indices Determines which entity sets to search
         * @param {string} [filterAuthStrategyId] Filter by direct equality comparison (short-hand) of the auth_strategy_id property with a supplied value.
         * @param {string} [q] Determines how to filter search results
         * @param {string} [join] Determines which sub-entities to include in search results
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPortalEntities: async (indices: SearchIndicesParameters, filterAuthStrategyId?: string, q?: string, join?: string, pageSize?: number, pageNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indices' is not null or undefined
            assertParamExists('searchPortalEntities', 'indices', indices)
            const localVarPath = `/api/v2/search/{indices}`
                .replace(`{${"indices"}}`, encodeURIComponent(String(indices)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (filterAuthStrategyId !== undefined) {
                localVarQueryParameter['filter[auth_strategy_id]'] = filterAuthStrategyId;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (join !== undefined) {
                localVarQueryParameter['join'] = join;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns paginated search results from the specified entities with the given search parameters.
         * @summary Search Portal Entities
         * @param {SearchIndicesParameters} indices Determines which entity sets to search
         * @param {string} [filterAuthStrategyId] Filter by direct equality comparison (short-hand) of the auth_strategy_id property with a supplied value.
         * @param {string} [q] Determines how to filter search results
         * @param {string} [join] Determines which sub-entities to include in search results
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPortalEntities(indices: SearchIndicesParameters, filterAuthStrategyId?: string, q?: string, join?: string, pageSize?: number, pageNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPortalEntities(indices, filterAuthStrategyId, q, join, pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Returns paginated search results from the specified entities with the given search parameters.
         * @summary Search Portal Entities
         * @param {SearchIndicesParameters} indices Determines which entity sets to search
         * @param {string} [filterAuthStrategyId] Filter by direct equality comparison (short-hand) of the auth_strategy_id property with a supplied value.
         * @param {string} [q] Determines how to filter search results
         * @param {string} [join] Determines which sub-entities to include in search results
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPortalEntities(indices: SearchIndicesParameters, filterAuthStrategyId?: string, q?: string, join?: string, pageSize?: number, pageNumber?: number, options?: any): AxiosPromise<SearchResults> {
            return localVarFp.searchPortalEntities(indices, filterAuthStrategyId, q, join, pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for searchPortalEntities operation in SearchApi.
 * @export
 * @interface SearchApiSearchPortalEntitiesRequest
 */
export interface SearchApiSearchPortalEntitiesRequest {
    /**
     * Determines which entity sets to search
     * @type {SearchIndicesParameters}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly indices: SearchIndicesParameters

    /**
     * Filter by direct equality comparison (short-hand) of the auth_strategy_id property with a supplied value.
     * @type {string}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly filterAuthStrategyId?: string

    /**
     * Determines how to filter search results
     * @type {string}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly q?: string

    /**
     * Determines which sub-entities to include in search results
     * @type {string}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly join?: string

    /**
     * The maximum number of items to include per page. The last page of a collection may include fewer items.
     * @type {number}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly pageSize?: number

    /**
     * Determines which page of the entities to retrieve.
     * @type {number}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly pageNumber?: number
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Returns paginated search results from the specified entities with the given search parameters.
     * @summary Search Portal Entities
     * @param {SearchApiSearchPortalEntitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchPortalEntities(requestParameters: SearchApiSearchPortalEntitiesRequest, options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchPortalEntities(requestParameters.indices, requestParameters.filterAuthStrategyId, requestParameters.q, requestParameters.join, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VersionsApi - axios parameter creator
 * @export
 */
export const VersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get applications that have a registration for a given product version. Any registration for the version will count, regardless of status (i.e. even if it is pending, rejected, or revoked). Use the `unregistered` query param to return the inverse, only including applicatons that do not have a registration (regardless of status).
         * @summary Get applications by product version
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} productVersionId Contains a unique identifier used by the Portal API for this resource.
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatusEq] Filter by direct equality comparison of the status property with a supplied value.
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatus] Filter by direct equality comparison (short-hand) of the status property with a supplied value.
         * @param {boolean} [unregistered] Return applications that do **not** have a registration for the product version (regardless of registration status).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsByProductVersion: async (productId: string, productVersionId: string, pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, filterStatusEq?: 'approved' | 'pending' | 'rejected' | 'revoked', filterStatus?: 'approved' | 'pending' | 'rejected' | 'revoked', unregistered?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getApplicationsByProductVersion', 'productId', productId)
            // verify required parameter 'productVersionId' is not null or undefined
            assertParamExists('getApplicationsByProductVersion', 'productVersionId', productVersionId)
            const localVarPath = `/api/v2/products/{productId}/versions/{productVersionId}/applications`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"productVersionId"}}`, encodeURIComponent(String(productVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (filterNameEq !== undefined) {
                localVarQueryParameter['filter[name][eq]'] = filterNameEq;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterNameContains !== undefined) {
                localVarQueryParameter['filter[name][contains]'] = filterNameContains;
            }

            if (filterStatusEq !== undefined) {
                localVarQueryParameter['filter[status][eq]'] = filterStatusEq;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (unregistered !== undefined) {
                localVarQueryParameter['unregistered'] = unregistered;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the details for an existing product version.
         * @summary Get product version
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} productVersionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersion: async (productId: string, productVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductVersion', 'productId', productId)
            // verify required parameter 'productVersionId' is not null or undefined
            assertParamExists('getProductVersion', 'productVersionId', productVersionId)
            const localVarPath = `/api/v2/products/{productId}/versions/{productVersionId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"productVersionId"}}`, encodeURIComponent(String(productVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the API specification document attached to given product version. Currently only OpenAPI is supported.
         * @summary Get spec for product version
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} productVersionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersionSpec: async (productId: string, productVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductVersionSpec', 'productId', productId)
            // verify required parameter 'productVersionId' is not null or undefined
            assertParamExists('getProductVersionSpec', 'productVersionId', productVersionId)
            const localVarPath = `/api/v2/products/{productId}/versions/{productVersionId}/spec`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"productVersionId"}}`, encodeURIComponent(String(productVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of operations used in the API specification document attached to given product version.
         * @summary Get operations in version spec
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} productVersionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersionSpecOperations: async (productId: string, productVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductVersionSpecOperations', 'productId', productId)
            // verify required parameter 'productVersionId' is not null or undefined
            assertParamExists('getProductVersionSpecOperations', 'productVersionId', productVersionId)
            const localVarPath = `/api/v2/products/{productId}/versions/{productVersionId}/spec/operations`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"productVersionId"}}`, encodeURIComponent(String(productVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paginated list of versions of a given product.
         * @summary Get page of product versions
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductVersions: async (productId: string, pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('listProductVersions', 'productId', productId)
            const localVarPath = `/api/v2/products/{productId}/versions`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (filterNameEq !== undefined) {
                localVarQueryParameter['filter[name][eq]'] = filterNameEq;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterNameContains !== undefined) {
                localVarQueryParameter['filter[name][contains]'] = filterNameContains;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionsApi - functional programming interface
 * @export
 */
export const VersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get applications that have a registration for a given product version. Any registration for the version will count, regardless of status (i.e. even if it is pending, rejected, or revoked). Use the `unregistered` query param to return the inverse, only including applicatons that do not have a registration (regardless of status).
         * @summary Get applications by product version
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} productVersionId Contains a unique identifier used by the Portal API for this resource.
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatusEq] Filter by direct equality comparison of the status property with a supplied value.
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatus] Filter by direct equality comparison (short-hand) of the status property with a supplied value.
         * @param {boolean} [unregistered] Return applications that do **not** have a registration for the product version (regardless of registration status).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationsByProductVersion(productId: string, productVersionId: string, pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, filterStatusEq?: 'approved' | 'pending' | 'rejected' | 'revoked', filterStatus?: 'approved' | 'pending' | 'rejected' | 'revoked', unregistered?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVersionListApplicationsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationsByProductVersion(productId, productVersionId, pageSize, pageNumber, filterNameEq, filterName, filterNameContains, filterStatusEq, filterStatus, unregistered, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the details for an existing product version.
         * @summary Get product version
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} productVersionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductVersion(productId: string, productVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductVersion(productId, productVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the API specification document attached to given product version. Currently only OpenAPI is supported.
         * @summary Get spec for product version
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} productVersionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductVersionSpec(productId: string, productVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVersionSpecDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductVersionSpec(productId, productVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list of operations used in the API specification document attached to given product version.
         * @summary Get operations in version spec
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} productVersionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductVersionSpecOperations(productId: string, productVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVersionSpecOperations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductVersionSpecOperations(productId, productVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns paginated list of versions of a given product.
         * @summary Get page of product versions
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductVersions(productId: string, pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVersionListPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProductVersions(productId, pageSize, pageNumber, filterNameEq, filterName, filterNameContains, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VersionsApi - factory interface
 * @export
 */
export const VersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionsApiFp(configuration)
    return {
        /**
         * Get applications that have a registration for a given product version. Any registration for the version will count, regardless of status (i.e. even if it is pending, rejected, or revoked). Use the `unregistered` query param to return the inverse, only including applicatons that do not have a registration (regardless of status).
         * @summary Get applications by product version
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} productVersionId Contains a unique identifier used by the Portal API for this resource.
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatusEq] Filter by direct equality comparison of the status property with a supplied value.
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatus] Filter by direct equality comparison (short-hand) of the status property with a supplied value.
         * @param {boolean} [unregistered] Return applications that do **not** have a registration for the product version (regardless of registration status).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsByProductVersion(productId: string, productVersionId: string, pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, filterStatusEq?: 'approved' | 'pending' | 'rejected' | 'revoked', filterStatus?: 'approved' | 'pending' | 'rejected' | 'revoked', unregistered?: boolean, options?: any): AxiosPromise<ProductVersionListApplicationsPage> {
            return localVarFp.getApplicationsByProductVersion(productId, productVersionId, pageSize, pageNumber, filterNameEq, filterName, filterNameContains, filterStatusEq, filterStatus, unregistered, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the details for an existing product version.
         * @summary Get product version
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} productVersionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersion(productId: string, productVersionId: string, options?: any): AxiosPromise<ProductVersion> {
            return localVarFp.getProductVersion(productId, productVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the API specification document attached to given product version. Currently only OpenAPI is supported.
         * @summary Get spec for product version
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} productVersionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersionSpec(productId: string, productVersionId: string, options?: any): AxiosPromise<ProductVersionSpecDocument> {
            return localVarFp.getProductVersionSpec(productId, productVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of operations used in the API specification document attached to given product version.
         * @summary Get operations in version spec
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} productVersionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersionSpecOperations(productId: string, productVersionId: string, options?: any): AxiosPromise<ProductVersionSpecOperations> {
            return localVarFp.getProductVersionSpecOperations(productId, productVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns paginated list of versions of a given product.
         * @summary Get page of product versions
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {number} [pageSize] The maximum number of items to include per page. The last page of a collection may include fewer items.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductVersions(productId: string, pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, options?: any): AxiosPromise<ProductVersionListPage> {
            return localVarFp.listProductVersions(productId, pageSize, pageNumber, filterNameEq, filterName, filterNameContains, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getApplicationsByProductVersion operation in VersionsApi.
 * @export
 * @interface VersionsApiGetApplicationsByProductVersionRequest
 */
export interface VersionsApiGetApplicationsByProductVersionRequest {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof VersionsApiGetApplicationsByProductVersion
     */
    readonly productId: string

    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof VersionsApiGetApplicationsByProductVersion
     */
    readonly productVersionId: string

    /**
     * The maximum number of items to include per page. The last page of a collection may include fewer items.
     * @type {number}
     * @memberof VersionsApiGetApplicationsByProductVersion
     */
    readonly pageSize?: number

    /**
     * Determines which page of the entities to retrieve.
     * @type {number}
     * @memberof VersionsApiGetApplicationsByProductVersion
     */
    readonly pageNumber?: number

    /**
     * Filter by direct equality comparison of the name property with a supplied value.
     * @type {string}
     * @memberof VersionsApiGetApplicationsByProductVersion
     */
    readonly filterNameEq?: string

    /**
     * Filter by direct equality comparison (short-hand) of the name property with a supplied value.
     * @type {string}
     * @memberof VersionsApiGetApplicationsByProductVersion
     */
    readonly filterName?: string

    /**
     * Filter by contains comparison of the name property with a supplied substring
     * @type {string}
     * @memberof VersionsApiGetApplicationsByProductVersion
     */
    readonly filterNameContains?: string

    /**
     * Filter by direct equality comparison of the status property with a supplied value.
     * @type {'approved' | 'pending' | 'rejected' | 'revoked'}
     * @memberof VersionsApiGetApplicationsByProductVersion
     */
    readonly filterStatusEq?: 'approved' | 'pending' | 'rejected' | 'revoked'

    /**
     * Filter by direct equality comparison (short-hand) of the status property with a supplied value.
     * @type {'approved' | 'pending' | 'rejected' | 'revoked'}
     * @memberof VersionsApiGetApplicationsByProductVersion
     */
    readonly filterStatus?: 'approved' | 'pending' | 'rejected' | 'revoked'

    /**
     * Return applications that do **not** have a registration for the product version (regardless of registration status).
     * @type {boolean}
     * @memberof VersionsApiGetApplicationsByProductVersion
     */
    readonly unregistered?: boolean
}

/**
 * Request parameters for getProductVersion operation in VersionsApi.
 * @export
 * @interface VersionsApiGetProductVersionRequest
 */
export interface VersionsApiGetProductVersionRequest {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof VersionsApiGetProductVersion
     */
    readonly productId: string

    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof VersionsApiGetProductVersion
     */
    readonly productVersionId: string
}

/**
 * Request parameters for getProductVersionSpec operation in VersionsApi.
 * @export
 * @interface VersionsApiGetProductVersionSpecRequest
 */
export interface VersionsApiGetProductVersionSpecRequest {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof VersionsApiGetProductVersionSpec
     */
    readonly productId: string

    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof VersionsApiGetProductVersionSpec
     */
    readonly productVersionId: string
}

/**
 * Request parameters for getProductVersionSpecOperations operation in VersionsApi.
 * @export
 * @interface VersionsApiGetProductVersionSpecOperationsRequest
 */
export interface VersionsApiGetProductVersionSpecOperationsRequest {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof VersionsApiGetProductVersionSpecOperations
     */
    readonly productId: string

    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof VersionsApiGetProductVersionSpecOperations
     */
    readonly productVersionId: string
}

/**
 * Request parameters for listProductVersions operation in VersionsApi.
 * @export
 * @interface VersionsApiListProductVersionsRequest
 */
export interface VersionsApiListProductVersionsRequest {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof VersionsApiListProductVersions
     */
    readonly productId: string

    /**
     * The maximum number of items to include per page. The last page of a collection may include fewer items.
     * @type {number}
     * @memberof VersionsApiListProductVersions
     */
    readonly pageSize?: number

    /**
     * Determines which page of the entities to retrieve.
     * @type {number}
     * @memberof VersionsApiListProductVersions
     */
    readonly pageNumber?: number

    /**
     * Filter by direct equality comparison of the name property with a supplied value.
     * @type {string}
     * @memberof VersionsApiListProductVersions
     */
    readonly filterNameEq?: string

    /**
     * Filter by direct equality comparison (short-hand) of the name property with a supplied value.
     * @type {string}
     * @memberof VersionsApiListProductVersions
     */
    readonly filterName?: string

    /**
     * Filter by contains comparison of the name property with a supplied substring
     * @type {string}
     * @memberof VersionsApiListProductVersions
     */
    readonly filterNameContains?: string
}

/**
 * VersionsApi - object-oriented interface
 * @export
 * @class VersionsApi
 * @extends {BaseAPI}
 */
export class VersionsApi extends BaseAPI {
    /**
     * Get applications that have a registration for a given product version. Any registration for the version will count, regardless of status (i.e. even if it is pending, rejected, or revoked). Use the `unregistered` query param to return the inverse, only including applicatons that do not have a registration (regardless of status).
     * @summary Get applications by product version
     * @param {VersionsApiGetApplicationsByProductVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getApplicationsByProductVersion(requestParameters: VersionsApiGetApplicationsByProductVersionRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).getApplicationsByProductVersion(requestParameters.productId, requestParameters.productVersionId, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.filterNameEq, requestParameters.filterName, requestParameters.filterNameContains, requestParameters.filterStatusEq, requestParameters.filterStatus, requestParameters.unregistered, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the details for an existing product version.
     * @summary Get product version
     * @param {VersionsApiGetProductVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getProductVersion(requestParameters: VersionsApiGetProductVersionRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).getProductVersion(requestParameters.productId, requestParameters.productVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the API specification document attached to given product version. Currently only OpenAPI is supported.
     * @summary Get spec for product version
     * @param {VersionsApiGetProductVersionSpecRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getProductVersionSpec(requestParameters: VersionsApiGetProductVersionSpecRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).getProductVersionSpec(requestParameters.productId, requestParameters.productVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of operations used in the API specification document attached to given product version.
     * @summary Get operations in version spec
     * @param {VersionsApiGetProductVersionSpecOperationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getProductVersionSpecOperations(requestParameters: VersionsApiGetProductVersionSpecOperationsRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).getProductVersionSpecOperations(requestParameters.productId, requestParameters.productVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paginated list of versions of a given product.
     * @summary Get page of product versions
     * @param {VersionsApiListProductVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public listProductVersions(requestParameters: VersionsApiListProductVersionsRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).listProductVersions(requestParameters.productId, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.filterNameEq, requestParameters.filterName, requestParameters.filterNameContains, options).then((request) => request(this.axios, this.basePath));
    }
}


