/* tslint:disable */
/* eslint-disable */
/**
 * Portal API
 * Portal API
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const AlignmentKind = {
    Left: 'left',
    Right: 'right',
    Center: 'center',
    None: 'none'
} as const;

export type AlignmentKind = typeof AlignmentKind[keyof typeof AlignmentKind];


/**
 * @type AnyNode
 * @export
 */
export type AnyNode = { type: 'blockquote' } & BlockQuoteBlock | { type: 'break' } & BreakBlock | { type: 'code' } & Code | { type: 'code_block' } & CodeBlock | { type: 'document' } & DocumentBlock | { type: 'emphasis' } & Emphasis | { type: 'heading' } & HeadingBlock | { type: 'image' } & Image | { type: 'link' } & Link | { type: 'list' } & ListBlock | { type: 'list_item' } & ListItemBlock | { type: 'paragraph' } & ParagraphBlock | { type: 'strikethrough' } & StrikeThrough | { type: 'table' } & TableBlock | { type: 'table_cell' } & TableCellBlock | { type: 'table_header' } & TableHeaderBlock | { type: 'table_row' } & TableRowBlock | { type: 'task_checkbox' } & TaskCheckbox | { type: 'text' } & Text | { type: 'text_block' } & TextBlock;

/**
 * 
 * @export
 * @enum {string}
 */

export const ApiTypeEnum = {
    Openapi: 'openapi'
} as const;

export type ApiTypeEnum = typeof ApiTypeEnum[keyof typeof ApiTypeEnum];


/**
 * Application creation response payload
 * @export
 * @interface ApplicationCreationResponse
 */
export interface ApplicationCreationResponse {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'name': string;
    /**
     * An identifier to correlate the application with an external system. Cannot be set when using Dynamic Client Registration.
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'reference_id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'redirect_uri'?: string;
    /**
     * 
     * @type {ApplicationCreationResponseCredentials}
     * @memberof ApplicationCreationResponse
     */
    'credentials'?: ApplicationCreationResponseCredentials;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'created_at': string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface ApplicationCreationResponseCredentials
 */
export interface ApplicationCreationResponseCredentials {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponseCredentials
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponseCredentials
     */
    'client_secret': string;
}
/**
 * Application update response payload
 * @export
 * @interface ApplicationUpdateResponse
 */
export interface ApplicationUpdateResponse {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'name': string;
    /**
     * An identifier to correlate the application with an external system. Cannot be set when using Dynamic Client Registration.
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'reference_id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'redirect_uri'?: string;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'created_at': string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'updated_at': string;
}
/**
 * The request schema for the authenticate endpoint.
 * @export
 * @interface AuthenticateRequest
 */
export interface AuthenticateRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthenticateRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticateRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface BadRequestError
 */
export interface BadRequestError {
    /**
     * 
     * @type {any}
     * @memberof BadRequestError
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof BadRequestError
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof BadRequestError
     */
    'type'?: any;
    /**
     * 
     * @type {any}
     * @memberof BadRequestError
     */
    'instance'?: any;
    /**
     * 
     * @type {any}
     * @memberof BadRequestError
     */
    'detail'?: any;
    /**
     * invalid parameters
     * @type {Set<InvalidParameterItem>}
     * @memberof BadRequestError
     */
    'invalid_parameters': Set<InvalidParameterItem>;
}
/**
 * standard error
 * @export
 * @interface BaseError
 */
export interface BaseError {
    /**
     * The HTTP status code of the error. Useful when passing the response body to child properties in a frontend UI. Must be returned as an integer. 
     * @type {number}
     * @memberof BaseError
     */
    'status': number;
    /**
     * A short, human-readable summary of the problem. It should not change between occurences of a problem, except for localization. Should be provided as \"Sentence case\" for direct use in the UI. 
     * @type {string}
     * @memberof BaseError
     */
    'title': string;
    /**
     * The error type.
     * @type {string}
     * @memberof BaseError
     */
    'type'?: string;
    /**
     * Used to return the correlation ID back to the user, in the format kong:trace:<correlation_id>. This helps us find the relevant logs when a customer reports an issue. 
     * @type {string}
     * @memberof BaseError
     */
    'instance': string;
    /**
     * A human readable explanation specific to this occurence of the problem. This field may contain request/entity data to help the user understand what went wrong. Enclose variable values in square brackets. Should be provided as \"Sentence case\" for direct use in the UI. 
     * @type {string}
     * @memberof BaseError
     */
    'detail': string;
}
/**
 * 
 * @export
 * @interface BaseNode
 */
export interface BaseNode {
    /**
     * 
     * @type {string}
     * @memberof BaseNode
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface BlockNode
 */
export interface BlockNode {
    /**
     * 
     * @type {string}
     * @memberof BlockNode
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof BlockNode
     */
    'children'?: Array<AnyNode>;
}
/**
 * 
 * @export
 * @interface BlockNodeAllOf
 */
export interface BlockNodeAllOf {
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof BlockNodeAllOf
     */
    'children'?: Array<AnyNode>;
}
/**
 * 
 * @export
 * @interface BlockQuoteBlock
 */
export interface BlockQuoteBlock {
    /**
     * 
     * @type {string}
     * @memberof BlockQuoteBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof BlockQuoteBlock
     */
    'children'?: Array<AnyNode>;
}
/**
 * 
 * @export
 * @interface BreakBlock
 */
export interface BreakBlock {
    /**
     * 
     * @type {string}
     * @memberof BreakBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof BreakBlock
     */
    'children'?: Array<AnyNode>;
}
/**
 * 
 * @export
 * @interface Code
 */
export interface Code {
    /**
     * 
     * @type {string}
     * @memberof Code
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof Code
     */
    'children'?: Array<AnyNode>;
}
/**
 * 
 * @export
 * @interface CodeBlock
 */
export interface CodeBlock {
    /**
     * 
     * @type {string}
     * @memberof CodeBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof CodeBlock
     */
    'children'?: Array<AnyNode>;
    /**
     * 
     * @type {string}
     * @memberof CodeBlock
     */
    'lang'?: string;
}
/**
 * 
 * @export
 * @interface CodeBlockAllOf
 */
export interface CodeBlockAllOf {
    /**
     * 
     * @type {string}
     * @memberof CodeBlockAllOf
     */
    'lang'?: string;
}
/**
 * 
 * @export
 * @interface ConflictError
 */
export interface ConflictError {
    /**
     * 
     * @type {any}
     * @memberof ConflictError
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof ConflictError
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof ConflictError
     */
    'type'?: any;
    /**
     * 
     * @type {any}
     * @memberof ConflictError
     */
    'instance'?: any;
    /**
     * 
     * @type {any}
     * @memberof ConflictError
     */
    'detail'?: any;
}
/**
 * Application creation payload
 * @export
 * @interface CreateApplicationPayload
 */
export interface CreateApplicationPayload {
    /**
     * The name of the application
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'name': string;
    /**
     * An identifier to correlate the application with an external system. Cannot be set when using Dynamic Client Registration.
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'reference_id'?: string;
    /**
     * URL to redirect to after completing an OIDC auth flow
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'redirect_uri'?: string;
    /**
     * A brief description of the application
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateCredentialPayload
 */
export interface CreateCredentialPayload {
    /**
     * 
     * @type {string}
     * @memberof CreateCredentialPayload
     */
    'display_name'?: string;
}
/**
 * The payload to create a registration.
 * @export
 * @interface CreateRegistrationPayload
 */
export interface CreateRegistrationPayload {
    /**
     * The product version id required for registration.
     * @type {string}
     * @memberof CreateRegistrationPayload
     */
    'product_version_id': string;
}
/**
 * 
 * @export
 * @interface CredentialCreationResponse
 */
export interface CredentialCreationResponse {
    /**
     * 
     * @type {string}
     * @memberof CredentialCreationResponse
     */
    'credential': string;
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof CredentialCreationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CredentialCreationResponse
     */
    'display_name': string;
}
/**
 * A user who can use a developer portal
 * @export
 * @interface Developer
 */
export interface Developer {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof Developer
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Developer
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Developer
     */
    'full_name': string;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof Developer
     */
    'created_at'?: string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof Developer
     */
    'updated_at'?: string;
}
/**
 * content of the document
 * @export
 * @interface DocumentBlock
 */
export interface DocumentBlock {
    /**
     * 
     * @type {string}
     * @memberof DocumentBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof DocumentBlock
     */
    'children'?: Array<AnyNode>;
    /**
     * 
     * @type {string}
     * @memberof DocumentBlock
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface DocumentBlockAllOf
 */
export interface DocumentBlockAllOf {
    /**
     * 
     * @type {string}
     * @memberof DocumentBlockAllOf
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DocumentContentTypeEnum = {
    Json: 'application/json',
    KonnectDocumentTreejson: 'application/konnect.document-tree+json'
} as const;

export type DocumentContentTypeEnum = typeof DocumentContentTypeEnum[keyof typeof DocumentContentTypeEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const DocumentFormatContentTypeEnum = {
    Json: 'application/json',
    KonnectDocumentNodesjson: 'application/konnect.document-nodes+json'
} as const;

export type DocumentFormatContentTypeEnum = typeof DocumentFormatContentTypeEnum[keyof typeof DocumentFormatContentTypeEnum];


/**
 * 
 * @export
 * @interface DocumentItem
 */
export interface DocumentItem {
    /**
     * the id of the document
     * @type {string}
     * @memberof DocumentItem
     */
    'id': string;
    /**
     * the id of the parent document
     * @type {string}
     * @memberof DocumentItem
     */
    'parent_document_id': string | null;
    /**
     * the slug of the document
     * @type {string}
     * @memberof DocumentItem
     */
    'slug': string;
    /**
     * the title of the document
     * @type {string}
     * @memberof DocumentItem
     */
    'title': string;
}
/**
 * a document tree
 * @export
 * @interface DocumentTree
 */
export interface DocumentTree {
    /**
     * 
     * @type {string}
     * @memberof DocumentTree
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentTree
     */
    'parent_document_id'?: string | null;
    /**
     * the title of the document
     * @type {string}
     * @memberof DocumentTree
     */
    'title': string;
    /**
     * the slug of the document
     * @type {string}
     * @memberof DocumentTree
     */
    'slug': string;
    /**
     * the metadata of the document
     * @type {object}
     * @memberof DocumentTree
     */
    'meta': object;
    /**
     * 
     * @type {Array<DocumentTree>}
     * @memberof DocumentTree
     */
    'children': Array<DocumentTree>;
}
/**
 * 
 * @export
 * @interface Emphasis
 */
export interface Emphasis {
    /**
     * 
     * @type {string}
     * @memberof Emphasis
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof Emphasis
     */
    'children'?: Array<AnyNode>;
    /**
     * Level of emphasis 1 - italic 2 - bold 
     * @type {number}
     * @memberof Emphasis
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface EmphasisAllOf
 */
export interface EmphasisAllOf {
    /**
     * Level of emphasis 1 - italic 2 - bold 
     * @type {number}
     * @memberof EmphasisAllOf
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface ForbiddenError
 */
export interface ForbiddenError {
    /**
     * 
     * @type {any}
     * @memberof ForbiddenError
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof ForbiddenError
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof ForbiddenError
     */
    'type'?: any;
    /**
     * 
     * @type {any}
     * @memberof ForbiddenError
     */
    'instance'?: any;
    /**
     * 
     * @type {any}
     * @memberof ForbiddenError
     */
    'detail'?: any;
}
/**
 * 
 * @export
 * @interface GetApplicationResponse
 */
export interface GetApplicationResponse {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'name': string;
    /**
     * An identifier to correlate the application with an external system. Cannot be set when using Dynamic Client Registration.
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'reference_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'redirect_uri'?: string;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'created_at': string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface GetRegistrationResponse
 */
export interface GetRegistrationResponse {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'id': string;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'created_at': string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'updated_at': string;
    /**
     * The approval status of the registration.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'status': GetRegistrationResponseStatusEnum;
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'product_id': string;
    /**
     * The name of the product. This is the name that is displayed in the developer portal.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'product_name': string;
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'product_version_id': string;
    /**
     * The name of the product version. This is the version label that is displayed in the developer portal.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'product_version_name': string;
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'application_id': string;
}

export const GetRegistrationResponseStatusEnum = {
    Approved: 'approved',
    Pending: 'pending',
    Rejected: 'rejected',
    Revoked: 'revoked'
} as const;

export type GetRegistrationResponseStatusEnum = typeof GetRegistrationResponseStatusEnum[keyof typeof GetRegistrationResponseStatusEnum];

/**
 * 
 * @export
 * @interface GoneError
 */
export interface GoneError {
    /**
     * 
     * @type {any}
     * @memberof GoneError
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof GoneError
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof GoneError
     */
    'type'?: any;
    /**
     * 
     * @type {any}
     * @memberof GoneError
     */
    'instance'?: any;
    /**
     * 
     * @type {any}
     * @memberof GoneError
     */
    'detail'?: any;
}
/**
 * 
 * @export
 * @interface HeadingBlock
 */
export interface HeadingBlock {
    /**
     * 
     * @type {string}
     * @memberof HeadingBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof HeadingBlock
     */
    'children'?: Array<AnyNode>;
    /**
     * Level of the heading which maps to HTML <h> tag
     * @type {number}
     * @memberof HeadingBlock
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface HeadingBlockAllOf
 */
export interface HeadingBlockAllOf {
    /**
     * Level of the heading which maps to HTML <h> tag
     * @type {number}
     * @memberof HeadingBlockAllOf
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'type': string;
    /**
     * Url of the image
     * @type {string}
     * @memberof Image
     */
    'url'?: string;
    /**
     * Alternate tag of the image
     * @type {string}
     * @memberof Image
     */
    'alt'?: string;
    /**
     * Title of the image
     * @type {string}
     * @memberof Image
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface ImageAllOf
 */
export interface ImageAllOf {
    /**
     * Url of the image
     * @type {string}
     * @memberof ImageAllOf
     */
    'url'?: string;
    /**
     * Alternate tag of the image
     * @type {string}
     * @memberof ImageAllOf
     */
    'alt'?: string;
    /**
     * Title of the image
     * @type {string}
     * @memberof ImageAllOf
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface InternalError
 */
export interface InternalError {
    /**
     * The HTTP status code of the error. Useful when passing the response body to child properties in a frontend UI. Must be returned as an integer. 
     * @type {number}
     * @memberof InternalError
     */
    'status': number;
    /**
     * A short, human-readable summary of the problem. It should not change between occurences of a problem, except for localization. Should be provided as \"Sentence case\" for direct use in the UI. 
     * @type {string}
     * @memberof InternalError
     */
    'title': string;
    /**
     * The error type.
     * @type {string}
     * @memberof InternalError
     */
    'type'?: string;
    /**
     * Used to return the correlation ID back to the user, in the format kong:trace:<correlation_id>. This helps us find the relevant logs when a customer reports an issue. 
     * @type {string}
     * @memberof InternalError
     */
    'instance': string;
    /**
     * A human readable explanation specific to this occurence of the problem. This field may contain request/entity data to help the user understand what went wrong. Enclose variable values in square brackets. Should be provided as \"Sentence case\" for direct use in the UI. 
     * @type {string}
     * @memberof InternalError
     */
    'detail': string;
}
/**
 * 
 * @export
 * @interface InvalidParameterItem
 */
export interface InvalidParameterItem {
    /**
     * 
     * @type {string}
     * @memberof InvalidParameterItem
     */
    'field': string;
    /**
     * 
     * @type {InvalidRules}
     * @memberof InvalidParameterItem
     */
    'rule'?: InvalidRules | null;
    /**
     * 
     * @type {string}
     * @memberof InvalidParameterItem
     */
    'reason': string;
    /**
     * 
     * @type {Set<any>}
     * @memberof InvalidParameterItem
     */
    'choices'?: Set<any> | null;
}
/**
 * invalid parameters rules
 * @export
 * @enum {string}
 */

export const InvalidRules = {
    Required: 'required',
    Enum: 'enum',
    MinLength: 'min_length',
    MaxLength: 'max_length',
    MinDigits: 'min_digits',
    MinLowercase: 'min_lowercase',
    MinUppercase: 'min_uppercase',
    MinSymbols: 'min_symbols'
} as const;

export type InvalidRules = typeof InvalidRules[keyof typeof InvalidRules];


/**
 * 
 * @export
 * @interface LatestVersion
 */
export interface LatestVersion {
    /**
     * 
     * @type {string}
     * @memberof LatestVersion
     */
    'name'?: string;
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof LatestVersion
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'type': string;
    /**
     * Target url of the link
     * @type {string}
     * @memberof Link
     */
    'href'?: string;
    /**
     * Title of the link
     * @type {string}
     * @memberof Link
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface LinkAllOf
 */
export interface LinkAllOf {
    /**
     * Target url of the link
     * @type {string}
     * @memberof LinkAllOf
     */
    'href'?: string;
    /**
     * Title of the link
     * @type {string}
     * @memberof LinkAllOf
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface ListApplicationsResponse
 */
export interface ListApplicationsResponse {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ListApplicationsResponse
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<GetApplicationResponse>}
     * @memberof ListApplicationsResponse
     */
    'data': Array<GetApplicationResponse>;
}
/**
 * 
 * @export
 * @interface ListBlock
 */
export interface ListBlock {
    /**
     * 
     * @type {string}
     * @memberof ListBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof ListBlock
     */
    'children'?: Array<AnyNode>;
    /**
     * Defines if the list is ordered or not
     * @type {boolean}
     * @memberof ListBlock
     */
    'isOrdered'?: boolean;
}
/**
 * 
 * @export
 * @interface ListBlockAllOf
 */
export interface ListBlockAllOf {
    /**
     * Defines if the list is ordered or not
     * @type {boolean}
     * @memberof ListBlockAllOf
     */
    'isOrdered'?: boolean;
}
/**
 * 
 * @export
 * @interface ListCredentialsResponse
 */
export interface ListCredentialsResponse {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ListCredentialsResponse
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<ListCredentialsResponseDataInner>}
     * @memberof ListCredentialsResponse
     */
    'data': Array<ListCredentialsResponseDataInner>;
}
/**
 * 
 * @export
 * @interface ListCredentialsResponseDataInner
 */
export interface ListCredentialsResponseDataInner {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof ListCredentialsResponseDataInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListCredentialsResponseDataInner
     */
    'display_name': string;
}
/**
 * 
 * @export
 * @interface ListDocuments
 */
export interface ListDocuments {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ListDocuments
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<DocumentItem>}
     * @memberof ListDocuments
     */
    'data': Array<DocumentItem>;
}
/**
 * 
 * @export
 * @interface ListDocumentsTree
 */
export interface ListDocumentsTree {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ListDocumentsTree
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<DocumentTree>}
     * @memberof ListDocumentsTree
     */
    'data': Array<DocumentTree>;
}
/**
 * 
 * @export
 * @interface ListItemBlock
 */
export interface ListItemBlock {
    /**
     * 
     * @type {string}
     * @memberof ListItemBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof ListItemBlock
     */
    'children'?: Array<AnyNode>;
}
/**
 * 
 * @export
 * @interface ListRegistrationsResponse
 */
export interface ListRegistrationsResponse {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ListRegistrationsResponse
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<GetRegistrationResponse>}
     * @memberof ListRegistrationsResponse
     */
    'data': Array<GetRegistrationResponse>;
}
/**
 * 
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
    /**
     * 
     * @type {any}
     * @memberof NotFoundError
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotFoundError
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotFoundError
     */
    'type'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotFoundError
     */
    'instance'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotFoundError
     */
    'detail'?: any;
}
/**
 * Contains pagination query parameters and the total number of objects returned.
 * @export
 * @interface PageMeta
 */
export interface PageMeta {
    /**
     * 
     * @type {number}
     * @memberof PageMeta
     */
    'number': number;
    /**
     * 
     * @type {number}
     * @memberof PageMeta
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof PageMeta
     */
    'total': number;
}
/**
 * returns the pagination information
 * @export
 * @interface PaginatedMeta
 */
export interface PaginatedMeta {
    /**
     * 
     * @type {PageMeta}
     * @memberof PaginatedMeta
     */
    'page': PageMeta;
}
/**
 * 
 * @export
 * @interface ParagraphBlock
 */
export interface ParagraphBlock {
    /**
     * 
     * @type {string}
     * @memberof ParagraphBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof ParagraphBlock
     */
    'children'?: Array<AnyNode>;
}
/**
 * the portal appearance
 * @export
 * @interface PortalAppearance
 */
export interface PortalAppearance {
    /**
     * 
     * @type {PortalAppearanceVariables}
     * @memberof PortalAppearance
     */
    'variables'?: PortalAppearanceVariables;
    /**
     * 
     * @type {PortalAppearanceStylesheets}
     * @memberof PortalAppearance
     */
    'stylesheets'?: PortalAppearanceStylesheets;
}
/**
 * 
 * @export
 * @interface PortalAppearanceStylesheets
 */
export interface PortalAppearanceStylesheets {
    /**
     * 
     * @type {PortalAppearanceStylesheetsGlobal}
     * @memberof PortalAppearanceStylesheets
     */
    'global'?: PortalAppearanceStylesheetsGlobal;
}
/**
 * 
 * @export
 * @interface PortalAppearanceStylesheetsGlobal
 */
export interface PortalAppearanceStylesheetsGlobal {
    /**
     * 
     * @type {PortalAppearanceStylesheetsGlobalMain}
     * @memberof PortalAppearanceStylesheetsGlobal
     */
    'main'?: PortalAppearanceStylesheetsGlobalMain;
}
/**
 * 
 * @export
 * @interface PortalAppearanceStylesheetsGlobalMain
 */
export interface PortalAppearanceStylesheetsGlobalMain {
    /**
     * 
     * @type {object}
     * @memberof PortalAppearanceStylesheetsGlobalMain
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface PortalAppearanceVariables
 */
export interface PortalAppearanceVariables {
    /**
     * 
     * @type {PortalAppearanceVariablesCatalog}
     * @memberof PortalAppearanceVariables
     */
    'catalog'?: PortalAppearanceVariablesCatalog;
}
/**
 * 
 * @export
 * @interface PortalAppearanceVariablesCatalog
 */
export interface PortalAppearanceVariablesCatalog {
    /**
     * 
     * @type {PortalAppearanceVariablesCatalogLogo}
     * @memberof PortalAppearanceVariablesCatalog
     */
    'logo'?: PortalAppearanceVariablesCatalogLogo;
    /**
     * 
     * @type {PortalAppearanceVariablesCatalogLogo}
     * @memberof PortalAppearanceVariablesCatalog
     */
    'cover'?: PortalAppearanceVariablesCatalogLogo;
    /**
     * 
     * @type {PortalAppearanceVariablesCatalogPrimaryHeader}
     * @memberof PortalAppearanceVariablesCatalog
     */
    'primary_header'?: PortalAppearanceVariablesCatalogPrimaryHeader;
    /**
     * 
     * @type {PortalAppearanceVariablesCatalogPrimaryHeader}
     * @memberof PortalAppearanceVariablesCatalog
     */
    'welcome_message'?: PortalAppearanceVariablesCatalogPrimaryHeader;
}
/**
 * 
 * @export
 * @interface PortalAppearanceVariablesCatalogLogo
 */
export interface PortalAppearanceVariablesCatalogLogo {
    /**
     * 
     * @type {string}
     * @memberof PortalAppearanceVariablesCatalogLogo
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface PortalAppearanceVariablesCatalogPrimaryHeader
 */
export interface PortalAppearanceVariablesCatalogPrimaryHeader {
    /**
     * 
     * @type {string}
     * @memberof PortalAppearanceVariablesCatalogPrimaryHeader
     */
    'text'?: string;
}
/**
 * describe the portal execution context
 * @export
 * @interface PortalContext
 */
export interface PortalContext {
    /**
     * 
     * @type {string}
     * @memberof PortalContext
     */
    'portal_id': string;
    /**
     * 
     * @type {string}
     * @memberof PortalContext
     */
    'org_id': string;
    /**
     * 
     * @type {string}
     * @memberof PortalContext
     */
    'featureset_id': string;
    /**
     * Whether the portal can be accessed via email and password
     * @type {boolean}
     * @memberof PortalContext
     */
    'basic_auth_enabled': boolean;
    /**
     * Whether the portal can be accessed via authentication with Single Sign On (SSO) through OpenID Connect (OIDC) from a third-party Identity Provider
     * @type {boolean}
     * @memberof PortalContext
     */
    'oidc_auth_enabled': boolean;
    /**
     * Whether the portal catalog can be accessed by non-authenticated users
     * @type {boolean}
     * @memberof PortalContext
     */
    'is_public': boolean;
    /**
     * Whether the portal is protected with Role-Based Access Control
     * @type {boolean}
     * @memberof PortalContext
     */
    'rbac_enabled': boolean;
    /**
     * The unique identifiers of each available client provider when using Dynamic Client Registration
     * @type {Array<string>}
     * @memberof PortalContext
     */
    'dcr_provider_ids': Array<string>;
    /**
     * Allowed time period for Analytics queries
     * @type {string}
     * @memberof PortalContext
     */
    'allowed_time_period': string;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof Product
     */
    'created_at': string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof Product
     */
    'updated_at': string;
    /**
     * Name of product.
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'description'?: string;
    /**
     * Number of linked documents in documentation.
     * @type {number}
     * @memberof Product
     */
    'document_count'?: number;
    /**
     * Number of published versions.
     * @type {number}
     * @memberof Product
     */
    'version_count'?: number;
    /**
     * 
     * @type {LatestVersion}
     * @memberof Product
     */
    'latest_version'?: LatestVersion | null;
}
/**
 * 
 * @export
 * @interface ProductCatalogIndexSource
 */
export interface ProductCatalogIndexSource {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof ProductCatalogIndexSource
     */
    'id': string;
    /**
     * the name of the product
     * @type {string}
     * @memberof ProductCatalogIndexSource
     */
    'name': string | null;
    /**
     * a description of the product
     * @type {string}
     * @memberof ProductCatalogIndexSource
     */
    'description'?: string;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof ProductCatalogIndexSource
     */
    'created_at': string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof ProductCatalogIndexSource
     */
    'updated_at': string;
    /**
     * Number of product documents available.
     * @type {number}
     * @memberof ProductCatalogIndexSource
     */
    'document_count': number;
    /**
     * Number of product versions.
     * @type {number}
     * @memberof ProductCatalogIndexSource
     */
    'version_count': number;
    /**
     * 
     * @type {ProductCatalogIndexSourceLatestVersion}
     * @memberof ProductCatalogIndexSource
     */
    'latest_version': ProductCatalogIndexSourceLatestVersion;
}
/**
 * Last created version.
 * @export
 * @interface ProductCatalogIndexSourceLatestVersion
 */
export interface ProductCatalogIndexSourceLatestVersion {
    /**
     * Name of product version.
     * @type {string}
     * @memberof ProductCatalogIndexSourceLatestVersion
     */
    'name': string;
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof ProductCatalogIndexSourceLatestVersion
     */
    'id': string;
}
/**
 * A document for a product. This is a document that is not a part of the API specification.
 * @export
 * @interface ProductDocument
 */
export interface ProductDocument {
    /**
     * 
     * @type {string}
     * @memberof ProductDocument
     */
    'id': string;
    /**
     * Contains a unique identifier used by the DocumentHub service for this resource.
     * @type {string}
     * @memberof ProductDocument
     */
    'parent_document_id'?: string | null;
    /**
     * Slug of the document. This is used in the URL to identify the document.
     * @type {string}
     * @memberof ProductDocument
     */
    'slug': string;
    /**
     * 
     * @type {DocumentBlock}
     * @memberof ProductDocument
     */
    'content': DocumentBlock;
    /**
     * Title of the document. This is used in the Portal UI to identify the document.
     * @type {string}
     * @memberof ProductDocument
     */
    'title': string;
}
/**
 * A document for a product. This is a document that is not a part of the API specification.
 * @export
 * @interface ProductDocumentRaw
 */
export interface ProductDocumentRaw {
    /**
     * 
     * @type {string}
     * @memberof ProductDocumentRaw
     */
    'id': string;
    /**
     * Contains a unique identifier used by the DocumentHub service for this resource.
     * @type {string}
     * @memberof ProductDocumentRaw
     */
    'parent_document_id'?: string | null;
    /**
     * Slug of the document. This is used in the URL to identify the document.
     * @type {string}
     * @memberof ProductDocumentRaw
     */
    'slug': string;
    /**
     * Markdown document
     * @type {string}
     * @memberof ProductDocumentRaw
     */
    'content': string;
    /**
     * Title of the document. This is used in the Portal UI to identify the document.
     * @type {string}
     * @memberof ProductDocumentRaw
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ProductListPage
 */
export interface ProductListPage {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ProductListPage
     */
    'meta'?: PaginatedMeta;
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductListPage
     */
    'data'?: Array<Product>;
}
/**
 * 
 * @export
 * @interface ProductVersion
 */
export interface ProductVersion {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof ProductVersion
     */
    'id': string;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     * @type {string}
     * @memberof ProductVersion
     */
    'created_at': string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     * @type {string}
     * @memberof ProductVersion
     */
    'updated_at': string;
    /**
     * Name of product version.
     * @type {string}
     * @memberof ProductVersion
     */
    'name': string;
    /**
     * If true, product version is deprecated.
     * @type {boolean}
     * @memberof ProductVersion
     */
    'deprecated': boolean;
    /**
     * Configurations for how the product version is able to be registered for by applications.
     * @type {Array<ProductVersionRegistrationConfigsInner>}
     * @memberof ProductVersion
     */
    'registration_configs': Array<ProductVersionRegistrationConfigsInner>;
}
/**
 * 
 * @export
 * @interface ProductVersionListPage
 */
export interface ProductVersionListPage {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ProductVersionListPage
     */
    'meta'?: PaginatedMeta;
    /**
     * 
     * @type {Array<ProductVersion>}
     * @memberof ProductVersionListPage
     */
    'data'?: Array<ProductVersion>;
}
/**
 * 
 * @export
 * @interface ProductVersionRegistrationConfigsInner
 */
export interface ProductVersionRegistrationConfigsInner {
    /**
     * 
     * @type {string}
     * @memberof ProductVersionRegistrationConfigsInner
     */
    'name': ProductVersionRegistrationConfigsInnerNameEnum;
}

export const ProductVersionRegistrationConfigsInnerNameEnum = {
    KeyAuth: 'key-auth',
    OpenidConnect: 'openid-connect'
} as const;

export type ProductVersionRegistrationConfigsInnerNameEnum = typeof ProductVersionRegistrationConfigsInnerNameEnum[keyof typeof ProductVersionRegistrationConfigsInnerNameEnum];

/**
 * API specification document for a product version.
 * @export
 * @interface ProductVersionSpec
 */
export interface ProductVersionSpec {
    /**
     * 
     * @type {ApiTypeEnum}
     * @memberof ProductVersionSpec
     */
    'api_type': ApiTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductVersionSpec
     */
    'content': string;
}
/**
 * List of every operation detailed in a product version spec document.
 * @export
 * @interface ProductVersionSpecOperations
 */
export interface ProductVersionSpecOperations {
    /**
     * 
     * @type {ApiTypeEnum}
     * @memberof ProductVersionSpecOperations
     */
    'api_type': ApiTypeEnum;
    /**
     * 
     * @type {Array<ProductVersionSpecOperationsOperationsInner>}
     * @memberof ProductVersionSpecOperations
     */
    'operations': Array<ProductVersionSpecOperationsOperationsInner>;
}
/**
 * 
 * @export
 * @interface ProductVersionSpecOperationsOperationsInner
 */
export interface ProductVersionSpecOperationsOperationsInner {
    /**
     * 
     * @type {string}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'method': ProductVersionSpecOperationsOperationsInnerMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'operation_id': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'summary': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'deprecated': boolean;
}

export const ProductVersionSpecOperationsOperationsInnerMethodEnum = {
    Get: 'get',
    Patch: 'patch',
    Post: 'post',
    Put: 'put',
    Delete: 'delete',
    Options: 'options',
    Connect: 'connect',
    Trace: 'trace'
} as const;

export type ProductVersionSpecOperationsOperationsInnerMethodEnum = typeof ProductVersionSpecOperationsOperationsInnerMethodEnum[keyof typeof ProductVersionSpecOperationsOperationsInnerMethodEnum];

/**
 * Refresh token response
 * @export
 * @interface RefreshTokenResponse
 */
export interface RefreshTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    'client_secret': string;
}
/**
 * Payload required to be sent to register a developer to the portal. 
 * @export
 * @interface RegisterPayload
 */
export interface RegisterPayload {
    /**
     * 
     * @type {string}
     * @memberof RegisterPayload
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterPayload
     */
    'full_name': string;
}
/**
 * Payload required to start the reset password flow 
 * @export
 * @interface ResetPasswordPayload
 */
export interface ResetPasswordPayload {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordPayload
     */
    'email': string;
}
/**
 * The request schema for the reset password endpoint.
 * @export
 * @interface ResetPasswordRequest
 */
export interface ResetPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SearchIndicesParameters = {
    ProductCatalog: 'product-catalog'
} as const;

export type SearchIndicesParameters = typeof SearchIndicesParameters[keyof typeof SearchIndicesParameters];


/**
 * 
 * @export
 * @interface SearchResults
 */
export interface SearchResults {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof SearchResults
     */
    'meta': PaginatedMeta;
    /**
     * The paginated results that matched the search query
     * @type {Array<SearchResultsDataInner>}
     * @memberof SearchResults
     */
    'data': Array<SearchResultsDataInner>;
}
/**
 * 
 * @export
 * @interface SearchResultsDataInner
 */
export interface SearchResultsDataInner {
    /**
     * 
     * @type {SearchIndicesParameters}
     * @memberof SearchResultsDataInner
     */
    'index': SearchIndicesParameters;
    /**
     * 
     * @type {ProductCatalogIndexSource}
     * @memberof SearchResultsDataInner
     */
    'source': ProductCatalogIndexSource;
}
/**
 * 
 * @export
 * @interface StrikeThrough
 */
export interface StrikeThrough {
    /**
     * 
     * @type {string}
     * @memberof StrikeThrough
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface TableAlignments
 */
export interface TableAlignments {
    /**
     * 
     * @type {Array<AlignmentKind>}
     * @memberof TableAlignments
     */
    'alignments': Array<AlignmentKind> | null;
}
/**
 * 
 * @export
 * @interface TableBlock
 */
export interface TableBlock {
    /**
     * 
     * @type {string}
     * @memberof TableBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof TableBlock
     */
    'children'?: Array<AnyNode>;
    /**
     * 
     * @type {Array<AlignmentKind>}
     * @memberof TableBlock
     */
    'alignments': Array<AlignmentKind> | null;
}
/**
 * 
 * @export
 * @interface TableCellBlock
 */
export interface TableCellBlock {
    /**
     * 
     * @type {string}
     * @memberof TableCellBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof TableCellBlock
     */
    'children'?: Array<AnyNode>;
    /**
     * 
     * @type {AlignmentKind}
     * @memberof TableCellBlock
     */
    'alignment'?: AlignmentKind;
}
/**
 * 
 * @export
 * @interface TableCellBlockAllOf
 */
export interface TableCellBlockAllOf {
    /**
     * 
     * @type {AlignmentKind}
     * @memberof TableCellBlockAllOf
     */
    'alignment'?: AlignmentKind;
}
/**
 * 
 * @export
 * @interface TableHeaderBlock
 */
export interface TableHeaderBlock {
    /**
     * 
     * @type {string}
     * @memberof TableHeaderBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof TableHeaderBlock
     */
    'children'?: Array<AnyNode>;
    /**
     * 
     * @type {Array<AlignmentKind>}
     * @memberof TableHeaderBlock
     */
    'alignments': Array<AlignmentKind> | null;
}
/**
 * 
 * @export
 * @interface TableRowBlock
 */
export interface TableRowBlock {
    /**
     * 
     * @type {string}
     * @memberof TableRowBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof TableRowBlock
     */
    'children'?: Array<AnyNode>;
    /**
     * 
     * @type {Array<AlignmentKind>}
     * @memberof TableRowBlock
     */
    'alignments': Array<AlignmentKind> | null;
}
/**
 * 
 * @export
 * @interface TaskCheckbox
 */
export interface TaskCheckbox {
    /**
     * 
     * @type {string}
     * @memberof TaskCheckbox
     */
    'type': string;
    /**
     * State of the checkbox
     * @type {boolean}
     * @memberof TaskCheckbox
     */
    'checked': boolean;
}
/**
 * 
 * @export
 * @interface TaskCheckboxAllOf
 */
export interface TaskCheckboxAllOf {
    /**
     * State of the checkbox
     * @type {boolean}
     * @memberof TaskCheckboxAllOf
     */
    'checked': boolean;
}
/**
 * 
 * @export
 * @interface Text
 */
export interface Text {
    /**
     * 
     * @type {string}
     * @memberof Text
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof Text
     */
    'children'?: Array<AnyNode>;
    /**
     * 
     * @type {string}
     * @memberof Text
     */
    'text'?: string;
    /**
     * If this property is true the end of this block should be a carriage return and not concatenated to the next Text block. 
     * @type {boolean}
     * @memberof Text
     */
    'hardBreak'?: boolean;
    /**
     * If this property is true the end of this block should should be concatenated with a space caracter before the next block. This is the flag showing that the parsed markdown block was at the end of the line. 
     * @type {boolean}
     * @memberof Text
     */
    'softBreak'?: boolean;
}
/**
 * 
 * @export
 * @interface TextAllOf
 */
export interface TextAllOf {
    /**
     * 
     * @type {string}
     * @memberof TextAllOf
     */
    'text'?: string;
    /**
     * If this property is true the end of this block should be a carriage return and not concatenated to the next Text block. 
     * @type {boolean}
     * @memberof TextAllOf
     */
    'hardBreak'?: boolean;
    /**
     * If this property is true the end of this block should should be concatenated with a space caracter before the next block. This is the flag showing that the parsed markdown block was at the end of the line. 
     * @type {boolean}
     * @memberof TextAllOf
     */
    'softBreak'?: boolean;
}
/**
 * 
 * @export
 * @interface TextBlock
 */
export interface TextBlock {
    /**
     * 
     * @type {string}
     * @memberof TextBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof TextBlock
     */
    'children'?: Array<AnyNode>;
}
/**
 * 
 * @export
 * @interface TooManyRequestsError
 */
export interface TooManyRequestsError {
    /**
     * 
     * @type {any}
     * @memberof TooManyRequestsError
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof TooManyRequestsError
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof TooManyRequestsError
     */
    'type'?: any;
    /**
     * 
     * @type {any}
     * @memberof TooManyRequestsError
     */
    'instance'?: any;
    /**
     * 
     * @type {any}
     * @memberof TooManyRequestsError
     */
    'detail'?: any;
}
/**
 * 
 * @export
 * @interface UnauthorizedError
 */
export interface UnauthorizedError {
    /**
     * 
     * @type {any}
     * @memberof UnauthorizedError
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof UnauthorizedError
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof UnauthorizedError
     */
    'type'?: any;
    /**
     * 
     * @type {any}
     * @memberof UnauthorizedError
     */
    'instance'?: any;
    /**
     * 
     * @type {any}
     * @memberof UnauthorizedError
     */
    'detail'?: any;
}
/**
 * Payload required to update an application
 * @export
 * @interface UpdateApplicationPayload
 */
export interface UpdateApplicationPayload {
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationPayload
     */
    'name'?: string;
    /**
     * An identifier to correlate the application with an external system. Cannot be set when using Dynamic Client Registration.
     * @type {string}
     * @memberof UpdateApplicationPayload
     */
    'reference_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationPayload
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationPayload
     */
    'redirect_uri'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCredentialPayload
 */
export interface UpdateCredentialPayload {
    /**
     * 
     * @type {string}
     * @memberof UpdateCredentialPayload
     */
    'display_name': string;
}
/**
 * The request schema for the verify email endpoint.
 * @export
 * @interface VerifyEmailRequest
 */
export interface VerifyEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailRequest
     */
    'token': string;
}
/**
 * The response schema for the verify email endpoint.
 * @export
 * @interface VerifyEmailResponse
 */
export interface VerifyEmailResponse {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailResponse
     */
    'token'?: string;
}

/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Application.
         * @summary Create an Application
         * @param {CreateApplicationPayload} createApplicationPayload Create an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (createApplicationPayload: CreateApplicationPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createApplicationPayload' is not null or undefined
            assertParamExists('createApplication', 'createApplicationPayload', createApplicationPayload)
            const localVarPath = `/api/v2/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApplicationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an application and all of its associated entities (registrations).
         * @summary Delete Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplication', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the details for an existing application. You need only supply the unique application identifier that was returned upon application creation or by the list-applications endpoint.
         * @summary Get an Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplication', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List applications owned by the developer currently logged in.
         * @summary List Applications
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications: async (pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (filterNameEq !== undefined) {
                localVarQueryParameter['filter[name][eq]'] = filterNameEq;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterNameContains !== undefined) {
                localVarQueryParameter['filter[name][contains]'] = filterNameContains;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an application, replacing the object with the new values supplied in the request body.
         * @summary Update Application
         * @param {string} applicationId Id of the targeted application
         * @param {UpdateApplicationPayload} updateApplicationPayload Update an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication: async (applicationId: string, updateApplicationPayload: UpdateApplicationPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateApplication', 'applicationId', applicationId)
            // verify required parameter 'updateApplicationPayload' is not null or undefined
            assertParamExists('updateApplication', 'updateApplicationPayload', updateApplicationPayload)
            const localVarPath = `/api/v2/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateApplicationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new Application.
         * @summary Create an Application
         * @param {CreateApplicationPayload} createApplicationPayload Create an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(createApplicationPayload: CreateApplicationPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCreationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(createApplicationPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an application and all of its associated entities (registrations).
         * @summary Delete Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the details for an existing application. You need only supply the unique application identifier that was returned upon application creation or by the list-applications endpoint.
         * @summary Get an Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List applications owned by the developer currently logged in.
         * @summary List Applications
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplications(pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApplicationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplications(pageSize, pageNumber, filterNameEq, filterName, filterNameContains, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an application, replacing the object with the new values supplied in the request body.
         * @summary Update Application
         * @param {string} applicationId Id of the targeted application
         * @param {UpdateApplicationPayload} updateApplicationPayload Update an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplication(applicationId: string, updateApplicationPayload: UpdateApplicationPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplication(applicationId, updateApplicationPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * Creates a new Application.
         * @summary Create an Application
         * @param {CreateApplicationPayload} createApplicationPayload Create an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(createApplicationPayload: CreateApplicationPayload, options?: any): AxiosPromise<ApplicationCreationResponse> {
            return localVarFp.createApplication(createApplicationPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an application and all of its associated entities (registrations).
         * @summary Delete Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the details for an existing application. You need only supply the unique application identifier that was returned upon application creation or by the list-applications endpoint.
         * @summary Get an Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(applicationId: string, options?: any): AxiosPromise<GetApplicationResponse> {
            return localVarFp.getApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List applications owned by the developer currently logged in.
         * @summary List Applications
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, options?: any): AxiosPromise<ListApplicationsResponse> {
            return localVarFp.listApplications(pageSize, pageNumber, filterNameEq, filterName, filterNameContains, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an application, replacing the object with the new values supplied in the request body.
         * @summary Update Application
         * @param {string} applicationId Id of the targeted application
         * @param {UpdateApplicationPayload} updateApplicationPayload Update an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication(applicationId: string, updateApplicationPayload: UpdateApplicationPayload, options?: any): AxiosPromise<ApplicationUpdateResponse> {
            return localVarFp.updateApplication(applicationId, updateApplicationPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiCreateApplicationRequest
 */
export interface ApplicationsApiCreateApplicationRequest {
    /**
     * Create an application
     * @type {CreateApplicationPayload}
     * @memberof ApplicationsApiCreateApplication
     */
    readonly createApplicationPayload: CreateApplicationPayload
}

/**
 * Request parameters for deleteApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiDeleteApplicationRequest
 */
export interface ApplicationsApiDeleteApplicationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof ApplicationsApiDeleteApplication
     */
    readonly applicationId: string
}

/**
 * Request parameters for getApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiGetApplicationRequest
 */
export interface ApplicationsApiGetApplicationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof ApplicationsApiGetApplication
     */
    readonly applicationId: string
}

/**
 * Request parameters for listApplications operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiListApplicationsRequest
 */
export interface ApplicationsApiListApplicationsRequest {
    /**
     * Determines the size of the page to retrieve.
     * @type {number}
     * @memberof ApplicationsApiListApplications
     */
    readonly pageSize?: number

    /**
     * Determines which page of the entities to retrieve.
     * @type {number}
     * @memberof ApplicationsApiListApplications
     */
    readonly pageNumber?: number

    /**
     * Filter by direct equality comparison of the name property with a supplied value.
     * @type {string}
     * @memberof ApplicationsApiListApplications
     */
    readonly filterNameEq?: string

    /**
     * Filter by direct equality comparison (short-hand) of the name property with a supplied value.
     * @type {string}
     * @memberof ApplicationsApiListApplications
     */
    readonly filterName?: string

    /**
     * Filter by contains comparison of the name property with a supplied substring
     * @type {string}
     * @memberof ApplicationsApiListApplications
     */
    readonly filterNameContains?: string
}

/**
 * Request parameters for updateApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiUpdateApplicationRequest
 */
export interface ApplicationsApiUpdateApplicationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof ApplicationsApiUpdateApplication
     */
    readonly applicationId: string

    /**
     * Update an application
     * @type {UpdateApplicationPayload}
     * @memberof ApplicationsApiUpdateApplication
     */
    readonly updateApplicationPayload: UpdateApplicationPayload
}

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * Creates a new Application.
     * @summary Create an Application
     * @param {ApplicationsApiCreateApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public createApplication(requestParameters: ApplicationsApiCreateApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).createApplication(requestParameters.createApplicationPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an application and all of its associated entities (registrations).
     * @summary Delete Application
     * @param {ApplicationsApiDeleteApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public deleteApplication(requestParameters: ApplicationsApiDeleteApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).deleteApplication(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the details for an existing application. You need only supply the unique application identifier that was returned upon application creation or by the list-applications endpoint.
     * @summary Get an Application
     * @param {ApplicationsApiGetApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getApplication(requestParameters: ApplicationsApiGetApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getApplication(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List applications owned by the developer currently logged in.
     * @summary List Applications
     * @param {ApplicationsApiListApplicationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplications(requestParameters: ApplicationsApiListApplicationsRequest = {}, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplications(requestParameters.pageSize, requestParameters.pageNumber, requestParameters.filterNameEq, requestParameters.filterName, requestParameters.filterNameContains, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an application, replacing the object with the new values supplied in the request body.
     * @summary Update Application
     * @param {ApplicationsApiUpdateApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public updateApplication(requestParameters: ApplicationsApiUpdateApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).updateApplication(requestParameters.applicationId, requestParameters.updateApplicationPayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CredentialsApi - axios parameter creator
 * @export
 */
export const CredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows a developer to create a credential for an application they own.
         * @summary Create Credential for Application
         * @param {string} applicationId Id of the targeted application
         * @param {CreateCredentialPayload} [createCredentialPayload] Create a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredential: async (applicationId: string, createCredentialPayload?: CreateCredentialPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createCredential', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/credentials`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCredentialPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a credential for an application they own.
         * @summary Delete Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential: async (applicationId: string, credentialId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteCredential', 'applicationId', applicationId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('deleteCredential', 'credentialId', credentialId)
            const localVarPath = `/api/v2/applications/{applicationId}/credentials/{credentialId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the credentials for an application they own.
         * @summary List credentials
         * @param {string} applicationId Id of the targeted application
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials: async (applicationId: string, pageSize?: number, pageNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listCredentials', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/credentials`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the client secret for an application.
         * @summary Refresh Client Secret
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshApplicationToken: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('refreshApplicationToken', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/refresh-token`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a credential for an application owned by the current logged in developer.
         * @summary Update Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {UpdateCredentialPayload} updateCredentialPayload Update a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential: async (applicationId: string, credentialId: string, updateCredentialPayload: UpdateCredentialPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateCredential', 'applicationId', applicationId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('updateCredential', 'credentialId', credentialId)
            // verify required parameter 'updateCredentialPayload' is not null or undefined
            assertParamExists('updateCredential', 'updateCredentialPayload', updateCredentialPayload)
            const localVarPath = `/api/v2/applications/{applicationId}/credentials/{credentialId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCredentialPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CredentialsApi - functional programming interface
 * @export
 */
export const CredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows a developer to create a credential for an application they own.
         * @summary Create Credential for Application
         * @param {string} applicationId Id of the targeted application
         * @param {CreateCredentialPayload} [createCredentialPayload] Create a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredential(applicationId: string, createCredentialPayload?: CreateCredentialPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialCreationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredential(applicationId, createCredentialPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a credential for an application they own.
         * @summary Delete Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCredential(applicationId: string, credentialId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCredential(applicationId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the credentials for an application they own.
         * @summary List credentials
         * @param {string} applicationId Id of the targeted application
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCredentials(applicationId: string, pageSize?: number, pageNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCredentialsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredentials(applicationId, pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resets the client secret for an application.
         * @summary Refresh Client Secret
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshApplicationToken(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshApplicationToken(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a credential for an application owned by the current logged in developer.
         * @summary Update Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {UpdateCredentialPayload} updateCredentialPayload Update a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCredential(applicationId: string, credentialId: string, updateCredentialPayload: UpdateCredentialPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCredential(applicationId, credentialId, updateCredentialPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CredentialsApi - factory interface
 * @export
 */
export const CredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CredentialsApiFp(configuration)
    return {
        /**
         * Allows a developer to create a credential for an application they own.
         * @summary Create Credential for Application
         * @param {string} applicationId Id of the targeted application
         * @param {CreateCredentialPayload} [createCredentialPayload] Create a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredential(applicationId: string, createCredentialPayload?: CreateCredentialPayload, options?: any): AxiosPromise<CredentialCreationResponse> {
            return localVarFp.createCredential(applicationId, createCredentialPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a credential for an application they own.
         * @summary Delete Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(applicationId: string, credentialId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCredential(applicationId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the credentials for an application they own.
         * @summary List credentials
         * @param {string} applicationId Id of the targeted application
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(applicationId: string, pageSize?: number, pageNumber?: number, options?: any): AxiosPromise<ListCredentialsResponse> {
            return localVarFp.listCredentials(applicationId, pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the client secret for an application.
         * @summary Refresh Client Secret
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshApplicationToken(applicationId: string, options?: any): AxiosPromise<RefreshTokenResponse> {
            return localVarFp.refreshApplicationToken(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a credential for an application owned by the current logged in developer.
         * @summary Update Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {UpdateCredentialPayload} updateCredentialPayload Update a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(applicationId: string, credentialId: string, updateCredentialPayload: UpdateCredentialPayload, options?: any): AxiosPromise<void> {
            return localVarFp.updateCredential(applicationId, credentialId, updateCredentialPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCredential operation in CredentialsApi.
 * @export
 * @interface CredentialsApiCreateCredentialRequest
 */
export interface CredentialsApiCreateCredentialRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiCreateCredential
     */
    readonly applicationId: string

    /**
     * Create a credential
     * @type {CreateCredentialPayload}
     * @memberof CredentialsApiCreateCredential
     */
    readonly createCredentialPayload?: CreateCredentialPayload
}

/**
 * Request parameters for deleteCredential operation in CredentialsApi.
 * @export
 * @interface CredentialsApiDeleteCredentialRequest
 */
export interface CredentialsApiDeleteCredentialRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiDeleteCredential
     */
    readonly applicationId: string

    /**
     * Id of the targeted credential
     * @type {string}
     * @memberof CredentialsApiDeleteCredential
     */
    readonly credentialId: string
}

/**
 * Request parameters for listCredentials operation in CredentialsApi.
 * @export
 * @interface CredentialsApiListCredentialsRequest
 */
export interface CredentialsApiListCredentialsRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiListCredentials
     */
    readonly applicationId: string

    /**
     * Determines the size of the page to retrieve.
     * @type {number}
     * @memberof CredentialsApiListCredentials
     */
    readonly pageSize?: number

    /**
     * Determines which page of the entities to retrieve.
     * @type {number}
     * @memberof CredentialsApiListCredentials
     */
    readonly pageNumber?: number
}

/**
 * Request parameters for refreshApplicationToken operation in CredentialsApi.
 * @export
 * @interface CredentialsApiRefreshApplicationTokenRequest
 */
export interface CredentialsApiRefreshApplicationTokenRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiRefreshApplicationToken
     */
    readonly applicationId: string
}

/**
 * Request parameters for updateCredential operation in CredentialsApi.
 * @export
 * @interface CredentialsApiUpdateCredentialRequest
 */
export interface CredentialsApiUpdateCredentialRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiUpdateCredential
     */
    readonly applicationId: string

    /**
     * Id of the targeted credential
     * @type {string}
     * @memberof CredentialsApiUpdateCredential
     */
    readonly credentialId: string

    /**
     * Update a credential
     * @type {UpdateCredentialPayload}
     * @memberof CredentialsApiUpdateCredential
     */
    readonly updateCredentialPayload: UpdateCredentialPayload
}

/**
 * CredentialsApi - object-oriented interface
 * @export
 * @class CredentialsApi
 * @extends {BaseAPI}
 */
export class CredentialsApi extends BaseAPI {
    /**
     * Allows a developer to create a credential for an application they own.
     * @summary Create Credential for Application
     * @param {CredentialsApiCreateCredentialRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public createCredential(requestParameters: CredentialsApiCreateCredentialRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).createCredential(requestParameters.applicationId, requestParameters.createCredentialPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a credential for an application they own.
     * @summary Delete Credential
     * @param {CredentialsApiDeleteCredentialRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public deleteCredential(requestParameters: CredentialsApiDeleteCredentialRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).deleteCredential(requestParameters.applicationId, requestParameters.credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the credentials for an application they own.
     * @summary List credentials
     * @param {CredentialsApiListCredentialsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public listCredentials(requestParameters: CredentialsApiListCredentialsRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).listCredentials(requestParameters.applicationId, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the client secret for an application.
     * @summary Refresh Client Secret
     * @param {CredentialsApiRefreshApplicationTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public refreshApplicationToken(requestParameters: CredentialsApiRefreshApplicationTokenRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).refreshApplicationToken(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a credential for an application owned by the current logged in developer.
     * @summary Update Credential
     * @param {CredentialsApiUpdateCredentialRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public updateCredential(requestParameters: CredentialsApiUpdateCredentialRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).updateCredential(requestParameters.applicationId, requestParameters.credentialId, requestParameters.updateCredentialPayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeveloperApi - axios parameter creator
 * @export
 */
export const DeveloperApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Starts the password reset flow for the desired account. An email will be sent to the email address to initiate the password reset flow. 
         * @summary Forgot Password
         * @param {ResetPasswordPayload} [resetPasswordPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (resetPasswordPayload?: ResetPasswordPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/developer/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns info about the current developer.
         * @summary Retrieve My Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperMe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/developer/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register to the developer portal.
         * @summary Register
         * @param {RegisterPayload} [registerPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerPayload?: RegisterPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/developer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeveloperApi - functional programming interface
 * @export
 */
export const DeveloperApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeveloperApiAxiosParamCreator(configuration)
    return {
        /**
         * Starts the password reset flow for the desired account. An email will be sent to the email address to initiate the password reset flow. 
         * @summary Forgot Password
         * @param {ResetPasswordPayload} [resetPasswordPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(resetPasswordPayload?: ResetPasswordPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(resetPasswordPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns info about the current developer.
         * @summary Retrieve My Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeveloperMe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Developer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeveloperMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register to the developer portal.
         * @summary Register
         * @param {RegisterPayload} [registerPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerPayload?: RegisterPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeveloperApi - factory interface
 * @export
 */
export const DeveloperApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeveloperApiFp(configuration)
    return {
        /**
         * Starts the password reset flow for the desired account. An email will be sent to the email address to initiate the password reset flow. 
         * @summary Forgot Password
         * @param {ResetPasswordPayload} [resetPasswordPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(resetPasswordPayload?: ResetPasswordPayload, options?: any): AxiosPromise<void> {
            return localVarFp.forgotPassword(resetPasswordPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns info about the current developer.
         * @summary Retrieve My Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperMe(options?: any): AxiosPromise<Developer> {
            return localVarFp.getDeveloperMe(options).then((request) => request(axios, basePath));
        },
        /**
         * Register to the developer portal.
         * @summary Register
         * @param {RegisterPayload} [registerPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerPayload?: RegisterPayload, options?: any): AxiosPromise<void> {
            return localVarFp.register(registerPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for forgotPassword operation in DeveloperApi.
 * @export
 * @interface DeveloperApiForgotPasswordRequest
 */
export interface DeveloperApiForgotPasswordRequest {
    /**
     * Developer registration
     * @type {ResetPasswordPayload}
     * @memberof DeveloperApiForgotPassword
     */
    readonly resetPasswordPayload?: ResetPasswordPayload
}

/**
 * Request parameters for register operation in DeveloperApi.
 * @export
 * @interface DeveloperApiRegisterRequest
 */
export interface DeveloperApiRegisterRequest {
    /**
     * Developer registration
     * @type {RegisterPayload}
     * @memberof DeveloperApiRegister
     */
    readonly registerPayload?: RegisterPayload
}

/**
 * DeveloperApi - object-oriented interface
 * @export
 * @class DeveloperApi
 * @extends {BaseAPI}
 */
export class DeveloperApi extends BaseAPI {
    /**
     * Starts the password reset flow for the desired account. An email will be sent to the email address to initiate the password reset flow. 
     * @summary Forgot Password
     * @param {DeveloperApiForgotPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperApi
     */
    public forgotPassword(requestParameters: DeveloperApiForgotPasswordRequest = {}, options?: AxiosRequestConfig) {
        return DeveloperApiFp(this.configuration).forgotPassword(requestParameters.resetPasswordPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns info about the current developer.
     * @summary Retrieve My Account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperApi
     */
    public getDeveloperMe(options?: AxiosRequestConfig) {
        return DeveloperApiFp(this.configuration).getDeveloperMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register to the developer portal.
     * @summary Register
     * @param {DeveloperApiRegisterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperApi
     */
    public register(requestParameters: DeveloperApiRegisterRequest = {}, options?: AxiosRequestConfig) {
        return DeveloperApiFp(this.configuration).register(requestParameters.registerPayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentationApi - axios parameter creator
 * @export
 */
export const DocumentationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the specified document from the product\'s document tree.
         * @summary Get one product document
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} documentId Contains a unique identifier used by the Portal API for this resource.
         * @param {DocumentFormatContentTypeEnum} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductDocument: async (productId: string, documentId: string, accept?: DocumentFormatContentTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductDocument', 'productId', productId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getProductDocument', 'documentId', documentId)
            const localVarPath = `/api/v2/products/{productId}/documents/{documentId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (accept != null) {
                localVarHeaderParameter['Accept'] = typeof accept === 'string' 
                    ? accept 
                    : JSON.stringify(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of documents that are associated with a given product. The list is paginated, and is in either a list or tree format (based on the Accept header).
         * @summary List product documents
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {DocumentContentTypeEnum} [accept] 
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductDocuments: async (productId: string, accept?: DocumentContentTypeEnum, pageSize?: number, pageNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('listProductDocuments', 'productId', productId)
            const localVarPath = `/api/v2/products/{productId}/documents`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (accept != null) {
                localVarHeaderParameter['Accept'] = typeof accept === 'string' 
                    ? accept 
                    : JSON.stringify(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentationApi - functional programming interface
 * @export
 */
export const DocumentationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentationApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the specified document from the product\'s document tree.
         * @summary Get one product document
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} documentId Contains a unique identifier used by the Portal API for this resource.
         * @param {DocumentFormatContentTypeEnum} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductDocument(productId: string, documentId: string, accept?: DocumentFormatContentTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDocumentRaw>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductDocument(productId, documentId, accept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of documents that are associated with a given product. The list is paginated, and is in either a list or tree format (based on the Accept header).
         * @summary List product documents
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {DocumentContentTypeEnum} [accept] 
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductDocuments(productId: string, accept?: DocumentContentTypeEnum, pageSize?: number, pageNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDocuments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProductDocuments(productId, accept, pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentationApi - factory interface
 * @export
 */
export const DocumentationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentationApiFp(configuration)
    return {
        /**
         * Returns the specified document from the product\'s document tree.
         * @summary Get one product document
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} documentId Contains a unique identifier used by the Portal API for this resource.
         * @param {DocumentFormatContentTypeEnum} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductDocument(productId: string, documentId: string, accept?: DocumentFormatContentTypeEnum, options?: any): AxiosPromise<ProductDocumentRaw> {
            return localVarFp.getProductDocument(productId, documentId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of documents that are associated with a given product. The list is paginated, and is in either a list or tree format (based on the Accept header).
         * @summary List product documents
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {DocumentContentTypeEnum} [accept] 
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductDocuments(productId: string, accept?: DocumentContentTypeEnum, pageSize?: number, pageNumber?: number, options?: any): AxiosPromise<ListDocuments> {
            return localVarFp.listProductDocuments(productId, accept, pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getProductDocument operation in DocumentationApi.
 * @export
 * @interface DocumentationApiGetProductDocumentRequest
 */
export interface DocumentationApiGetProductDocumentRequest {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof DocumentationApiGetProductDocument
     */
    readonly productId: string

    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof DocumentationApiGetProductDocument
     */
    readonly documentId: string

    /**
     * 
     * @type {DocumentFormatContentTypeEnum}
     * @memberof DocumentationApiGetProductDocument
     */
    readonly accept?: DocumentFormatContentTypeEnum
}

/**
 * Request parameters for listProductDocuments operation in DocumentationApi.
 * @export
 * @interface DocumentationApiListProductDocumentsRequest
 */
export interface DocumentationApiListProductDocumentsRequest {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof DocumentationApiListProductDocuments
     */
    readonly productId: string

    /**
     * 
     * @type {DocumentContentTypeEnum}
     * @memberof DocumentationApiListProductDocuments
     */
    readonly accept?: DocumentContentTypeEnum

    /**
     * Determines the size of the page to retrieve.
     * @type {number}
     * @memberof DocumentationApiListProductDocuments
     */
    readonly pageSize?: number

    /**
     * Determines which page of the entities to retrieve.
     * @type {number}
     * @memberof DocumentationApiListProductDocuments
     */
    readonly pageNumber?: number
}

/**
 * DocumentationApi - object-oriented interface
 * @export
 * @class DocumentationApi
 * @extends {BaseAPI}
 */
export class DocumentationApi extends BaseAPI {
    /**
     * Returns the specified document from the product\'s document tree.
     * @summary Get one product document
     * @param {DocumentationApiGetProductDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentationApi
     */
    public getProductDocument(requestParameters: DocumentationApiGetProductDocumentRequest, options?: AxiosRequestConfig) {
        return DocumentationApiFp(this.configuration).getProductDocument(requestParameters.productId, requestParameters.documentId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of documents that are associated with a given product. The list is paginated, and is in either a list or tree format (based on the Accept header).
     * @summary List product documents
     * @param {DocumentationApiListProductDocumentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentationApi
     */
    public listProductDocuments(requestParameters: DocumentationApiListProductDocumentsRequest, options?: AxiosRequestConfig) {
        return DocumentationApiFp(this.configuration).listProductDocuments(requestParameters.productId, requestParameters.accept, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PortalApi - axios parameter creator
 * @export
 */
export const PortalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets appearance configuration object for the portal. This object is set in Konnect.
         * @summary Portal Appearance Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalAppearance: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/portal/appearance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets cover banner for the developer portal. This object is set in Konnect.
         * @summary Portal Catalog Cover Banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalCatalogCover: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/portal/catalog-cover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the portal context object.
         * @summary Get portal context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalContext: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/portal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets logo of the developer portal. This object is set in Konnect.
         * @summary Portal Logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalLogo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/portal/logo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortalApi - functional programming interface
 * @export
 */
export const PortalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortalApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets appearance configuration object for the portal. This object is set in Konnect.
         * @summary Portal Appearance Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalAppearance(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortalAppearance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalAppearance(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets cover banner for the developer portal. This object is set in Konnect.
         * @summary Portal Catalog Cover Banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalCatalogCover(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalCatalogCover(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return the portal context object.
         * @summary Get portal context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalContext(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortalContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalContext(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets logo of the developer portal. This object is set in Konnect.
         * @summary Portal Logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalLogo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalLogo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PortalApi - factory interface
 * @export
 */
export const PortalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortalApiFp(configuration)
    return {
        /**
         * Gets appearance configuration object for the portal. This object is set in Konnect.
         * @summary Portal Appearance Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalAppearance(options?: any): AxiosPromise<PortalAppearance> {
            return localVarFp.getPortalAppearance(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets cover banner for the developer portal. This object is set in Konnect.
         * @summary Portal Catalog Cover Banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalCatalogCover(options?: any): AxiosPromise<File> {
            return localVarFp.getPortalCatalogCover(options).then((request) => request(axios, basePath));
        },
        /**
         * Return the portal context object.
         * @summary Get portal context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalContext(options?: any): AxiosPromise<PortalContext> {
            return localVarFp.getPortalContext(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets logo of the developer portal. This object is set in Konnect.
         * @summary Portal Logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalLogo(options?: any): AxiosPromise<File> {
            return localVarFp.getPortalLogo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortalApi - object-oriented interface
 * @export
 * @class PortalApi
 * @extends {BaseAPI}
 */
export class PortalApi extends BaseAPI {
    /**
     * Gets appearance configuration object for the portal. This object is set in Konnect.
     * @summary Portal Appearance Details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalApi
     */
    public getPortalAppearance(options?: AxiosRequestConfig) {
        return PortalApiFp(this.configuration).getPortalAppearance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets cover banner for the developer portal. This object is set in Konnect.
     * @summary Portal Catalog Cover Banner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalApi
     */
    public getPortalCatalogCover(options?: AxiosRequestConfig) {
        return PortalApiFp(this.configuration).getPortalCatalogCover(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the portal context object.
     * @summary Get portal context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalApi
     */
    public getPortalContext(options?: AxiosRequestConfig) {
        return PortalApiFp(this.configuration).getPortalContext(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets logo of the developer portal. This object is set in Konnect.
     * @summary Portal Logo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalApi
     */
    public getPortalLogo(options?: AxiosRequestConfig) {
        return PortalApiFp(this.configuration).getPortalLogo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the details for an existing published product.
         * @summary Get a product
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (productId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProduct', 'productId', productId)
            const localVarPath = `/api/v2/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of published API Products.
         * @summary List Products
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {string} [filterDescriptionEq] Filter by direct equality comparison of the description property with a supplied value.
         * @param {string} [filterDescription] Filter by direct equality comparison (short-hand) of the description property with a supplied value.
         * @param {string} [filterDescriptionContains] Filter by contains comparison of the description property with a supplied substring
         * @param {string} [filterIdEq] Filter by direct equality comparison of the id property with a supplied value.
         * @param {string} [filterId] Filter by direct equality comparison (short-hand) of the id property with a supplied value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts: async (pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, filterDescriptionEq?: string, filterDescription?: string, filterDescriptionContains?: string, filterIdEq?: string, filterId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (filterNameEq !== undefined) {
                localVarQueryParameter['filter[name][eq]'] = filterNameEq;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterNameContains !== undefined) {
                localVarQueryParameter['filter[name][contains]'] = filterNameContains;
            }

            if (filterDescriptionEq !== undefined) {
                localVarQueryParameter['filter[description][eq]'] = filterDescriptionEq;
            }

            if (filterDescription !== undefined) {
                localVarQueryParameter['filter[description]'] = filterDescription;
            }

            if (filterDescriptionContains !== undefined) {
                localVarQueryParameter['filter[description][contains]'] = filterDescriptionContains;
            }

            if (filterIdEq !== undefined) {
                localVarQueryParameter['filter[id][eq]'] = filterIdEq;
            }

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets the details for an existing published product.
         * @summary Get a product
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(productId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a paginated list of published API Products.
         * @summary List Products
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {string} [filterDescriptionEq] Filter by direct equality comparison of the description property with a supplied value.
         * @param {string} [filterDescription] Filter by direct equality comparison (short-hand) of the description property with a supplied value.
         * @param {string} [filterDescriptionContains] Filter by contains comparison of the description property with a supplied substring
         * @param {string} [filterIdEq] Filter by direct equality comparison of the id property with a supplied value.
         * @param {string} [filterId] Filter by direct equality comparison (short-hand) of the id property with a supplied value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProducts(pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, filterDescriptionEq?: string, filterDescription?: string, filterDescriptionContains?: string, filterIdEq?: string, filterId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductListPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProducts(pageSize, pageNumber, filterNameEq, filterName, filterNameContains, filterDescriptionEq, filterDescription, filterDescriptionContains, filterIdEq, filterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * Gets the details for an existing published product.
         * @summary Get a product
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(productId: string, options?: any): AxiosPromise<Product> {
            return localVarFp.getProduct(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of published API Products.
         * @summary List Products
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {string} [filterDescriptionEq] Filter by direct equality comparison of the description property with a supplied value.
         * @param {string} [filterDescription] Filter by direct equality comparison (short-hand) of the description property with a supplied value.
         * @param {string} [filterDescriptionContains] Filter by contains comparison of the description property with a supplied substring
         * @param {string} [filterIdEq] Filter by direct equality comparison of the id property with a supplied value.
         * @param {string} [filterId] Filter by direct equality comparison (short-hand) of the id property with a supplied value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, filterDescriptionEq?: string, filterDescription?: string, filterDescriptionContains?: string, filterIdEq?: string, filterId?: string, options?: any): AxiosPromise<ProductListPage> {
            return localVarFp.listProducts(pageSize, pageNumber, filterNameEq, filterName, filterNameContains, filterDescriptionEq, filterDescription, filterDescriptionContains, filterIdEq, filterId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getProduct operation in ProductsApi.
 * @export
 * @interface ProductsApiGetProductRequest
 */
export interface ProductsApiGetProductRequest {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof ProductsApiGetProduct
     */
    readonly productId: string
}

/**
 * Request parameters for listProducts operation in ProductsApi.
 * @export
 * @interface ProductsApiListProductsRequest
 */
export interface ProductsApiListProductsRequest {
    /**
     * Determines the size of the page to retrieve.
     * @type {number}
     * @memberof ProductsApiListProducts
     */
    readonly pageSize?: number

    /**
     * Determines which page of the entities to retrieve.
     * @type {number}
     * @memberof ProductsApiListProducts
     */
    readonly pageNumber?: number

    /**
     * Filter by direct equality comparison of the name property with a supplied value.
     * @type {string}
     * @memberof ProductsApiListProducts
     */
    readonly filterNameEq?: string

    /**
     * Filter by direct equality comparison (short-hand) of the name property with a supplied value.
     * @type {string}
     * @memberof ProductsApiListProducts
     */
    readonly filterName?: string

    /**
     * Filter by contains comparison of the name property with a supplied substring
     * @type {string}
     * @memberof ProductsApiListProducts
     */
    readonly filterNameContains?: string

    /**
     * Filter by direct equality comparison of the description property with a supplied value.
     * @type {string}
     * @memberof ProductsApiListProducts
     */
    readonly filterDescriptionEq?: string

    /**
     * Filter by direct equality comparison (short-hand) of the description property with a supplied value.
     * @type {string}
     * @memberof ProductsApiListProducts
     */
    readonly filterDescription?: string

    /**
     * Filter by contains comparison of the description property with a supplied substring
     * @type {string}
     * @memberof ProductsApiListProducts
     */
    readonly filterDescriptionContains?: string

    /**
     * Filter by direct equality comparison of the id property with a supplied value.
     * @type {string}
     * @memberof ProductsApiListProducts
     */
    readonly filterIdEq?: string

    /**
     * Filter by direct equality comparison (short-hand) of the id property with a supplied value.
     * @type {string}
     * @memberof ProductsApiListProducts
     */
    readonly filterId?: string
}

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Gets the details for an existing published product.
     * @summary Get a product
     * @param {ProductsApiGetProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProduct(requestParameters: ProductsApiGetProductRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProduct(requestParameters.productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of published API Products.
     * @summary List Products
     * @param {ProductsApiListProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listProducts(requestParameters: ProductsApiListProductsRequest = {}, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).listProducts(requestParameters.pageSize, requestParameters.pageNumber, requestParameters.filterNameEq, requestParameters.filterName, requestParameters.filterNameContains, requestParameters.filterDescriptionEq, requestParameters.filterDescription, requestParameters.filterDescriptionContains, requestParameters.filterIdEq, requestParameters.filterId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegistrationsApi - axios parameter creator
 * @export
 */
export const RegistrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Registers an application for a product.
         * @summary Register an application for a product
         * @param {string} applicationId Id of the targeted application
         * @param {CreateRegistrationPayload} createRegistrationPayload Create an application registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationRegistration: async (applicationId: string, createRegistrationPayload: CreateRegistrationPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationRegistration', 'applicationId', applicationId)
            // verify required parameter 'createRegistrationPayload' is not null or undefined
            assertParamExists('createApplicationRegistration', 'createRegistrationPayload', createRegistrationPayload)
            const localVarPath = `/api/v2/applications/{applicationId}/registrations`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRegistrationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unregister an application for a product version.
         * @summary Delete an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationRegistration: async (applicationId: string, registrationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationRegistration', 'applicationId', applicationId)
            // verify required parameter 'registrationId' is not null or undefined
            assertParamExists('deleteApplicationRegistration', 'registrationId', registrationId)
            const localVarPath = `/api/v2/applications/{applicationId}/registrations/{registrationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"registrationId"}}`, encodeURIComponent(String(registrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the specified product registration for an application.
         * @summary Get an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationRegistration: async (applicationId: string, registrationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationRegistration', 'applicationId', applicationId)
            // verify required parameter 'registrationId' is not null or undefined
            assertParamExists('getApplicationRegistration', 'registrationId', registrationId)
            const localVarPath = `/api/v2/applications/{applicationId}/registrations/{registrationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"registrationId"}}`, encodeURIComponent(String(registrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists product registrations for an application.
         * @summary Get application registrations
         * @param {string} applicationId Id of the targeted application
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterIdEq] Filter by direct equality comparison of the id property with a supplied value.
         * @param {string} [filterId] Filter by direct equality comparison (short-hand) of the id property with a supplied value.
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatusEq] Filter by direct equality comparison of the status property with a supplied value.
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatus] Filter by direct equality comparison (short-hand) of the status property with a supplied value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationRegistrations: async (applicationId: string, pageSize?: number, pageNumber?: number, filterIdEq?: string, filterId?: string, filterStatusEq?: 'approved' | 'pending' | 'rejected' | 'revoked', filterStatus?: 'approved' | 'pending' | 'rejected' | 'revoked', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationRegistrations', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/registrations`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (filterIdEq !== undefined) {
                localVarQueryParameter['filter[id][eq]'] = filterIdEq;
            }

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterStatusEq !== undefined) {
                localVarQueryParameter['filter[status][eq]'] = filterStatusEq;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistrationsApi - functional programming interface
 * @export
 */
export const RegistrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Registers an application for a product.
         * @summary Register an application for a product
         * @param {string} applicationId Id of the targeted application
         * @param {CreateRegistrationPayload} createRegistrationPayload Create an application registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationRegistration(applicationId: string, createRegistrationPayload: CreateRegistrationPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRegistrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationRegistration(applicationId, createRegistrationPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unregister an application for a product version.
         * @summary Delete an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationRegistration(applicationId: string, registrationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationRegistration(applicationId, registrationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the specified product registration for an application.
         * @summary Get an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationRegistration(applicationId: string, registrationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRegistrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationRegistration(applicationId, registrationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists product registrations for an application.
         * @summary Get application registrations
         * @param {string} applicationId Id of the targeted application
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterIdEq] Filter by direct equality comparison of the id property with a supplied value.
         * @param {string} [filterId] Filter by direct equality comparison (short-hand) of the id property with a supplied value.
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatusEq] Filter by direct equality comparison of the status property with a supplied value.
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatus] Filter by direct equality comparison (short-hand) of the status property with a supplied value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationRegistrations(applicationId: string, pageSize?: number, pageNumber?: number, filterIdEq?: string, filterId?: string, filterStatusEq?: 'approved' | 'pending' | 'rejected' | 'revoked', filterStatus?: 'approved' | 'pending' | 'rejected' | 'revoked', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRegistrationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationRegistrations(applicationId, pageSize, pageNumber, filterIdEq, filterId, filterStatusEq, filterStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegistrationsApi - factory interface
 * @export
 */
export const RegistrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistrationsApiFp(configuration)
    return {
        /**
         * Registers an application for a product.
         * @summary Register an application for a product
         * @param {string} applicationId Id of the targeted application
         * @param {CreateRegistrationPayload} createRegistrationPayload Create an application registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationRegistration(applicationId: string, createRegistrationPayload: CreateRegistrationPayload, options?: any): AxiosPromise<GetRegistrationResponse> {
            return localVarFp.createApplicationRegistration(applicationId, createRegistrationPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Unregister an application for a product version.
         * @summary Delete an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationRegistration(applicationId: string, registrationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationRegistration(applicationId, registrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the specified product registration for an application.
         * @summary Get an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationRegistration(applicationId: string, registrationId: string, options?: any): AxiosPromise<GetRegistrationResponse> {
            return localVarFp.getApplicationRegistration(applicationId, registrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists product registrations for an application.
         * @summary Get application registrations
         * @param {string} applicationId Id of the targeted application
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterIdEq] Filter by direct equality comparison of the id property with a supplied value.
         * @param {string} [filterId] Filter by direct equality comparison (short-hand) of the id property with a supplied value.
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatusEq] Filter by direct equality comparison of the status property with a supplied value.
         * @param {'approved' | 'pending' | 'rejected' | 'revoked'} [filterStatus] Filter by direct equality comparison (short-hand) of the status property with a supplied value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationRegistrations(applicationId: string, pageSize?: number, pageNumber?: number, filterIdEq?: string, filterId?: string, filterStatusEq?: 'approved' | 'pending' | 'rejected' | 'revoked', filterStatus?: 'approved' | 'pending' | 'rejected' | 'revoked', options?: any): AxiosPromise<ListRegistrationsResponse> {
            return localVarFp.listApplicationRegistrations(applicationId, pageSize, pageNumber, filterIdEq, filterId, filterStatusEq, filterStatus, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createApplicationRegistration operation in RegistrationsApi.
 * @export
 * @interface RegistrationsApiCreateApplicationRegistrationRequest
 */
export interface RegistrationsApiCreateApplicationRegistrationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof RegistrationsApiCreateApplicationRegistration
     */
    readonly applicationId: string

    /**
     * Create an application registration.
     * @type {CreateRegistrationPayload}
     * @memberof RegistrationsApiCreateApplicationRegistration
     */
    readonly createRegistrationPayload: CreateRegistrationPayload
}

/**
 * Request parameters for deleteApplicationRegistration operation in RegistrationsApi.
 * @export
 * @interface RegistrationsApiDeleteApplicationRegistrationRequest
 */
export interface RegistrationsApiDeleteApplicationRegistrationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof RegistrationsApiDeleteApplicationRegistration
     */
    readonly applicationId: string

    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof RegistrationsApiDeleteApplicationRegistration
     */
    readonly registrationId: string
}

/**
 * Request parameters for getApplicationRegistration operation in RegistrationsApi.
 * @export
 * @interface RegistrationsApiGetApplicationRegistrationRequest
 */
export interface RegistrationsApiGetApplicationRegistrationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof RegistrationsApiGetApplicationRegistration
     */
    readonly applicationId: string

    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof RegistrationsApiGetApplicationRegistration
     */
    readonly registrationId: string
}

/**
 * Request parameters for listApplicationRegistrations operation in RegistrationsApi.
 * @export
 * @interface RegistrationsApiListApplicationRegistrationsRequest
 */
export interface RegistrationsApiListApplicationRegistrationsRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof RegistrationsApiListApplicationRegistrations
     */
    readonly applicationId: string

    /**
     * Determines the size of the page to retrieve.
     * @type {number}
     * @memberof RegistrationsApiListApplicationRegistrations
     */
    readonly pageSize?: number

    /**
     * Determines which page of the entities to retrieve.
     * @type {number}
     * @memberof RegistrationsApiListApplicationRegistrations
     */
    readonly pageNumber?: number

    /**
     * Filter by direct equality comparison of the id property with a supplied value.
     * @type {string}
     * @memberof RegistrationsApiListApplicationRegistrations
     */
    readonly filterIdEq?: string

    /**
     * Filter by direct equality comparison (short-hand) of the id property with a supplied value.
     * @type {string}
     * @memberof RegistrationsApiListApplicationRegistrations
     */
    readonly filterId?: string

    /**
     * Filter by direct equality comparison of the status property with a supplied value.
     * @type {'approved' | 'pending' | 'rejected' | 'revoked'}
     * @memberof RegistrationsApiListApplicationRegistrations
     */
    readonly filterStatusEq?: 'approved' | 'pending' | 'rejected' | 'revoked'

    /**
     * Filter by direct equality comparison (short-hand) of the status property with a supplied value.
     * @type {'approved' | 'pending' | 'rejected' | 'revoked'}
     * @memberof RegistrationsApiListApplicationRegistrations
     */
    readonly filterStatus?: 'approved' | 'pending' | 'rejected' | 'revoked'
}

/**
 * RegistrationsApi - object-oriented interface
 * @export
 * @class RegistrationsApi
 * @extends {BaseAPI}
 */
export class RegistrationsApi extends BaseAPI {
    /**
     * Registers an application for a product.
     * @summary Register an application for a product
     * @param {RegistrationsApiCreateApplicationRegistrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationsApi
     */
    public createApplicationRegistration(requestParameters: RegistrationsApiCreateApplicationRegistrationRequest, options?: AxiosRequestConfig) {
        return RegistrationsApiFp(this.configuration).createApplicationRegistration(requestParameters.applicationId, requestParameters.createRegistrationPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unregister an application for a product version.
     * @summary Delete an application registration
     * @param {RegistrationsApiDeleteApplicationRegistrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationsApi
     */
    public deleteApplicationRegistration(requestParameters: RegistrationsApiDeleteApplicationRegistrationRequest, options?: AxiosRequestConfig) {
        return RegistrationsApiFp(this.configuration).deleteApplicationRegistration(requestParameters.applicationId, requestParameters.registrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the specified product registration for an application.
     * @summary Get an application registration
     * @param {RegistrationsApiGetApplicationRegistrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationsApi
     */
    public getApplicationRegistration(requestParameters: RegistrationsApiGetApplicationRegistrationRequest, options?: AxiosRequestConfig) {
        return RegistrationsApiFp(this.configuration).getApplicationRegistration(requestParameters.applicationId, requestParameters.registrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists product registrations for an application.
     * @summary Get application registrations
     * @param {RegistrationsApiListApplicationRegistrationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationsApi
     */
    public listApplicationRegistrations(requestParameters: RegistrationsApiListApplicationRegistrationsRequest, options?: AxiosRequestConfig) {
        return RegistrationsApiFp(this.configuration).listApplicationRegistrations(requestParameters.applicationId, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.filterIdEq, requestParameters.filterId, requestParameters.filterStatusEq, requestParameters.filterStatus, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns paginated search results from the specified entities with the given search parameters.
         * @summary Search Portal Entities
         * @param {SearchIndicesParameters} indices Determines which entity sets to search
         * @param {string} [q] Determines how to filter search results
         * @param {string} [join] Determines which sub-entities to include in search results
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPortalEntities: async (indices: SearchIndicesParameters, q?: string, join?: string, pageSize?: number, pageNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indices' is not null or undefined
            assertParamExists('searchPortalEntities', 'indices', indices)
            const localVarPath = `/api/v2/search/{indices}`
                .replace(`{${"indices"}}`, encodeURIComponent(String(indices)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (join !== undefined) {
                localVarQueryParameter['join'] = join;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns paginated search results from the specified entities with the given search parameters.
         * @summary Search Portal Entities
         * @param {SearchIndicesParameters} indices Determines which entity sets to search
         * @param {string} [q] Determines how to filter search results
         * @param {string} [join] Determines which sub-entities to include in search results
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPortalEntities(indices: SearchIndicesParameters, q?: string, join?: string, pageSize?: number, pageNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPortalEntities(indices, q, join, pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Returns paginated search results from the specified entities with the given search parameters.
         * @summary Search Portal Entities
         * @param {SearchIndicesParameters} indices Determines which entity sets to search
         * @param {string} [q] Determines how to filter search results
         * @param {string} [join] Determines which sub-entities to include in search results
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPortalEntities(indices: SearchIndicesParameters, q?: string, join?: string, pageSize?: number, pageNumber?: number, options?: any): AxiosPromise<SearchResults> {
            return localVarFp.searchPortalEntities(indices, q, join, pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for searchPortalEntities operation in SearchApi.
 * @export
 * @interface SearchApiSearchPortalEntitiesRequest
 */
export interface SearchApiSearchPortalEntitiesRequest {
    /**
     * Determines which entity sets to search
     * @type {SearchIndicesParameters}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly indices: SearchIndicesParameters

    /**
     * Determines how to filter search results
     * @type {string}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly q?: string

    /**
     * Determines which sub-entities to include in search results
     * @type {string}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly join?: string

    /**
     * Determines the size of the page to retrieve.
     * @type {number}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly pageSize?: number

    /**
     * Determines which page of the entities to retrieve.
     * @type {number}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly pageNumber?: number
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Returns paginated search results from the specified entities with the given search parameters.
     * @summary Search Portal Entities
     * @param {SearchApiSearchPortalEntitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchPortalEntities(requestParameters: SearchApiSearchPortalEntitiesRequest, options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchPortalEntities(requestParameters.indices, requestParameters.q, requestParameters.join, requestParameters.pageSize, requestParameters.pageNumber, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VersionsApi - axios parameter creator
 * @export
 */
export const VersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the details for an existing product version.
         * @summary Get product version
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} versionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersion: async (productId: string, versionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductVersion', 'productId', productId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getProductVersion', 'versionId', versionId)
            const localVarPath = `/api/v2/products/{productId}/versions/{versionId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the API specification document attached to given product version. Currently only OpenAPI is supported.
         * @summary Get spec for product version
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} versionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersionSpec: async (productId: string, versionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductVersionSpec', 'productId', productId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getProductVersionSpec', 'versionId', versionId)
            const localVarPath = `/api/v2/products/{productId}/versions/{versionId}/spec`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of operations used in the API specification document attached to given product version.
         * @summary Get operations in version spec
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} versionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersionSpecOperations: async (productId: string, versionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductVersionSpecOperations', 'productId', productId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getProductVersionSpecOperations', 'versionId', versionId)
            const localVarPath = `/api/v2/products/{productId}/versions/{versionId}/spec/operations`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paginated list of versions of a given product.
         * @summary Get page of product versions
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductVersions: async (productId: string, pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('listProductVersions', 'productId', productId)
            const localVarPath = `/api/v2/products/{productId}/versions`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (filterNameEq !== undefined) {
                localVarQueryParameter['filter[name][eq]'] = filterNameEq;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterNameContains !== undefined) {
                localVarQueryParameter['filter[name][contains]'] = filterNameContains;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionsApi - functional programming interface
 * @export
 */
export const VersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets the details for an existing product version.
         * @summary Get product version
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} versionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductVersion(productId: string, versionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductVersion(productId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the API specification document attached to given product version. Currently only OpenAPI is supported.
         * @summary Get spec for product version
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} versionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductVersionSpec(productId: string, versionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVersionSpec>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductVersionSpec(productId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list of operations used in the API specification document attached to given product version.
         * @summary Get operations in version spec
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} versionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductVersionSpecOperations(productId: string, versionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVersionSpecOperations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductVersionSpecOperations(productId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns paginated list of versions of a given product.
         * @summary Get page of product versions
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductVersions(productId: string, pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVersionListPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProductVersions(productId, pageSize, pageNumber, filterNameEq, filterName, filterNameContains, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VersionsApi - factory interface
 * @export
 */
export const VersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionsApiFp(configuration)
    return {
        /**
         * Gets the details for an existing product version.
         * @summary Get product version
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} versionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersion(productId: string, versionId: string, options?: any): AxiosPromise<ProductVersion> {
            return localVarFp.getProductVersion(productId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the API specification document attached to given product version. Currently only OpenAPI is supported.
         * @summary Get spec for product version
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} versionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersionSpec(productId: string, versionId: string, options?: any): AxiosPromise<ProductVersionSpec> {
            return localVarFp.getProductVersionSpec(productId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of operations used in the API specification document attached to given product version.
         * @summary Get operations in version spec
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {string} versionId Contains a unique identifier used by the Portal API for this resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersionSpecOperations(productId: string, versionId: string, options?: any): AxiosPromise<ProductVersionSpecOperations> {
            return localVarFp.getProductVersionSpecOperations(productId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns paginated list of versions of a given product.
         * @summary Get page of product versions
         * @param {string} productId Contains a unique identifier used by the Portal API for this resource.
         * @param {number} [pageSize] Determines the size of the page to retrieve.
         * @param {number} [pageNumber] Determines which page of the entities to retrieve.
         * @param {string} [filterNameEq] Filter by direct equality comparison of the name property with a supplied value.
         * @param {string} [filterName] Filter by direct equality comparison (short-hand) of the name property with a supplied value.
         * @param {string} [filterNameContains] Filter by contains comparison of the name property with a supplied substring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductVersions(productId: string, pageSize?: number, pageNumber?: number, filterNameEq?: string, filterName?: string, filterNameContains?: string, options?: any): AxiosPromise<ProductVersionListPage> {
            return localVarFp.listProductVersions(productId, pageSize, pageNumber, filterNameEq, filterName, filterNameContains, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getProductVersion operation in VersionsApi.
 * @export
 * @interface VersionsApiGetProductVersionRequest
 */
export interface VersionsApiGetProductVersionRequest {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof VersionsApiGetProductVersion
     */
    readonly productId: string

    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof VersionsApiGetProductVersion
     */
    readonly versionId: string
}

/**
 * Request parameters for getProductVersionSpec operation in VersionsApi.
 * @export
 * @interface VersionsApiGetProductVersionSpecRequest
 */
export interface VersionsApiGetProductVersionSpecRequest {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof VersionsApiGetProductVersionSpec
     */
    readonly productId: string

    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof VersionsApiGetProductVersionSpec
     */
    readonly versionId: string
}

/**
 * Request parameters for getProductVersionSpecOperations operation in VersionsApi.
 * @export
 * @interface VersionsApiGetProductVersionSpecOperationsRequest
 */
export interface VersionsApiGetProductVersionSpecOperationsRequest {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof VersionsApiGetProductVersionSpecOperations
     */
    readonly productId: string

    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof VersionsApiGetProductVersionSpecOperations
     */
    readonly versionId: string
}

/**
 * Request parameters for listProductVersions operation in VersionsApi.
 * @export
 * @interface VersionsApiListProductVersionsRequest
 */
export interface VersionsApiListProductVersionsRequest {
    /**
     * Contains a unique identifier used by the Portal API for this resource.
     * @type {string}
     * @memberof VersionsApiListProductVersions
     */
    readonly productId: string

    /**
     * Determines the size of the page to retrieve.
     * @type {number}
     * @memberof VersionsApiListProductVersions
     */
    readonly pageSize?: number

    /**
     * Determines which page of the entities to retrieve.
     * @type {number}
     * @memberof VersionsApiListProductVersions
     */
    readonly pageNumber?: number

    /**
     * Filter by direct equality comparison of the name property with a supplied value.
     * @type {string}
     * @memberof VersionsApiListProductVersions
     */
    readonly filterNameEq?: string

    /**
     * Filter by direct equality comparison (short-hand) of the name property with a supplied value.
     * @type {string}
     * @memberof VersionsApiListProductVersions
     */
    readonly filterName?: string

    /**
     * Filter by contains comparison of the name property with a supplied substring
     * @type {string}
     * @memberof VersionsApiListProductVersions
     */
    readonly filterNameContains?: string
}

/**
 * VersionsApi - object-oriented interface
 * @export
 * @class VersionsApi
 * @extends {BaseAPI}
 */
export class VersionsApi extends BaseAPI {
    /**
     * Gets the details for an existing product version.
     * @summary Get product version
     * @param {VersionsApiGetProductVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getProductVersion(requestParameters: VersionsApiGetProductVersionRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).getProductVersion(requestParameters.productId, requestParameters.versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the API specification document attached to given product version. Currently only OpenAPI is supported.
     * @summary Get spec for product version
     * @param {VersionsApiGetProductVersionSpecRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getProductVersionSpec(requestParameters: VersionsApiGetProductVersionSpecRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).getProductVersionSpec(requestParameters.productId, requestParameters.versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of operations used in the API specification document attached to given product version.
     * @summary Get operations in version spec
     * @param {VersionsApiGetProductVersionSpecOperationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getProductVersionSpecOperations(requestParameters: VersionsApiGetProductVersionSpecOperationsRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).getProductVersionSpecOperations(requestParameters.productId, requestParameters.versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paginated list of versions of a given product.
     * @summary Get page of product versions
     * @param {VersionsApiListProductVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public listProductVersions(requestParameters: VersionsApiListProductVersionsRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).listProductVersions(requestParameters.productId, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.filterNameEq, requestParameters.filterName, requestParameters.filterNameContains, options).then((request) => request(this.axios, this.basePath));
    }
}


