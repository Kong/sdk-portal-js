/* tslint:disable */
/* eslint-disable */
/**
 * Portal API
 * Portal API
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const AlignmentKind = {
    Left: 'left',
    Right: 'right',
    Center: 'center',
    None: 'none'
} as const;

export type AlignmentKind = typeof AlignmentKind[keyof typeof AlignmentKind];


/**
 * @type AnyNode
 * @export
 */
export type AnyNode = { type: 'blockquote' } & BlockQuoteBlock | { type: 'break' } & BreakBlock | { type: 'code' } & Code | { type: 'code_block' } & CodeBlock | { type: 'document' } & DocumentBlock | { type: 'emphasis' } & Emphasis | { type: 'heading' } & HeadingBlock | { type: 'image' } & Image | { type: 'link' } & Link | { type: 'list' } & ListBlock | { type: 'list_item' } & ListItemBlock | { type: 'paragraph' } & ParagraphBlock | { type: 'strikethrough' } & StrikeThrough | { type: 'table' } & TableBlock | { type: 'table_cell' } & TableCellBlock | { type: 'table_header' } & TableHeaderBlock | { type: 'table_row' } & TableRowBlock | { type: 'task_checkbox' } & TaskCheckbox | { type: 'text' } & Text | { type: 'text_block' } & TextBlock;

/**
 * Application creation response payload
 * @export
 * @interface ApplicationCreationResponse
 */
export interface ApplicationCreationResponse {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'reference_id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponse
     */
    'redirect_uri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationCreationResponse
     */
    'is_dcr': boolean;
    /**
     * 
     * @type {ApplicationCreationResponseCredentials}
     * @memberof ApplicationCreationResponse
     */
    'credentials'?: ApplicationCreationResponseCredentials;
}
/**
 * 
 * @export
 * @interface ApplicationCreationResponseCredentials
 */
export interface ApplicationCreationResponseCredentials {
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponseCredentials
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCreationResponseCredentials
     */
    'client_secret': string;
}
/**
 * 
 * @export
 * @interface ApplicationRegistrationConfiguration
 */
export interface ApplicationRegistrationConfiguration {
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationRegistrationConfiguration
     */
    'auto_approve': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationRegistrationConfiguration
     */
    'status': ApplicationRegistrationConfigurationStatusEnum;
    /**
     * 
     * @type {ApplicationRegistrationConfigurationAuthConfig}
     * @memberof ApplicationRegistrationConfiguration
     */
    'auth_config': ApplicationRegistrationConfigurationAuthConfig;
}

export const ApplicationRegistrationConfigurationStatusEnum = {
    Enabled: 'enabled',
    Pending: 'pending'
} as const;

export type ApplicationRegistrationConfigurationStatusEnum = typeof ApplicationRegistrationConfigurationStatusEnum[keyof typeof ApplicationRegistrationConfigurationStatusEnum];

/**
 * 
 * @export
 * @interface ApplicationRegistrationConfigurationAuthConfig
 */
export interface ApplicationRegistrationConfigurationAuthConfig {
    /**
     * 
     * @type {string}
     * @memberof ApplicationRegistrationConfigurationAuthConfig
     */
    'name'?: ApplicationRegistrationConfigurationAuthConfigNameEnum;
    /**
     * 
     * @type {object}
     * @memberof ApplicationRegistrationConfigurationAuthConfig
     */
    'config'?: object;
}

export const ApplicationRegistrationConfigurationAuthConfigNameEnum = {
    KeyAuth: 'key-auth',
    OpenidConnect: 'openid-connect'
} as const;

export type ApplicationRegistrationConfigurationAuthConfigNameEnum = typeof ApplicationRegistrationConfigurationAuthConfigNameEnum[keyof typeof ApplicationRegistrationConfigurationAuthConfigNameEnum];

/**
 * Application update response payload
 * @export
 * @interface ApplicationUpdateResponse
 */
export interface ApplicationUpdateResponse {
    /**
     * 
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'reference_id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUpdateResponse
     */
    'redirect_uri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUpdateResponse
     */
    'is_dcr': boolean;
}
/**
 * 
 * @export
 * @interface BadRequestError
 */
export interface BadRequestError {
    /**
     * The HTTP status code of the error. Useful when passing the response body to child properties in a frontend UI. Must be returned as an integer. 
     * @type {number}
     * @memberof BadRequestError
     */
    'status': number;
    /**
     * A short, human-readable summary of the problem. It should not change between occurences of a problem, except for localization. Should be provided as \"Sentence case\" for direct use in the UI. 
     * @type {string}
     * @memberof BadRequestError
     */
    'title': string;
    /**
     * The error type.
     * @type {string}
     * @memberof BadRequestError
     */
    'type'?: string;
    /**
     * Used to return the correlation ID back to the user, in the format kong:trace:<correlation_id>. This helps us find the relevant logs when a customer reports an issue. 
     * @type {string}
     * @memberof BadRequestError
     */
    'instance': string;
    /**
     * A human readable explanation specific to this occurence of the problem. This field may contain request/entity data to help the user understand what went wrong. Enclose variable values in square brackets. Should be provided as \"Sentence case\" for direct use in the UI. 
     * @type {string}
     * @memberof BadRequestError
     */
    'detail': string;
}
/**
 * standard error
 * @export
 * @interface BaseError
 */
export interface BaseError {
    /**
     * The HTTP status code of the error. Useful when passing the response body to child properties in a frontend UI. Must be returned as an integer. 
     * @type {number}
     * @memberof BaseError
     */
    'status': number;
    /**
     * A short, human-readable summary of the problem. It should not change between occurences of a problem, except for localization. Should be provided as \"Sentence case\" for direct use in the UI. 
     * @type {string}
     * @memberof BaseError
     */
    'title': string;
    /**
     * The error type.
     * @type {string}
     * @memberof BaseError
     */
    'type'?: string;
    /**
     * Used to return the correlation ID back to the user, in the format kong:trace:<correlation_id>. This helps us find the relevant logs when a customer reports an issue. 
     * @type {string}
     * @memberof BaseError
     */
    'instance': string;
    /**
     * A human readable explanation specific to this occurence of the problem. This field may contain request/entity data to help the user understand what went wrong. Enclose variable values in square brackets. Should be provided as \"Sentence case\" for direct use in the UI. 
     * @type {string}
     * @memberof BaseError
     */
    'detail': string;
}
/**
 * 
 * @export
 * @interface BaseNode
 */
export interface BaseNode {
    /**
     * 
     * @type {string}
     * @memberof BaseNode
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface BlockNode
 */
export interface BlockNode {
    /**
     * 
     * @type {string}
     * @memberof BlockNode
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof BlockNode
     */
    'children'?: Array<AnyNode>;
}
/**
 * 
 * @export
 * @interface BlockNodeAllOf
 */
export interface BlockNodeAllOf {
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof BlockNodeAllOf
     */
    'children'?: Array<AnyNode>;
}
/**
 * 
 * @export
 * @interface BlockQuoteBlock
 */
export interface BlockQuoteBlock {
    /**
     * 
     * @type {string}
     * @memberof BlockQuoteBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof BlockQuoteBlock
     */
    'children'?: Array<AnyNode>;
}
/**
 * 
 * @export
 * @interface BreakBlock
 */
export interface BreakBlock {
    /**
     * 
     * @type {string}
     * @memberof BreakBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof BreakBlock
     */
    'children'?: Array<AnyNode>;
}
/**
 * 
 * @export
 * @interface Code
 */
export interface Code {
    /**
     * 
     * @type {string}
     * @memberof Code
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof Code
     */
    'children'?: Array<AnyNode>;
}
/**
 * 
 * @export
 * @interface CodeBlock
 */
export interface CodeBlock {
    /**
     * 
     * @type {string}
     * @memberof CodeBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof CodeBlock
     */
    'children'?: Array<AnyNode>;
    /**
     * 
     * @type {string}
     * @memberof CodeBlock
     */
    'lang'?: string;
}
/**
 * 
 * @export
 * @interface CodeBlockAllOf
 */
export interface CodeBlockAllOf {
    /**
     * 
     * @type {string}
     * @memberof CodeBlockAllOf
     */
    'lang'?: string;
}
/**
 * an application payload
 * @export
 * @interface CreateApplicationPayload
 */
export interface CreateApplicationPayload {
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'reference_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'redirect_uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationPayload
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateCredentialPayload
 */
export interface CreateCredentialPayload {
    /**
     * 
     * @type {string}
     * @memberof CreateCredentialPayload
     */
    'display_name'?: string;
}
/**
 * an application registration payload
 * @export
 * @interface CreateRegistrationPayload
 */
export interface CreateRegistrationPayload {
    /**
     * The UUID of the service version to register for
     * @type {string}
     * @memberof CreateRegistrationPayload
     */
    'service_version_id': string;
}
/**
 * 
 * @export
 * @interface CredentialCreationResponse
 */
export interface CredentialCreationResponse {
    /**
     * 
     * @type {string}
     * @memberof CredentialCreationResponse
     */
    'credential': string;
    /**
     * 
     * @type {string}
     * @memberof CredentialCreationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CredentialCreationResponse
     */
    'display_name': string;
}
/**
 * content of the document
 * @export
 * @interface DocumentBlock
 */
export interface DocumentBlock {
    /**
     * 
     * @type {string}
     * @memberof DocumentBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof DocumentBlock
     */
    'children'?: Array<AnyNode>;
    /**
     * 
     * @type {string}
     * @memberof DocumentBlock
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface DocumentBlockAllOf
 */
export interface DocumentBlockAllOf {
    /**
     * 
     * @type {string}
     * @memberof DocumentBlockAllOf
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface Emphasis
 */
export interface Emphasis {
    /**
     * 
     * @type {string}
     * @memberof Emphasis
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof Emphasis
     */
    'children'?: Array<AnyNode>;
    /**
     * Level of emphasis 1 - italic 2 - bold 
     * @type {number}
     * @memberof Emphasis
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface EmphasisAllOf
 */
export interface EmphasisAllOf {
    /**
     * Level of emphasis 1 - italic 2 - bold 
     * @type {number}
     * @memberof EmphasisAllOf
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface ErrorInvalidParametersInner
 */
export interface ErrorInvalidParametersInner {
    [key: string]: any;

    /**
     * The name of the invalid parameter.
     * @type {string}
     * @memberof ErrorInvalidParametersInner
     */
    'name'?: string;
    /**
     * The reason the parameter is invalid.
     * @type {string}
     * @memberof ErrorInvalidParametersInner
     */
    'reason': string;
    /**
     * The field that caused the error.
     * @type {string}
     * @memberof ErrorInvalidParametersInner
     */
    'field': string;
    /**
     * The rule that caused the error.
     * @type {string}
     * @memberof ErrorInvalidParametersInner
     */
    'rule'?: string;
}
/**
 * 
 * @export
 * @interface GetApplicationResponse
 */
export interface GetApplicationResponse {
    /**
     * 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'reference_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationResponse
     */
    'redirect_uri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplicationResponse
     */
    'is_dcr': boolean;
}
/**
 * 
 * @export
 * @interface GetCredentialsResponse
 */
export interface GetCredentialsResponse {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof GetCredentialsResponse
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<GetCredentialsResponseDataInner>}
     * @memberof GetCredentialsResponse
     */
    'data': Array<GetCredentialsResponseDataInner>;
}
/**
 * 
 * @export
 * @interface GetCredentialsResponseDataInner
 */
export interface GetCredentialsResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetCredentialsResponseDataInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetCredentialsResponseDataInner
     */
    'display_name': string;
}
/**
 * 
 * @export
 * @interface GetManyApplicationsResponse
 */
export interface GetManyApplicationsResponse {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof GetManyApplicationsResponse
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<GetApplicationResponse>}
     * @memberof GetManyApplicationsResponse
     */
    'data': Array<GetApplicationResponse>;
}
/**
 * 
 * @export
 * @interface GetManyRegistrationsResponse
 */
export interface GetManyRegistrationsResponse {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof GetManyRegistrationsResponse
     */
    'meta': PaginatedMeta;
    /**
     * 
     * @type {Array<GetRegistrationResponse>}
     * @memberof GetManyRegistrationsResponse
     */
    'data': Array<GetRegistrationResponse>;
}
/**
 * 
 * @export
 * @interface GetRegistrationResponse
 */
export interface GetRegistrationResponse {
    /**
     * The UUID of the registration
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'id': string;
    /**
     * The approval status of the registration
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'status': GetRegistrationResponseStatusEnum;
    /**
     * The UUID of the service version registered for
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'service_version_id': string;
    /**
     * The UUID of the application the registration is linked to
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'application_id': string;
    /**
     * ISO timestamp the registration record was created
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'created_at': string;
    /**
     * ISO timestamp the registration record was last updated
     * @type {string}
     * @memberof GetRegistrationResponse
     */
    'updated_at': string;
}

export const GetRegistrationResponseStatusEnum = {
    Approved: 'approved',
    Pending: 'pending',
    Rejected: 'rejected',
    Revoked: 'revoked'
} as const;

export type GetRegistrationResponseStatusEnum = typeof GetRegistrationResponseStatusEnum[keyof typeof GetRegistrationResponseStatusEnum];

/**
 * 
 * @export
 * @interface HeadingBlock
 */
export interface HeadingBlock {
    /**
     * 
     * @type {string}
     * @memberof HeadingBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof HeadingBlock
     */
    'children'?: Array<AnyNode>;
    /**
     * Level of the heading which maps to HTML <h> tag
     * @type {number}
     * @memberof HeadingBlock
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface HeadingBlockAllOf
 */
export interface HeadingBlockAllOf {
    /**
     * Level of the heading which maps to HTML <h> tag
     * @type {number}
     * @memberof HeadingBlockAllOf
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'type': string;
    /**
     * Url of the image
     * @type {string}
     * @memberof Image
     */
    'url'?: string;
    /**
     * Alternate tag of the image
     * @type {string}
     * @memberof Image
     */
    'alt'?: string;
    /**
     * Title of the image
     * @type {string}
     * @memberof Image
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface ImageAllOf
 */
export interface ImageAllOf {
    /**
     * Url of the image
     * @type {string}
     * @memberof ImageAllOf
     */
    'url'?: string;
    /**
     * Alternate tag of the image
     * @type {string}
     * @memberof ImageAllOf
     */
    'alt'?: string;
    /**
     * Title of the image
     * @type {string}
     * @memberof ImageAllOf
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface InvalidParameterItem
 */
export interface InvalidParameterItem {
    /**
     * 
     * @type {string}
     * @memberof InvalidParameterItem
     */
    'field': string;
    /**
     * 
     * @type {InvalidRules}
     * @memberof InvalidParameterItem
     */
    'rule': InvalidRules;
    /**
     * 
     * @type {string}
     * @memberof InvalidParameterItem
     */
    'reason': string;
    /**
     * 
     * @type {Set<any>}
     * @memberof InvalidParameterItem
     */
    'choices'?: Set<any>;
}
/**
 * invalid parameters rules
 * @export
 * @enum {string}
 */

export const InvalidRules = {
    Required: 'required',
    Enum: 'enum',
    MinLength: 'min_length',
    MaxLength: 'max_length',
    MinDigits: 'min_digits',
    MinLowercase: 'min_lowercase',
    MinUppercase: 'min_uppercase',
    MinSymbols: 'min_symbols'
} as const;

export type InvalidRules = typeof InvalidRules[keyof typeof InvalidRules];


/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'type': string;
    /**
     * Target url of the link
     * @type {string}
     * @memberof Link
     */
    'href'?: string;
    /**
     * Title of the link
     * @type {string}
     * @memberof Link
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface LinkAllOf
 */
export interface LinkAllOf {
    /**
     * Target url of the link
     * @type {string}
     * @memberof LinkAllOf
     */
    'href'?: string;
    /**
     * Title of the link
     * @type {string}
     * @memberof LinkAllOf
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface ListBlock
 */
export interface ListBlock {
    /**
     * 
     * @type {string}
     * @memberof ListBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof ListBlock
     */
    'children'?: Array<AnyNode>;
    /**
     * Defines if the list is ordered or not
     * @type {boolean}
     * @memberof ListBlock
     */
    'isOrdered'?: boolean;
}
/**
 * 
 * @export
 * @interface ListBlockAllOf
 */
export interface ListBlockAllOf {
    /**
     * Defines if the list is ordered or not
     * @type {boolean}
     * @memberof ListBlockAllOf
     */
    'isOrdered'?: boolean;
}
/**
 * 
 * @export
 * @interface ListItemBlock
 */
export interface ListItemBlock {
    /**
     * 
     * @type {string}
     * @memberof ListItemBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof ListItemBlock
     */
    'children'?: Array<AnyNode>;
}
/**
 * standard error
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * The HTTP status code.
     * @type {number}
     * @memberof ModelError
     */
    'status': number;
    /**
     * The error response code.
     * @type {string}
     * @memberof ModelError
     */
    'title': string;
    /**
     * The error type.
     * @type {string}
     * @memberof ModelError
     */
    'type'?: string;
    /**
     * The portal traceback code
     * @type {string}
     * @memberof ModelError
     */
    'instance': string;
    /**
     * An array of objects that contains information related to the error response.
     * @type {Array<ErrorInvalidParametersInner>}
     * @memberof ModelError
     */
    'invalid_parameters'?: Array<ErrorInvalidParametersInner>;
    /**
     * Details about the error.
     * @type {string}
     * @memberof ModelError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
    /**
     * The HTTP status code of the error. Useful when passing the response body to child properties in a frontend UI. Must be returned as an integer. 
     * @type {number}
     * @memberof NotFoundError
     */
    'status': number;
    /**
     * A short, human-readable summary of the problem. It should not change between occurences of a problem, except for localization. Should be provided as \"Sentence case\" for direct use in the UI. 
     * @type {string}
     * @memberof NotFoundError
     */
    'title': string;
    /**
     * The error type.
     * @type {string}
     * @memberof NotFoundError
     */
    'type'?: string;
    /**
     * Used to return the correlation ID back to the user, in the format kong:trace:<correlation_id>. This helps us find the relevant logs when a customer reports an issue. 
     * @type {string}
     * @memberof NotFoundError
     */
    'instance': string;
    /**
     * A human readable explanation specific to this occurence of the problem. This field may contain request/entity data to help the user understand what went wrong. Enclose variable values in square brackets. Should be provided as \"Sentence case\" for direct use in the UI. 
     * @type {string}
     * @memberof NotFoundError
     */
    'detail': string;
}
/**
 * Contains pagination query parameters and the total number of objects returned.
 * @export
 * @interface PageMeta
 */
export interface PageMeta {
    /**
     * 
     * @type {number}
     * @memberof PageMeta
     */
    'number': number;
    /**
     * 
     * @type {number}
     * @memberof PageMeta
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof PageMeta
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface PageParameters
 */
export interface PageParameters {
    /**
     * 
     * @type {number}
     * @memberof PageParameters
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageParameters
     */
    'number'?: number;
}
/**
 * Returns pagination information
 * @export
 * @interface PaginatedMeta
 */
export interface PaginatedMeta {
    /**
     * 
     * @type {PageMeta}
     * @memberof PaginatedMeta
     */
    'page': PageMeta;
}
/**
 * 
 * @export
 * @interface ParagraphBlock
 */
export interface ParagraphBlock {
    /**
     * 
     * @type {string}
     * @memberof ParagraphBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof ParagraphBlock
     */
    'children'?: Array<AnyNode>;
}
/**
 * the portal appearance
 * @export
 * @interface PortalAppearance
 */
export interface PortalAppearance {
    /**
     * 
     * @type {PortalAppearanceVariables}
     * @memberof PortalAppearance
     */
    'variables'?: PortalAppearanceVariables;
    /**
     * 
     * @type {PortalAppearanceStylesheets}
     * @memberof PortalAppearance
     */
    'stylesheets'?: PortalAppearanceStylesheets;
}
/**
 * 
 * @export
 * @interface PortalAppearanceStylesheets
 */
export interface PortalAppearanceStylesheets {
    /**
     * 
     * @type {PortalAppearanceStylesheetsGlobal}
     * @memberof PortalAppearanceStylesheets
     */
    'global'?: PortalAppearanceStylesheetsGlobal;
}
/**
 * 
 * @export
 * @interface PortalAppearanceStylesheetsGlobal
 */
export interface PortalAppearanceStylesheetsGlobal {
    /**
     * 
     * @type {PortalAppearanceStylesheetsGlobalMain}
     * @memberof PortalAppearanceStylesheetsGlobal
     */
    'main'?: PortalAppearanceStylesheetsGlobalMain;
}
/**
 * 
 * @export
 * @interface PortalAppearanceStylesheetsGlobalMain
 */
export interface PortalAppearanceStylesheetsGlobalMain {
    /**
     * 
     * @type {object}
     * @memberof PortalAppearanceStylesheetsGlobalMain
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface PortalAppearanceVariables
 */
export interface PortalAppearanceVariables {
    /**
     * 
     * @type {PortalAppearanceVariablesCatalog}
     * @memberof PortalAppearanceVariables
     */
    'catalog'?: PortalAppearanceVariablesCatalog;
}
/**
 * 
 * @export
 * @interface PortalAppearanceVariablesCatalog
 */
export interface PortalAppearanceVariablesCatalog {
    /**
     * 
     * @type {PortalAppearanceVariablesCatalogLogo}
     * @memberof PortalAppearanceVariablesCatalog
     */
    'logo'?: PortalAppearanceVariablesCatalogLogo;
    /**
     * 
     * @type {PortalAppearanceVariablesCatalogLogo}
     * @memberof PortalAppearanceVariablesCatalog
     */
    'cover'?: PortalAppearanceVariablesCatalogLogo;
    /**
     * 
     * @type {PortalAppearanceVariablesCatalogPrimaryHeader}
     * @memberof PortalAppearanceVariablesCatalog
     */
    'primary_header'?: PortalAppearanceVariablesCatalogPrimaryHeader;
    /**
     * 
     * @type {PortalAppearanceVariablesCatalogPrimaryHeader}
     * @memberof PortalAppearanceVariablesCatalog
     */
    'welcome_message'?: PortalAppearanceVariablesCatalogPrimaryHeader;
}
/**
 * 
 * @export
 * @interface PortalAppearanceVariablesCatalogLogo
 */
export interface PortalAppearanceVariablesCatalogLogo {
    /**
     * 
     * @type {string}
     * @memberof PortalAppearanceVariablesCatalogLogo
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface PortalAppearanceVariablesCatalogPrimaryHeader
 */
export interface PortalAppearanceVariablesCatalogPrimaryHeader {
    /**
     * 
     * @type {string}
     * @memberof PortalAppearanceVariablesCatalogPrimaryHeader
     */
    'text'?: string;
}
/**
 * describe the portal execution context
 * @export
 * @interface PortalContext
 */
export interface PortalContext {
    /**
     * 
     * @type {string}
     * @memberof PortalContext
     */
    'portal_id': string;
    /**
     * 
     * @type {string}
     * @memberof PortalContext
     */
    'org_id': string;
    /**
     * 
     * @type {string}
     * @memberof PortalContext
     */
    'featureset_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof PortalContext
     */
    'basic_auth_enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortalContext
     */
    'is_public': boolean;
    /**
     * Is the portal protected with role base access
     * @type {boolean}
     * @memberof PortalContext
     */
    'rbac_enabled': boolean;
    /**
     * Is the portal using DCR application registration
     * @type {boolean}
     * @memberof PortalContext
     */
    'is_dcr': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortalContext
     */
    'oidc_auth_enabled': boolean;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * An ISO-8604 timestamp representation of product creation date.
     * @type {string}
     * @memberof Product
     */
    'created_at': string;
    /**
     * An ISO-8604 timestamp representation of product update date.
     * @type {string}
     * @memberof Product
     */
    'updated_at': string;
    /**
     * name of service
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * display name used by UI for service
     * @type {string}
     * @memberof Product
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'description'?: string;
    /**
     * 
     * @type {object}
     * @memberof Product
     */
    'labels'?: object;
}
/**
 * a document
 * @export
 * @interface ProductDocument
 */
export interface ProductDocument {
    /**
     * the id of the document
     * @type {string}
     * @memberof ProductDocument
     */
    'id': string;
    /**
     * the id of the parent document
     * @type {string}
     * @memberof ProductDocument
     */
    'parent_document_id'?: string | null;
    /**
     * the slug of the document
     * @type {string}
     * @memberof ProductDocument
     */
    'slug': string;
    /**
     * 
     * @type {DocumentBlock}
     * @memberof ProductDocument
     */
    'content': DocumentBlock;
    /**
     * the metadata of the document
     * @type {{ [key: string]: any; }}
     * @memberof ProductDocument
     */
    'meta': { [key: string]: any; };
    /**
     * the title of the document
     * @type {string}
     * @memberof ProductDocument
     */
    'title': string;
}
/**
 * a list of top-level documents in a document tree, each with their children
 * @export
 * @interface ProductDocumentTree
 */
export interface ProductDocumentTree {
    /**
     * 
     * @type {ProductDocumentTreeItem}
     * @memberof ProductDocumentTree
     */
    'tree': ProductDocumentTreeItem;
}
/**
 * an item in a document tree attached to a product
 * @export
 * @interface ProductDocumentTreeItem
 */
export interface ProductDocumentTreeItem {
    /**
     * 
     * @type {string}
     * @memberof ProductDocumentTreeItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductDocumentTreeItem
     */
    'parent_document_id'?: string | null;
    /**
     * the title of the document
     * @type {string}
     * @memberof ProductDocumentTreeItem
     */
    'title': string;
    /**
     * the slug of the document
     * @type {string}
     * @memberof ProductDocumentTreeItem
     */
    'slug': string;
    /**
     * the metadata of the document
     * @type {{ [key: string]: any; }}
     * @memberof ProductDocumentTreeItem
     */
    'meta': { [key: string]: any; };
    /**
     * 
     * @type {Array<DocumentBlock>}
     * @memberof ProductDocumentTreeItem
     */
    'children': Array<DocumentBlock>;
}
/**
 * 
 * @export
 * @interface ProductListPage
 */
export interface ProductListPage {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ProductListPage
     */
    'meta'?: PaginatedMeta;
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductListPage
     */
    'data'?: Array<Product>;
}
/**
 * 
 * @export
 * @interface ProductVersion
 */
export interface ProductVersion {
    /**
     * 
     * @type {string}
     * @memberof ProductVersion
     */
    'id': string;
    /**
     * An ISO-8604 timestamp representation of product version creation date.
     * @type {string}
     * @memberof ProductVersion
     */
    'created_at': string;
    /**
     * An ISO-8604 timestamp representation of product version update date.
     * @type {string}
     * @memberof ProductVersion
     */
    'updated_at': string;
    /**
     * Name of product version
     * @type {string}
     * @memberof ProductVersion
     */
    'version': string;
    /**
     * If true, product version is deprecated
     * @type {boolean}
     * @memberof ProductVersion
     */
    'is_deprecated': boolean;
    /**
     * ID used for application registration with Konnect Application Auth Plugin
     * @type {string}
     * @memberof ProductVersion
     */
    'tracking_id': string;
}
/**
 * 
 * @export
 * @interface ProductVersionListPage
 */
export interface ProductVersionListPage {
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof ProductVersionListPage
     */
    'meta'?: PaginatedMeta;
    /**
     * 
     * @type {Array<ProductVersion>}
     * @memberof ProductVersionListPage
     */
    'data'?: Array<ProductVersion>;
}
/**
 * List of every operation detailed in the product version spec document
 * @export
 * @interface ProductVersionSpecOperations
 */
export interface ProductVersionSpecOperations {
    /**
     * 
     * @type {Array<ProductVersionSpecOperationsOperationsInner>}
     * @memberof ProductVersionSpecOperations
     */
    'operations'?: Array<ProductVersionSpecOperationsOperationsInner>;
}
/**
 * 
 * @export
 * @interface ProductVersionSpecOperationsOperationsInner
 */
export interface ProductVersionSpecOperationsOperationsInner {
    /**
     * 
     * @type {string}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'method'?: ProductVersionSpecOperationsOperationsInnerMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'opertationId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'summary'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductVersionSpecOperationsOperationsInner
     */
    'depercated'?: boolean;
}

export const ProductVersionSpecOperationsOperationsInnerMethodEnum = {
    Get: 'get',
    Patch: 'patch',
    Post: 'post',
    Put: 'put',
    Delete: 'delete',
    Options: 'options',
    Connect: 'connect',
    Trace: 'trace'
} as const;

export type ProductVersionSpecOperationsOperationsInnerMethodEnum = typeof ProductVersionSpecOperationsOperationsInnerMethodEnum[keyof typeof ProductVersionSpecOperationsOperationsInnerMethodEnum];

/**
 * Refresh token response
 * @export
 * @interface RefreshTokenResponse
 */
export interface RefreshTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    'client_secret': string;
}
/**
 * Payload required to be sent to register a developer to the portal. 
 * @export
 * @interface RegisterPayload
 */
export interface RegisterPayload {
    /**
     * 
     * @type {string}
     * @memberof RegisterPayload
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterPayload
     */
    'full_name': string;
}
/**
 * Payload required to start the reset password flow 
 * @export
 * @interface ResetPasswordPayload
 */
export interface ResetPasswordPayload {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordPayload
     */
    'email': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SearchIndicesParameters = {
    ServiceCatalog: 'service-catalog'
} as const;

export type SearchIndicesParameters = typeof SearchIndicesParameters[keyof typeof SearchIndicesParameters];


/**
 * 
 * @export
 * @interface SearchParameters
 */
export interface SearchParameters {
    /**
     * 
     * @type {string}
     * @memberof SearchParameters
     */
    'q'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchParameters
     */
    'join'?: SearchParametersJoinEnum;
}

export const SearchParametersJoinEnum = {
    Documents: 'documents',
    Versions: 'versions',
    VersionsDocuments: 'versions.documents'
} as const;

export type SearchParametersJoinEnum = typeof SearchParametersJoinEnum[keyof typeof SearchParametersJoinEnum];

/**
 * 
 * @export
 * @interface SearchResults
 */
export interface SearchResults {
    /**
     * The paginated data items that matched the search query
     * @type {Array<SearchResultsDataInner>}
     * @memberof SearchResults
     */
    'data': Array<SearchResultsDataInner>;
    /**
     * 
     * @type {PaginatedMeta}
     * @memberof SearchResults
     */
    'meta': PaginatedMeta;
}
/**
 * 
 * @export
 * @interface SearchResultsDataInner
 */
export interface SearchResultsDataInner {
    /**
     * 
     * @type {SearchIndicesParameters}
     * @memberof SearchResultsDataInner
     */
    'index': SearchIndicesParameters;
    /**
     * 
     * @type {ServiceCatalogIndexSource}
     * @memberof SearchResultsDataInner
     */
    'source': ServiceCatalogIndexSource;
}
/**
 * 
 * @export
 * @interface ServiceCatalogIndexSource
 */
export interface ServiceCatalogIndexSource {
    /**
     * The entity ID.
     * @type {string}
     * @memberof ServiceCatalogIndexSource
     */
    'id': string;
    /**
     * the name of the service
     * @type {string}
     * @memberof ServiceCatalogIndexSource
     */
    'name': string;
    /**
     * the name of the service
     * @type {string}
     * @memberof ServiceCatalogIndexSource
     */
    'display_name'?: string;
    /**
     * the name of the service
     * @type {string}
     * @memberof ServiceCatalogIndexSource
     */
    'description'?: string;
    /**
     * An ISO-8604 timestamp representation of entity creation date.
     * @type {string}
     * @memberof ServiceCatalogIndexSource
     */
    'created_at': string;
    /**
     * An ISO-8604 timestamp representation of entity update date.
     * @type {string}
     * @memberof ServiceCatalogIndexSource
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<ServiceCatalogIndexSourceVersionsInner>}
     * @memberof ServiceCatalogIndexSource
     */
    'versions'?: Array<ServiceCatalogIndexSourceVersionsInner>;
}
/**
 * 
 * @export
 * @interface ServiceCatalogIndexSourceVersionsInner
 */
export interface ServiceCatalogIndexSourceVersionsInner {
    /**
     * The entity ID.
     * @type {string}
     * @memberof ServiceCatalogIndexSourceVersionsInner
     */
    'id': string;
    /**
     * An ISO-8604 timestamp representation of entity creation date.
     * @type {string}
     * @memberof ServiceCatalogIndexSourceVersionsInner
     */
    'created_at': string;
    /**
     * An ISO-8604 timestamp representation of entity update date.
     * @type {string}
     * @memberof ServiceCatalogIndexSourceVersionsInner
     */
    'updated_at': string;
    /**
     * the name of the service
     * @type {string}
     * @memberof ServiceCatalogIndexSourceVersionsInner
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCatalogIndexSourceVersionsInner
     */
    'publish_status': ServiceCatalogIndexSourceVersionsInnerPublishStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceCatalogIndexSourceVersionsInner
     */
    'deprecated': boolean;
    /**
     * The entity ID.
     * @type {string}
     * @memberof ServiceCatalogIndexSourceVersionsInner
     */
    'tracking_id': string;
}

export const ServiceCatalogIndexSourceVersionsInnerPublishStatusEnum = {
    Published: 'published',
    Unpublished: 'unpublished'
} as const;

export type ServiceCatalogIndexSourceVersionsInnerPublishStatusEnum = typeof ServiceCatalogIndexSourceVersionsInnerPublishStatusEnum[keyof typeof ServiceCatalogIndexSourceVersionsInnerPublishStatusEnum];

/**
 * 
 * @export
 * @interface StrikeThrough
 */
export interface StrikeThrough {
    /**
     * 
     * @type {string}
     * @memberof StrikeThrough
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface TableAlignments
 */
export interface TableAlignments {
    /**
     * 
     * @type {Array<AlignmentKind>}
     * @memberof TableAlignments
     */
    'alignments': Array<AlignmentKind>;
}
/**
 * 
 * @export
 * @interface TableBlock
 */
export interface TableBlock {
    /**
     * 
     * @type {string}
     * @memberof TableBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof TableBlock
     */
    'children'?: Array<AnyNode>;
    /**
     * 
     * @type {Array<AlignmentKind>}
     * @memberof TableBlock
     */
    'alignments': Array<AlignmentKind>;
}
/**
 * 
 * @export
 * @interface TableCellBlock
 */
export interface TableCellBlock {
    /**
     * 
     * @type {string}
     * @memberof TableCellBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof TableCellBlock
     */
    'children'?: Array<AnyNode>;
    /**
     * 
     * @type {AlignmentKind}
     * @memberof TableCellBlock
     */
    'alignment'?: AlignmentKind;
}
/**
 * 
 * @export
 * @interface TableCellBlockAllOf
 */
export interface TableCellBlockAllOf {
    /**
     * 
     * @type {AlignmentKind}
     * @memberof TableCellBlockAllOf
     */
    'alignment'?: AlignmentKind;
}
/**
 * 
 * @export
 * @interface TableHeaderBlock
 */
export interface TableHeaderBlock {
    /**
     * 
     * @type {string}
     * @memberof TableHeaderBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof TableHeaderBlock
     */
    'children'?: Array<AnyNode>;
    /**
     * 
     * @type {Array<AlignmentKind>}
     * @memberof TableHeaderBlock
     */
    'alignments': Array<AlignmentKind>;
}
/**
 * 
 * @export
 * @interface TableRowBlock
 */
export interface TableRowBlock {
    /**
     * 
     * @type {string}
     * @memberof TableRowBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof TableRowBlock
     */
    'children'?: Array<AnyNode>;
    /**
     * 
     * @type {Array<AlignmentKind>}
     * @memberof TableRowBlock
     */
    'alignments': Array<AlignmentKind>;
}
/**
 * 
 * @export
 * @interface TaskCheckbox
 */
export interface TaskCheckbox {
    /**
     * 
     * @type {string}
     * @memberof TaskCheckbox
     */
    'type': string;
    /**
     * State of the checkbox
     * @type {boolean}
     * @memberof TaskCheckbox
     */
    'checked': boolean;
}
/**
 * 
 * @export
 * @interface TaskCheckboxAllOf
 */
export interface TaskCheckboxAllOf {
    /**
     * State of the checkbox
     * @type {boolean}
     * @memberof TaskCheckboxAllOf
     */
    'checked': boolean;
}
/**
 * 
 * @export
 * @interface Text
 */
export interface Text {
    /**
     * 
     * @type {string}
     * @memberof Text
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof Text
     */
    'children'?: Array<AnyNode>;
    /**
     * 
     * @type {string}
     * @memberof Text
     */
    'text'?: string;
    /**
     * If this property is true the end of this block should be a carriage return and not concatenated to the next Text block. 
     * @type {boolean}
     * @memberof Text
     */
    'hardBreak'?: boolean;
    /**
     * If this property is true the end of this block should should be concatenated with a space caracter before the next block. This is the flag showing that the parsed markdown block was at the end of the line. 
     * @type {boolean}
     * @memberof Text
     */
    'softBreak'?: boolean;
}
/**
 * 
 * @export
 * @interface TextAllOf
 */
export interface TextAllOf {
    /**
     * 
     * @type {string}
     * @memberof TextAllOf
     */
    'text'?: string;
    /**
     * If this property is true the end of this block should be a carriage return and not concatenated to the next Text block. 
     * @type {boolean}
     * @memberof TextAllOf
     */
    'hardBreak'?: boolean;
    /**
     * If this property is true the end of this block should should be concatenated with a space caracter before the next block. This is the flag showing that the parsed markdown block was at the end of the line. 
     * @type {boolean}
     * @memberof TextAllOf
     */
    'softBreak'?: boolean;
}
/**
 * 
 * @export
 * @interface TextBlock
 */
export interface TextBlock {
    /**
     * 
     * @type {string}
     * @memberof TextBlock
     */
    'type': string;
    /**
     * List of children nodes of the current node
     * @type {Array<AnyNode>}
     * @memberof TextBlock
     */
    'children'?: Array<AnyNode>;
}
/**
 * 
 * @export
 * @interface UnauthorizedError
 */
export interface UnauthorizedError {
    /**
     * The HTTP status code of the error. Useful when passing the response body to child properties in a frontend UI. Must be returned as an integer. 
     * @type {number}
     * @memberof UnauthorizedError
     */
    'status': number;
    /**
     * A short, human-readable summary of the problem. It should not change between occurences of a problem, except for localization. Should be provided as \"Sentence case\" for direct use in the UI. 
     * @type {string}
     * @memberof UnauthorizedError
     */
    'title': string;
    /**
     * The error type.
     * @type {string}
     * @memberof UnauthorizedError
     */
    'type'?: string;
    /**
     * Used to return the correlation ID back to the user, in the format kong:trace:<correlation_id>. This helps us find the relevant logs when a customer reports an issue. 
     * @type {string}
     * @memberof UnauthorizedError
     */
    'instance': string;
    /**
     * A human readable explanation specific to this occurence of the problem. This field may contain request/entity data to help the user understand what went wrong. Enclose variable values in square brackets. Should be provided as \"Sentence case\" for direct use in the UI. 
     * @type {string}
     * @memberof UnauthorizedError
     */
    'detail': string;
}
/**
 * Payload required to update an application
 * @export
 * @interface UpdateApplicationPayload
 */
export interface UpdateApplicationPayload {
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationPayload
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationPayload
     */
    'reference_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationPayload
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationPayload
     */
    'redirect_uri'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCredentialPayload
 */
export interface UpdateCredentialPayload {
    /**
     * 
     * @type {string}
     * @memberof UpdateCredentialPayload
     */
    'display_name': string;
}

/**
 * AppRegApi - axios parameter creator
 * @export
 */
export const AppRegApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the application registration configuration of the given service
         * @summary Application registration Configuration
         * @param {string} id id of the service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationRegistrationConfiguration: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getApplicationRegistrationConfiguration', 'id', id)
            const localVarPath = `/api/v2/application-registrations/service-versions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppRegApi - functional programming interface
 * @export
 */
export const AppRegApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppRegApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the application registration configuration of the given service
         * @summary Application registration Configuration
         * @param {string} id id of the service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationRegistrationConfiguration(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationRegistrationConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationRegistrationConfiguration(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppRegApi - factory interface
 * @export
 */
export const AppRegApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppRegApiFp(configuration)
    return {
        /**
         * Returns the application registration configuration of the given service
         * @summary Application registration Configuration
         * @param {string} id id of the service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationRegistrationConfiguration(id: string, options?: any): AxiosPromise<ApplicationRegistrationConfiguration> {
            return localVarFp.getApplicationRegistrationConfiguration(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getApplicationRegistrationConfiguration operation in AppRegApi.
 * @export
 * @interface AppRegApiGetApplicationRegistrationConfigurationRequest
 */
export interface AppRegApiGetApplicationRegistrationConfigurationRequest {
    /**
     * id of the service version
     * @type {string}
     * @memberof AppRegApiGetApplicationRegistrationConfiguration
     */
    readonly id: string
}

/**
 * AppRegApi - object-oriented interface
 * @export
 * @class AppRegApi
 * @extends {BaseAPI}
 */
export class AppRegApi extends BaseAPI {
    /**
     * Returns the application registration configuration of the given service
     * @summary Application registration Configuration
     * @param {AppRegApiGetApplicationRegistrationConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppRegApi
     */
    public getApplicationRegistrationConfiguration(requestParameters: AppRegApiGetApplicationRegistrationConfigurationRequest, options?: AxiosRequestConfig) {
        return AppRegApiFp(this.configuration).getApplicationRegistrationConfiguration(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows the developer to create an application
         * @summary Create Application
         * @param {CreateApplicationPayload} createApplicationPayload Create an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (createApplicationPayload: CreateApplicationPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createApplicationPayload' is not null or undefined
            assertParamExists('createApplication', 'createApplicationPayload', createApplicationPayload)
            const localVarPath = `/api/v2/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApplicationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to delete an application they own
         * @summary Delete Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplication', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to list applications
         * @summary Get many applications
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyApplications: async (page?: PageParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to get an application
         * @summary Get one Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getOneApplication', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to reset the client secret for an application they own
         * @summary refresh token
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshApplicationToken: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('refreshApplicationToken', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/refresh-token`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to update an application they own
         * @summary Update Application
         * @param {string} applicationId Id of the targeted application
         * @param {UpdateApplicationPayload} updateApplicationPayload Update an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication: async (applicationId: string, updateApplicationPayload: UpdateApplicationPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateApplication', 'applicationId', applicationId)
            // verify required parameter 'updateApplicationPayload' is not null or undefined
            assertParamExists('updateApplication', 'updateApplicationPayload', updateApplicationPayload)
            const localVarPath = `/api/v2/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateApplicationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows the developer to create an application
         * @summary Create Application
         * @param {CreateApplicationPayload} createApplicationPayload Create an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(createApplicationPayload: CreateApplicationPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCreationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(createApplicationPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to delete an application they own
         * @summary Delete Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to list applications
         * @summary Get many applications
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManyApplications(page?: PageParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetManyApplicationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManyApplications(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to get an application
         * @summary Get one Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOneApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOneApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to reset the client secret for an application they own
         * @summary refresh token
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshApplicationToken(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshApplicationToken(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to update an application they own
         * @summary Update Application
         * @param {string} applicationId Id of the targeted application
         * @param {UpdateApplicationPayload} updateApplicationPayload Update an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplication(applicationId: string, updateApplicationPayload: UpdateApplicationPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplication(applicationId, updateApplicationPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * This endpoint allows the developer to create an application
         * @summary Create Application
         * @param {CreateApplicationPayload} createApplicationPayload Create an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(createApplicationPayload: CreateApplicationPayload, options?: any): AxiosPromise<ApplicationCreationResponse> {
            return localVarFp.createApplication(createApplicationPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to delete an application they own
         * @summary Delete Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to list applications
         * @summary Get many applications
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyApplications(page?: PageParameters, options?: any): AxiosPromise<GetManyApplicationsResponse> {
            return localVarFp.getManyApplications(page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to get an application
         * @summary Get one Application
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneApplication(applicationId: string, options?: any): AxiosPromise<GetApplicationResponse> {
            return localVarFp.getOneApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to reset the client secret for an application they own
         * @summary refresh token
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshApplicationToken(applicationId: string, options?: any): AxiosPromise<RefreshTokenResponse> {
            return localVarFp.refreshApplicationToken(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to update an application they own
         * @summary Update Application
         * @param {string} applicationId Id of the targeted application
         * @param {UpdateApplicationPayload} updateApplicationPayload Update an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication(applicationId: string, updateApplicationPayload: UpdateApplicationPayload, options?: any): AxiosPromise<ApplicationUpdateResponse> {
            return localVarFp.updateApplication(applicationId, updateApplicationPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiCreateApplicationRequest
 */
export interface ApplicationsApiCreateApplicationRequest {
    /**
     * Create an application
     * @type {CreateApplicationPayload}
     * @memberof ApplicationsApiCreateApplication
     */
    readonly createApplicationPayload: CreateApplicationPayload
}

/**
 * Request parameters for deleteApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiDeleteApplicationRequest
 */
export interface ApplicationsApiDeleteApplicationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof ApplicationsApiDeleteApplication
     */
    readonly applicationId: string
}

/**
 * Request parameters for getManyApplications operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiGetManyApplicationsRequest
 */
export interface ApplicationsApiGetManyApplicationsRequest {
    /**
     * Determines which page of search results to retrieve.
     * @type {PageParameters}
     * @memberof ApplicationsApiGetManyApplications
     */
    readonly page?: PageParameters
}

/**
 * Request parameters for getOneApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiGetOneApplicationRequest
 */
export interface ApplicationsApiGetOneApplicationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof ApplicationsApiGetOneApplication
     */
    readonly applicationId: string
}

/**
 * Request parameters for refreshApplicationToken operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiRefreshApplicationTokenRequest
 */
export interface ApplicationsApiRefreshApplicationTokenRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof ApplicationsApiRefreshApplicationToken
     */
    readonly applicationId: string
}

/**
 * Request parameters for updateApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiUpdateApplicationRequest
 */
export interface ApplicationsApiUpdateApplicationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof ApplicationsApiUpdateApplication
     */
    readonly applicationId: string

    /**
     * Update an application
     * @type {UpdateApplicationPayload}
     * @memberof ApplicationsApiUpdateApplication
     */
    readonly updateApplicationPayload: UpdateApplicationPayload
}

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * This endpoint allows the developer to create an application
     * @summary Create Application
     * @param {ApplicationsApiCreateApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public createApplication(requestParameters: ApplicationsApiCreateApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).createApplication(requestParameters.createApplicationPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to delete an application they own
     * @summary Delete Application
     * @param {ApplicationsApiDeleteApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public deleteApplication(requestParameters: ApplicationsApiDeleteApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).deleteApplication(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to list applications
     * @summary Get many applications
     * @param {ApplicationsApiGetManyApplicationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getManyApplications(requestParameters: ApplicationsApiGetManyApplicationsRequest = {}, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getManyApplications(requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to get an application
     * @summary Get one Application
     * @param {ApplicationsApiGetOneApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getOneApplication(requestParameters: ApplicationsApiGetOneApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getOneApplication(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to reset the client secret for an application they own
     * @summary refresh token
     * @param {ApplicationsApiRefreshApplicationTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public refreshApplicationToken(requestParameters: ApplicationsApiRefreshApplicationTokenRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).refreshApplicationToken(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to update an application they own
     * @summary Update Application
     * @param {ApplicationsApiUpdateApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public updateApplication(requestParameters: ApplicationsApiUpdateApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).updateApplication(requestParameters.applicationId, requestParameters.updateApplicationPayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CredentialsApi - axios parameter creator
 * @export
 */
export const CredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows the developer to create a credential for an application they own
         * @summary Post Credential
         * @param {string} applicationId Id of the targeted application
         * @param {CreateCredentialPayload} [createCredentialPayload] Create a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredential: async (applicationId: string, createCredentialPayload?: CreateCredentialPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createCredential', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/credentials`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCredentialPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to delete a credential for an application they own
         * @summary Delete Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential: async (applicationId: string, credentialId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteCredential', 'applicationId', applicationId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('deleteCredential', 'credentialId', credentialId)
            const localVarPath = `/api/v2/applications/{applicationId}/credentials/{credentialId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to list the credentials for an application they own
         * @summary Get Many credentials
         * @param {string} applicationId Id of the targeted application
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyCredentials: async (applicationId: string, page?: PageParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getManyCredentials', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/credentials`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to reset the client secret for an application they own
         * @summary refresh token
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshApplicationToken: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('refreshApplicationToken', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/refresh-token`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows the developer to update a credential for an application they own
         * @summary Update Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {UpdateCredentialPayload} updateCredentialPayload Update a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential: async (applicationId: string, credentialId: string, updateCredentialPayload: UpdateCredentialPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateCredential', 'applicationId', applicationId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('updateCredential', 'credentialId', credentialId)
            // verify required parameter 'updateCredentialPayload' is not null or undefined
            assertParamExists('updateCredential', 'updateCredentialPayload', updateCredentialPayload)
            const localVarPath = `/api/v2/applications/{applicationId}/credentials/{credentialId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCredentialPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CredentialsApi - functional programming interface
 * @export
 */
export const CredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows the developer to create a credential for an application they own
         * @summary Post Credential
         * @param {string} applicationId Id of the targeted application
         * @param {CreateCredentialPayload} [createCredentialPayload] Create a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredential(applicationId: string, createCredentialPayload?: CreateCredentialPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialCreationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredential(applicationId, createCredentialPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to delete a credential for an application they own
         * @summary Delete Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCredential(applicationId: string, credentialId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCredential(applicationId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to list the credentials for an application they own
         * @summary Get Many credentials
         * @param {string} applicationId Id of the targeted application
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManyCredentials(applicationId: string, page?: PageParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCredentialsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManyCredentials(applicationId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to reset the client secret for an application they own
         * @summary refresh token
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshApplicationToken(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshApplicationToken(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows the developer to update a credential for an application they own
         * @summary Update Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {UpdateCredentialPayload} updateCredentialPayload Update a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCredential(applicationId: string, credentialId: string, updateCredentialPayload: UpdateCredentialPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCredential(applicationId, credentialId, updateCredentialPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CredentialsApi - factory interface
 * @export
 */
export const CredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CredentialsApiFp(configuration)
    return {
        /**
         * This endpoint allows the developer to create a credential for an application they own
         * @summary Post Credential
         * @param {string} applicationId Id of the targeted application
         * @param {CreateCredentialPayload} [createCredentialPayload] Create a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredential(applicationId: string, createCredentialPayload?: CreateCredentialPayload, options?: any): AxiosPromise<CredentialCreationResponse> {
            return localVarFp.createCredential(applicationId, createCredentialPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to delete a credential for an application they own
         * @summary Delete Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(applicationId: string, credentialId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCredential(applicationId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to list the credentials for an application they own
         * @summary Get Many credentials
         * @param {string} applicationId Id of the targeted application
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyCredentials(applicationId: string, page?: PageParameters, options?: any): AxiosPromise<GetCredentialsResponse> {
            return localVarFp.getManyCredentials(applicationId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to reset the client secret for an application they own
         * @summary refresh token
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshApplicationToken(applicationId: string, options?: any): AxiosPromise<RefreshTokenResponse> {
            return localVarFp.refreshApplicationToken(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows the developer to update a credential for an application they own
         * @summary Update Credential
         * @param {string} applicationId Id of the targeted application
         * @param {string} credentialId Id of the targeted credential
         * @param {UpdateCredentialPayload} updateCredentialPayload Update a credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(applicationId: string, credentialId: string, updateCredentialPayload: UpdateCredentialPayload, options?: any): AxiosPromise<void> {
            return localVarFp.updateCredential(applicationId, credentialId, updateCredentialPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCredential operation in CredentialsApi.
 * @export
 * @interface CredentialsApiCreateCredentialRequest
 */
export interface CredentialsApiCreateCredentialRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiCreateCredential
     */
    readonly applicationId: string

    /**
     * Create a credential
     * @type {CreateCredentialPayload}
     * @memberof CredentialsApiCreateCredential
     */
    readonly createCredentialPayload?: CreateCredentialPayload
}

/**
 * Request parameters for deleteCredential operation in CredentialsApi.
 * @export
 * @interface CredentialsApiDeleteCredentialRequest
 */
export interface CredentialsApiDeleteCredentialRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiDeleteCredential
     */
    readonly applicationId: string

    /**
     * Id of the targeted credential
     * @type {string}
     * @memberof CredentialsApiDeleteCredential
     */
    readonly credentialId: string
}

/**
 * Request parameters for getManyCredentials operation in CredentialsApi.
 * @export
 * @interface CredentialsApiGetManyCredentialsRequest
 */
export interface CredentialsApiGetManyCredentialsRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiGetManyCredentials
     */
    readonly applicationId: string

    /**
     * Determines which page of search results to retrieve.
     * @type {PageParameters}
     * @memberof CredentialsApiGetManyCredentials
     */
    readonly page?: PageParameters
}

/**
 * Request parameters for refreshApplicationToken operation in CredentialsApi.
 * @export
 * @interface CredentialsApiRefreshApplicationTokenRequest
 */
export interface CredentialsApiRefreshApplicationTokenRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiRefreshApplicationToken
     */
    readonly applicationId: string
}

/**
 * Request parameters for updateCredential operation in CredentialsApi.
 * @export
 * @interface CredentialsApiUpdateCredentialRequest
 */
export interface CredentialsApiUpdateCredentialRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof CredentialsApiUpdateCredential
     */
    readonly applicationId: string

    /**
     * Id of the targeted credential
     * @type {string}
     * @memberof CredentialsApiUpdateCredential
     */
    readonly credentialId: string

    /**
     * Update a credential
     * @type {UpdateCredentialPayload}
     * @memberof CredentialsApiUpdateCredential
     */
    readonly updateCredentialPayload: UpdateCredentialPayload
}

/**
 * CredentialsApi - object-oriented interface
 * @export
 * @class CredentialsApi
 * @extends {BaseAPI}
 */
export class CredentialsApi extends BaseAPI {
    /**
     * This endpoint allows the developer to create a credential for an application they own
     * @summary Post Credential
     * @param {CredentialsApiCreateCredentialRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public createCredential(requestParameters: CredentialsApiCreateCredentialRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).createCredential(requestParameters.applicationId, requestParameters.createCredentialPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to delete a credential for an application they own
     * @summary Delete Credential
     * @param {CredentialsApiDeleteCredentialRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public deleteCredential(requestParameters: CredentialsApiDeleteCredentialRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).deleteCredential(requestParameters.applicationId, requestParameters.credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to list the credentials for an application they own
     * @summary Get Many credentials
     * @param {CredentialsApiGetManyCredentialsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public getManyCredentials(requestParameters: CredentialsApiGetManyCredentialsRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).getManyCredentials(requestParameters.applicationId, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to reset the client secret for an application they own
     * @summary refresh token
     * @param {CredentialsApiRefreshApplicationTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public refreshApplicationToken(requestParameters: CredentialsApiRefreshApplicationTokenRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).refreshApplicationToken(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows the developer to update a credential for an application they own
     * @summary Update Credential
     * @param {CredentialsApiUpdateCredentialRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public updateCredential(requestParameters: CredentialsApiUpdateCredentialRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).updateCredential(requestParameters.applicationId, requestParameters.credentialId, requestParameters.updateCredentialPayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeveloperApi - axios parameter creator
 * @export
 */
export const DeveloperApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Register to the developer portal
         * @summary Register
         * @param {RegisterPayload} [registerPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerPayload?: RegisterPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/developer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the password reset flow for the desired account. An email will be sent to the email address to initiate the password reset flow. 
         * @summary Password Reset
         * @param {ResetPasswordPayload} [resetPasswordPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetPasswordPayload?: ResetPasswordPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/developer/password-reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeveloperApi - functional programming interface
 * @export
 */
export const DeveloperApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeveloperApiAxiosParamCreator(configuration)
    return {
        /**
         * Register to the developer portal
         * @summary Register
         * @param {RegisterPayload} [registerPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerPayload?: RegisterPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Starts the password reset flow for the desired account. An email will be sent to the email address to initiate the password reset flow. 
         * @summary Password Reset
         * @param {ResetPasswordPayload} [resetPasswordPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetPasswordPayload?: ResetPasswordPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetPasswordPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeveloperApi - factory interface
 * @export
 */
export const DeveloperApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeveloperApiFp(configuration)
    return {
        /**
         * Register to the developer portal
         * @summary Register
         * @param {RegisterPayload} [registerPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerPayload?: RegisterPayload, options?: any): AxiosPromise<void> {
            return localVarFp.register(registerPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the password reset flow for the desired account. An email will be sent to the email address to initiate the password reset flow. 
         * @summary Password Reset
         * @param {ResetPasswordPayload} [resetPasswordPayload] Developer registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(resetPasswordPayload?: ResetPasswordPayload, options?: any): AxiosPromise<void> {
            return localVarFp.resetPassword(resetPasswordPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for register operation in DeveloperApi.
 * @export
 * @interface DeveloperApiRegisterRequest
 */
export interface DeveloperApiRegisterRequest {
    /**
     * Developer registration
     * @type {RegisterPayload}
     * @memberof DeveloperApiRegister
     */
    readonly registerPayload?: RegisterPayload
}

/**
 * Request parameters for resetPassword operation in DeveloperApi.
 * @export
 * @interface DeveloperApiResetPasswordRequest
 */
export interface DeveloperApiResetPasswordRequest {
    /**
     * Developer registration
     * @type {ResetPasswordPayload}
     * @memberof DeveloperApiResetPassword
     */
    readonly resetPasswordPayload?: ResetPasswordPayload
}

/**
 * DeveloperApi - object-oriented interface
 * @export
 * @class DeveloperApi
 * @extends {BaseAPI}
 */
export class DeveloperApi extends BaseAPI {
    /**
     * Register to the developer portal
     * @summary Register
     * @param {DeveloperApiRegisterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperApi
     */
    public register(requestParameters: DeveloperApiRegisterRequest = {}, options?: AxiosRequestConfig) {
        return DeveloperApiFp(this.configuration).register(requestParameters.registerPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts the password reset flow for the desired account. An email will be sent to the email address to initiate the password reset flow. 
     * @summary Password Reset
     * @param {DeveloperApiResetPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperApi
     */
    public resetPassword(requestParameters: DeveloperApiResetPasswordRequest = {}, options?: AxiosRequestConfig) {
        return DeveloperApiFp(this.configuration).resetPassword(requestParameters.resetPasswordPayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentationApi - axios parameter creator
 * @export
 */
export const DocumentationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the specified document from the product\'s document tree
         * @summary Get one product document
         * @param {string} productId Id of the product
         * @param {string} documentId Id of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductDocument: async (productId: string, documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductDocument', 'productId', productId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getProductDocument', 'documentId', documentId)
            const localVarPath = `/api/v2/products/{productId}/documents/{documentId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the entire documentation tree of a product
         * @summary Get product document tree
         * @param {string} productId Id of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductDocumentTree: async (productId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductDocumentTree', 'productId', productId)
            const localVarPath = `/api/v2/products/{productId}/document-tree`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentationApi - functional programming interface
 * @export
 */
export const DocumentationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentationApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the specified document from the product\'s document tree
         * @summary Get one product document
         * @param {string} productId Id of the product
         * @param {string} documentId Id of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductDocument(productId: string, documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductDocument(productId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return the entire documentation tree of a product
         * @summary Get product document tree
         * @param {string} productId Id of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductDocumentTree(productId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDocumentTree>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductDocumentTree(productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentationApi - factory interface
 * @export
 */
export const DocumentationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentationApiFp(configuration)
    return {
        /**
         * Returns the specified document from the product\'s document tree
         * @summary Get one product document
         * @param {string} productId Id of the product
         * @param {string} documentId Id of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductDocument(productId: string, documentId: string, options?: any): AxiosPromise<ProductDocument> {
            return localVarFp.getProductDocument(productId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the entire documentation tree of a product
         * @summary Get product document tree
         * @param {string} productId Id of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductDocumentTree(productId: string, options?: any): AxiosPromise<ProductDocumentTree> {
            return localVarFp.getProductDocumentTree(productId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getProductDocument operation in DocumentationApi.
 * @export
 * @interface DocumentationApiGetProductDocumentRequest
 */
export interface DocumentationApiGetProductDocumentRequest {
    /**
     * Id of the product
     * @type {string}
     * @memberof DocumentationApiGetProductDocument
     */
    readonly productId: string

    /**
     * Id of the document
     * @type {string}
     * @memberof DocumentationApiGetProductDocument
     */
    readonly documentId: string
}

/**
 * Request parameters for getProductDocumentTree operation in DocumentationApi.
 * @export
 * @interface DocumentationApiGetProductDocumentTreeRequest
 */
export interface DocumentationApiGetProductDocumentTreeRequest {
    /**
     * Id of the product
     * @type {string}
     * @memberof DocumentationApiGetProductDocumentTree
     */
    readonly productId: string
}

/**
 * DocumentationApi - object-oriented interface
 * @export
 * @class DocumentationApi
 * @extends {BaseAPI}
 */
export class DocumentationApi extends BaseAPI {
    /**
     * Returns the specified document from the product\'s document tree
     * @summary Get one product document
     * @param {DocumentationApiGetProductDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentationApi
     */
    public getProductDocument(requestParameters: DocumentationApiGetProductDocumentRequest, options?: AxiosRequestConfig) {
        return DocumentationApiFp(this.configuration).getProductDocument(requestParameters.productId, requestParameters.documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the entire documentation tree of a product
     * @summary Get product document tree
     * @param {DocumentationApiGetProductDocumentTreeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentationApi
     */
    public getProductDocumentTree(requestParameters: DocumentationApiGetProductDocumentTreeRequest, options?: AxiosRequestConfig) {
        return DocumentationApiFp(this.configuration).getProductDocumentTree(requestParameters.productId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PortalApi - axios parameter creator
 * @export
 */
export const PortalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * appearance of the portal
         * @summary portal appearance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalAppearance: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/portal/appearance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cover banner for the developer portal
         * @summary catalog cover
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalCatalogCover: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/portal/stylesheet/catalog-cover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * return the portal context
         * @summary get portal context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalContext: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/portal/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logo of the developer portal
         * @summary portal logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalLogo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/portal/stylesheet/logo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortalApi - functional programming interface
 * @export
 */
export const PortalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortalApiAxiosParamCreator(configuration)
    return {
        /**
         * appearance of the portal
         * @summary portal appearance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalAppearance(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortalAppearance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalAppearance(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cover banner for the developer portal
         * @summary catalog cover
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalCatalogCover(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalCatalogCover(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * return the portal context
         * @summary get portal context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalContext(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortalContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalContext(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Logo of the developer portal
         * @summary portal logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalLogo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalLogo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PortalApi - factory interface
 * @export
 */
export const PortalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortalApiFp(configuration)
    return {
        /**
         * appearance of the portal
         * @summary portal appearance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalAppearance(options?: any): AxiosPromise<PortalAppearance> {
            return localVarFp.getPortalAppearance(options).then((request) => request(axios, basePath));
        },
        /**
         * Cover banner for the developer portal
         * @summary catalog cover
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalCatalogCover(options?: any): AxiosPromise<File> {
            return localVarFp.getPortalCatalogCover(options).then((request) => request(axios, basePath));
        },
        /**
         * return the portal context
         * @summary get portal context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalContext(options?: any): AxiosPromise<PortalContext> {
            return localVarFp.getPortalContext(options).then((request) => request(axios, basePath));
        },
        /**
         * Logo of the developer portal
         * @summary portal logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalLogo(options?: any): AxiosPromise<File> {
            return localVarFp.getPortalLogo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortalApi - object-oriented interface
 * @export
 * @class PortalApi
 * @extends {BaseAPI}
 */
export class PortalApi extends BaseAPI {
    /**
     * appearance of the portal
     * @summary portal appearance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalApi
     */
    public getPortalAppearance(options?: AxiosRequestConfig) {
        return PortalApiFp(this.configuration).getPortalAppearance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cover banner for the developer portal
     * @summary catalog cover
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalApi
     */
    public getPortalCatalogCover(options?: AxiosRequestConfig) {
        return PortalApiFp(this.configuration).getPortalCatalogCover(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * return the portal context
     * @summary get portal context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalApi
     */
    public getPortalContext(options?: AxiosRequestConfig) {
        return PortalApiFp(this.configuration).getPortalContext(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logo of the developer portal
     * @summary portal logo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalApi
     */
    public getPortalLogo(options?: AxiosRequestConfig) {
        return PortalApiFp(this.configuration).getPortalLogo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a paginated list of published API Products, each with their versions and documents
         * @summary Get page of products
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyProducts: async (page?: PageParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the given published product, with its versions attached
         * @summary Get a product
         * @param {string} productId Id of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (productId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProduct', 'productId', productId)
            const localVarPath = `/api/v2/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a paginated list of published API Products, each with their versions and documents
         * @summary Get page of products
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManyProducts(page?: PageParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductListPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManyProducts(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the given published product, with its versions attached
         * @summary Get a product
         * @param {string} productId Id of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(productId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * Returns a paginated list of published API Products, each with their versions and documents
         * @summary Get page of products
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyProducts(page?: PageParameters, options?: any): AxiosPromise<ProductListPage> {
            return localVarFp.getManyProducts(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the given published product, with its versions attached
         * @summary Get a product
         * @param {string} productId Id of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(productId: string, options?: any): AxiosPromise<Product> {
            return localVarFp.getProduct(productId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getManyProducts operation in ProductsApi.
 * @export
 * @interface ProductsApiGetManyProductsRequest
 */
export interface ProductsApiGetManyProductsRequest {
    /**
     * Determines which page of search results to retrieve.
     * @type {PageParameters}
     * @memberof ProductsApiGetManyProducts
     */
    readonly page?: PageParameters
}

/**
 * Request parameters for getProduct operation in ProductsApi.
 * @export
 * @interface ProductsApiGetProductRequest
 */
export interface ProductsApiGetProductRequest {
    /**
     * Id of the product
     * @type {string}
     * @memberof ProductsApiGetProduct
     */
    readonly productId: string
}

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Returns a paginated list of published API Products, each with their versions and documents
     * @summary Get page of products
     * @param {ProductsApiGetManyProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getManyProducts(requestParameters: ProductsApiGetManyProductsRequest = {}, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getManyProducts(requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the given published product, with its versions attached
     * @summary Get a product
     * @param {ProductsApiGetProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProduct(requestParameters: ProductsApiGetProductRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProduct(requestParameters.productId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegistrationsApi - axios parameter creator
 * @export
 */
export const RegistrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint registers an application for a service
         * @summary Register an application for a service
         * @param {string} applicationId Id of the targeted application
         * @param {CreateRegistrationPayload} createRegistrationPayload Create an application registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationRegistration: async (applicationId: string, createRegistrationPayload: CreateRegistrationPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationRegistration', 'applicationId', applicationId)
            // verify required parameter 'createRegistrationPayload' is not null or undefined
            assertParamExists('createApplicationRegistration', 'createRegistrationPayload', createRegistrationPayload)
            const localVarPath = `/api/v2/applications/{applicationId}/registrations`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRegistrationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint unregister an application for a service version
         * @summary Delete an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Id of the targeted registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationRegistration: async (applicationId: string, registrationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationRegistration', 'applicationId', applicationId)
            // verify required parameter 'registrationId' is not null or undefined
            assertParamExists('deleteApplicationRegistration', 'registrationId', registrationId)
            const localVarPath = `/api/v2/applications/{applicationId}/registrations/{registrationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"registrationId"}}`, encodeURIComponent(String(registrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint lists service registrations for an application
         * @summary Get application registrations
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyApplicationRegistrations: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getManyApplicationRegistrations', 'applicationId', applicationId)
            const localVarPath = `/api/v2/applications/{applicationId}/registrations`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves the specified service registration for an application
         * @summary Get an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Id of the targeted registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneApplicationRegistration: async (applicationId: string, registrationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getOneApplicationRegistration', 'applicationId', applicationId)
            // verify required parameter 'registrationId' is not null or undefined
            assertParamExists('getOneApplicationRegistration', 'registrationId', registrationId)
            const localVarPath = `/api/v2/applications/{applicationId}/registrations/{registrationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"registrationId"}}`, encodeURIComponent(String(registrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistrationsApi - functional programming interface
 * @export
 */
export const RegistrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint registers an application for a service
         * @summary Register an application for a service
         * @param {string} applicationId Id of the targeted application
         * @param {CreateRegistrationPayload} createRegistrationPayload Create an application registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationRegistration(applicationId: string, createRegistrationPayload: CreateRegistrationPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRegistrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationRegistration(applicationId, createRegistrationPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint unregister an application for a service version
         * @summary Delete an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Id of the targeted registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationRegistration(applicationId: string, registrationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationRegistration(applicationId, registrationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint lists service registrations for an application
         * @summary Get application registrations
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManyApplicationRegistrations(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetManyRegistrationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManyApplicationRegistrations(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint retrieves the specified service registration for an application
         * @summary Get an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Id of the targeted registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOneApplicationRegistration(applicationId: string, registrationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRegistrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOneApplicationRegistration(applicationId, registrationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegistrationsApi - factory interface
 * @export
 */
export const RegistrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistrationsApiFp(configuration)
    return {
        /**
         * This endpoint registers an application for a service
         * @summary Register an application for a service
         * @param {string} applicationId Id of the targeted application
         * @param {CreateRegistrationPayload} createRegistrationPayload Create an application registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationRegistration(applicationId: string, createRegistrationPayload: CreateRegistrationPayload, options?: any): AxiosPromise<GetRegistrationResponse> {
            return localVarFp.createApplicationRegistration(applicationId, createRegistrationPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint unregister an application for a service version
         * @summary Delete an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Id of the targeted registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationRegistration(applicationId: string, registrationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationRegistration(applicationId, registrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint lists service registrations for an application
         * @summary Get application registrations
         * @param {string} applicationId Id of the targeted application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyApplicationRegistrations(applicationId: string, options?: any): AxiosPromise<GetManyRegistrationsResponse> {
            return localVarFp.getManyApplicationRegistrations(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves the specified service registration for an application
         * @summary Get an application registration
         * @param {string} applicationId Id of the targeted application
         * @param {string} registrationId Id of the targeted registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneApplicationRegistration(applicationId: string, registrationId: string, options?: any): AxiosPromise<GetRegistrationResponse> {
            return localVarFp.getOneApplicationRegistration(applicationId, registrationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createApplicationRegistration operation in RegistrationsApi.
 * @export
 * @interface RegistrationsApiCreateApplicationRegistrationRequest
 */
export interface RegistrationsApiCreateApplicationRegistrationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof RegistrationsApiCreateApplicationRegistration
     */
    readonly applicationId: string

    /**
     * Create an application registration
     * @type {CreateRegistrationPayload}
     * @memberof RegistrationsApiCreateApplicationRegistration
     */
    readonly createRegistrationPayload: CreateRegistrationPayload
}

/**
 * Request parameters for deleteApplicationRegistration operation in RegistrationsApi.
 * @export
 * @interface RegistrationsApiDeleteApplicationRegistrationRequest
 */
export interface RegistrationsApiDeleteApplicationRegistrationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof RegistrationsApiDeleteApplicationRegistration
     */
    readonly applicationId: string

    /**
     * Id of the targeted registration
     * @type {string}
     * @memberof RegistrationsApiDeleteApplicationRegistration
     */
    readonly registrationId: string
}

/**
 * Request parameters for getManyApplicationRegistrations operation in RegistrationsApi.
 * @export
 * @interface RegistrationsApiGetManyApplicationRegistrationsRequest
 */
export interface RegistrationsApiGetManyApplicationRegistrationsRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof RegistrationsApiGetManyApplicationRegistrations
     */
    readonly applicationId: string
}

/**
 * Request parameters for getOneApplicationRegistration operation in RegistrationsApi.
 * @export
 * @interface RegistrationsApiGetOneApplicationRegistrationRequest
 */
export interface RegistrationsApiGetOneApplicationRegistrationRequest {
    /**
     * Id of the targeted application
     * @type {string}
     * @memberof RegistrationsApiGetOneApplicationRegistration
     */
    readonly applicationId: string

    /**
     * Id of the targeted registration
     * @type {string}
     * @memberof RegistrationsApiGetOneApplicationRegistration
     */
    readonly registrationId: string
}

/**
 * RegistrationsApi - object-oriented interface
 * @export
 * @class RegistrationsApi
 * @extends {BaseAPI}
 */
export class RegistrationsApi extends BaseAPI {
    /**
     * This endpoint registers an application for a service
     * @summary Register an application for a service
     * @param {RegistrationsApiCreateApplicationRegistrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationsApi
     */
    public createApplicationRegistration(requestParameters: RegistrationsApiCreateApplicationRegistrationRequest, options?: AxiosRequestConfig) {
        return RegistrationsApiFp(this.configuration).createApplicationRegistration(requestParameters.applicationId, requestParameters.createRegistrationPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint unregister an application for a service version
     * @summary Delete an application registration
     * @param {RegistrationsApiDeleteApplicationRegistrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationsApi
     */
    public deleteApplicationRegistration(requestParameters: RegistrationsApiDeleteApplicationRegistrationRequest, options?: AxiosRequestConfig) {
        return RegistrationsApiFp(this.configuration).deleteApplicationRegistration(requestParameters.applicationId, requestParameters.registrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint lists service registrations for an application
     * @summary Get application registrations
     * @param {RegistrationsApiGetManyApplicationRegistrationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationsApi
     */
    public getManyApplicationRegistrations(requestParameters: RegistrationsApiGetManyApplicationRegistrationsRequest, options?: AxiosRequestConfig) {
        return RegistrationsApiFp(this.configuration).getManyApplicationRegistrations(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves the specified service registration for an application
     * @summary Get an application registration
     * @param {RegistrationsApiGetOneApplicationRegistrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationsApi
     */
    public getOneApplicationRegistration(requestParameters: RegistrationsApiGetOneApplicationRegistrationRequest, options?: AxiosRequestConfig) {
        return RegistrationsApiFp(this.configuration).getOneApplicationRegistration(requestParameters.applicationId, requestParameters.registrationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns paginated search results from the specified entities with the given search parameters.
         * @summary Search Portal Entities
         * @param {SearchIndicesParameters} indices Determines which entity sets to search
         * @param {SearchParameters} [search] Determines how to filter search results
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPortalEntities: async (indices: SearchIndicesParameters, search?: SearchParameters, page?: PageParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indices' is not null or undefined
            assertParamExists('searchPortalEntities', 'indices', indices)
            const localVarPath = `/api/v2/search/{indices}`
                .replace(`{${"indices"}}`, encodeURIComponent(String(indices)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns paginated search results from the specified entities with the given search parameters.
         * @summary Search Portal Entities
         * @param {SearchIndicesParameters} indices Determines which entity sets to search
         * @param {SearchParameters} [search] Determines how to filter search results
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPortalEntities(indices: SearchIndicesParameters, search?: SearchParameters, page?: PageParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPortalEntities(indices, search, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Returns paginated search results from the specified entities with the given search parameters.
         * @summary Search Portal Entities
         * @param {SearchIndicesParameters} indices Determines which entity sets to search
         * @param {SearchParameters} [search] Determines how to filter search results
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPortalEntities(indices: SearchIndicesParameters, search?: SearchParameters, page?: PageParameters, options?: any): AxiosPromise<SearchResults> {
            return localVarFp.searchPortalEntities(indices, search, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for searchPortalEntities operation in SearchApi.
 * @export
 * @interface SearchApiSearchPortalEntitiesRequest
 */
export interface SearchApiSearchPortalEntitiesRequest {
    /**
     * Determines which entity sets to search
     * @type {SearchIndicesParameters}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly indices: SearchIndicesParameters

    /**
     * Determines how to filter search results
     * @type {SearchParameters}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly search?: SearchParameters

    /**
     * Determines which page of search results to retrieve.
     * @type {PageParameters}
     * @memberof SearchApiSearchPortalEntities
     */
    readonly page?: PageParameters
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Returns paginated search results from the specified entities with the given search parameters.
     * @summary Search Portal Entities
     * @param {SearchApiSearchPortalEntitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchPortalEntities(requestParameters: SearchApiSearchPortalEntitiesRequest, options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchPortalEntities(requestParameters.indices, requestParameters.search, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VersionsApi - axios parameter creator
 * @export
 */
export const VersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns paginated list of versions of a given product
         * @summary Get page of product versions
         * @param {string} productId Id of the product
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyProductVersions: async (productId: string, page?: PageParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getManyProductVersions', 'productId', productId)
            const localVarPath = `/api/v2/products/{productId}/versions`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return given product version
         * @summary Get product version
         * @param {string} productId Id of the product
         * @param {string} versionId Id of the product version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersion: async (productId: string, versionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductVersion', 'productId', productId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getProductVersion', 'versionId', versionId)
            const localVarPath = `/api/v2/products/{productId}/versions/{versionId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the OpenAPI specification document attached to given product version
         * @summary Get OpenAPI spec for product version
         * @param {string} productId Id of the product
         * @param {string} versionId Id of the product version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersionSpec: async (productId: string, versionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductVersionSpec', 'productId', productId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getProductVersionSpec', 'versionId', versionId)
            const localVarPath = `/api/v2/products/{productId}/versions/{versionId}/spec`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of operations used in the OpenAPI specefication document attached to given product version
         * @summary Get operations in version spec
         * @param {string} productId Id of the product
         * @param {string} versionId Id of the product version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersionSpecOperations: async (productId: string, versionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductVersionSpecOperations', 'productId', productId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getProductVersionSpecOperations', 'versionId', versionId)
            const localVarPath = `/api/v2/products/{productId}/versions/{versionId}/operations`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication portalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionsApi - functional programming interface
 * @export
 */
export const VersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns paginated list of versions of a given product
         * @summary Get page of product versions
         * @param {string} productId Id of the product
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManyProductVersions(productId: string, page?: PageParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVersionListPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManyProductVersions(productId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return given product version
         * @summary Get product version
         * @param {string} productId Id of the product
         * @param {string} versionId Id of the product version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductVersion(productId: string, versionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductVersion(productId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the OpenAPI specification document attached to given product version
         * @summary Get OpenAPI spec for product version
         * @param {string} productId Id of the product
         * @param {string} versionId Id of the product version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductVersionSpec(productId: string, versionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductVersionSpec(productId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list of operations used in the OpenAPI specefication document attached to given product version
         * @summary Get operations in version spec
         * @param {string} productId Id of the product
         * @param {string} versionId Id of the product version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductVersionSpecOperations(productId: string, versionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVersionSpecOperations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductVersionSpecOperations(productId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VersionsApi - factory interface
 * @export
 */
export const VersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionsApiFp(configuration)
    return {
        /**
         * Returns paginated list of versions of a given product
         * @summary Get page of product versions
         * @param {string} productId Id of the product
         * @param {PageParameters} [page] Determines which page of search results to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManyProductVersions(productId: string, page?: PageParameters, options?: any): AxiosPromise<ProductVersionListPage> {
            return localVarFp.getManyProductVersions(productId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Return given product version
         * @summary Get product version
         * @param {string} productId Id of the product
         * @param {string} versionId Id of the product version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersion(productId: string, versionId: string, options?: any): AxiosPromise<ProductVersion> {
            return localVarFp.getProductVersion(productId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the OpenAPI specification document attached to given product version
         * @summary Get OpenAPI spec for product version
         * @param {string} productId Id of the product
         * @param {string} versionId Id of the product version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersionSpec(productId: string, versionId: string, options?: any): AxiosPromise<string> {
            return localVarFp.getProductVersionSpec(productId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of operations used in the OpenAPI specefication document attached to given product version
         * @summary Get operations in version spec
         * @param {string} productId Id of the product
         * @param {string} versionId Id of the product version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductVersionSpecOperations(productId: string, versionId: string, options?: any): AxiosPromise<ProductVersionSpecOperations> {
            return localVarFp.getProductVersionSpecOperations(productId, versionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getManyProductVersions operation in VersionsApi.
 * @export
 * @interface VersionsApiGetManyProductVersionsRequest
 */
export interface VersionsApiGetManyProductVersionsRequest {
    /**
     * Id of the product
     * @type {string}
     * @memberof VersionsApiGetManyProductVersions
     */
    readonly productId: string

    /**
     * Determines which page of search results to retrieve.
     * @type {PageParameters}
     * @memberof VersionsApiGetManyProductVersions
     */
    readonly page?: PageParameters
}

/**
 * Request parameters for getProductVersion operation in VersionsApi.
 * @export
 * @interface VersionsApiGetProductVersionRequest
 */
export interface VersionsApiGetProductVersionRequest {
    /**
     * Id of the product
     * @type {string}
     * @memberof VersionsApiGetProductVersion
     */
    readonly productId: string

    /**
     * Id of the product version
     * @type {string}
     * @memberof VersionsApiGetProductVersion
     */
    readonly versionId: string
}

/**
 * Request parameters for getProductVersionSpec operation in VersionsApi.
 * @export
 * @interface VersionsApiGetProductVersionSpecRequest
 */
export interface VersionsApiGetProductVersionSpecRequest {
    /**
     * Id of the product
     * @type {string}
     * @memberof VersionsApiGetProductVersionSpec
     */
    readonly productId: string

    /**
     * Id of the product version
     * @type {string}
     * @memberof VersionsApiGetProductVersionSpec
     */
    readonly versionId: string
}

/**
 * Request parameters for getProductVersionSpecOperations operation in VersionsApi.
 * @export
 * @interface VersionsApiGetProductVersionSpecOperationsRequest
 */
export interface VersionsApiGetProductVersionSpecOperationsRequest {
    /**
     * Id of the product
     * @type {string}
     * @memberof VersionsApiGetProductVersionSpecOperations
     */
    readonly productId: string

    /**
     * Id of the product version
     * @type {string}
     * @memberof VersionsApiGetProductVersionSpecOperations
     */
    readonly versionId: string
}

/**
 * VersionsApi - object-oriented interface
 * @export
 * @class VersionsApi
 * @extends {BaseAPI}
 */
export class VersionsApi extends BaseAPI {
    /**
     * Returns paginated list of versions of a given product
     * @summary Get page of product versions
     * @param {VersionsApiGetManyProductVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getManyProductVersions(requestParameters: VersionsApiGetManyProductVersionsRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).getManyProductVersions(requestParameters.productId, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return given product version
     * @summary Get product version
     * @param {VersionsApiGetProductVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getProductVersion(requestParameters: VersionsApiGetProductVersionRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).getProductVersion(requestParameters.productId, requestParameters.versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the OpenAPI specification document attached to given product version
     * @summary Get OpenAPI spec for product version
     * @param {VersionsApiGetProductVersionSpecRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getProductVersionSpec(requestParameters: VersionsApiGetProductVersionSpecRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).getProductVersionSpec(requestParameters.productId, requestParameters.versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of operations used in the OpenAPI specefication document attached to given product version
     * @summary Get operations in version spec
     * @param {VersionsApiGetProductVersionSpecOperationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getProductVersionSpecOperations(requestParameters: VersionsApiGetProductVersionSpecOperationsRequest, options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).getProductVersionSpecOperations(requestParameters.productId, requestParameters.versionId, options).then((request) => request(this.axios, this.basePath));
    }
}


